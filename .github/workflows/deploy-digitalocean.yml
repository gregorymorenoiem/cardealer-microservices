# =============================================================================
# DEPLOY TO DIGITAL OCEAN KUBERNETES
# =============================================================================
# Workflow dedicado para deployment a DOKS
# Trigger: Manual o despuÃ©s de CI exitoso en main
# =============================================================================

name: ðŸš€ Deploy to Digital Ocean

on:
  # Trigger manual
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      services:
        description: 'Services to deploy (comma-separated or "all")'
        required: false
        default: "all"
        type: string

  # Trigger automÃ¡tico despuÃ©s de CI exitoso
  workflow_run:
    workflows: ["ðŸš€ Smart CI/CD"]
    types:
      - completed
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/${{ github.repository_owner }}

jobs:
  # ============================================
  # Prepare deployment
  # ============================================
  prepare:
    name: ðŸ“‹ Prepare Deployment
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      version: ${{ steps.version.outputs.version }}
      services: ${{ steps.services.outputs.list }}

    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ðŸ·ï¸ Set environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ”¢ Get version
        id: version
        run: |
          VERSION="1.0.${{ github.run_number }}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Deploying version: $VERSION"

      - name: ðŸ“‹ Determine services to deploy
        id: services
        run: |
          if [ "${{ inputs.services }}" == "all" ] || [ -z "${{ inputs.services }}" ]; then
            # Note: vehiclesrentservice, propertiessaleservice, propertiesrentservice disabled temporarily
            SERVICES="frontend-web,gateway,authservice,userservice,roleservice,vehiclessaleservice,mediaservice,notificationservice,billingservice,errorservice,kycservice,auditservice,idempotencyservice,contactservice,adminservice,dealermanagementservice,chatbotservice"
          else
            SERVICES="${{ inputs.services }}"
          fi
          echo "list=$SERVICES" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Services to deploy: $SERVICES"

  # ============================================
  # Deploy to Kubernetes
  # ============================================
  deploy:
    name: ðŸš€ Deploy to ${{ needs.prepare.outputs.environment }}
    needs: prepare
    runs-on: ubuntu-latest
    environment: ${{ needs.prepare.outputs.environment }}

    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ðŸ”§ Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: ðŸ” Configure Kubernetes
        run: |
          doctl kubernetes cluster kubeconfig save ${{ secrets.DO_CLUSTER_NAME }}
          kubectl cluster-info

      - name: ðŸ“¦ Create namespace if not exists
        run: |
          kubectl apply -f k8s/namespace.yaml

      - name: ðŸ”’ Apply secrets
        run: |
          # =============================================================
          # All secrets are created from GitHub Secrets
          # No hardcoded credentials in K8s manifests
          # =============================================================

          PG_USER="${{ secrets.POSTGRES_USER }}"
          PG_PASS="${{ secrets.POSTGRES_PASSWORD }}"
          PG_HOST="${{ secrets.POSTGRES_HOST || 'postgres' }}"
          PG_PORT="${{ secrets.POSTGRES_PORT || '5432' }}"
          JWT_KEY="${{ secrets.JWT_SECRET_KEY }}"
          REDIS_PASS="${{ secrets.REDIS_PASSWORD }}"
          RABBITMQ_USER="${{ secrets.RABBITMQ_USER }}"
          RABBITMQ_PASS="${{ secrets.RABBITMQ_PASSWORD }}"

          # --- PostgreSQL master secret (used by infrastructure.yaml StatefulSet) ---
          kubectl create secret generic postgres-master-secret \
            --from-literal=POSTGRES_PASSWORD="$PG_PASS" \
            --from-literal=password="$PG_PASS" \
            -n okla --dry-run=client -o yaml | kubectl apply -f -

          # --- PostgreSQL password secret (used by databases.yaml per-service StatefulSets) ---
          kubectl create secret generic postgres-password \
            --from-literal=password="$PG_PASS" \
            -n okla --dry-run=client -o yaml | kubectl apply -f -

          # --- Per-service DB secrets ---
          SERVICES="authservice userservice roleservice vehiclessaleservice mediaservice billingservice notificationservice errorservice chatbotservice kycservice auditservice idempotencyservice contactservice adminservice dealermanagementservice reviewservice"

          for SVC in $SERVICES; do
            kubectl create secret generic ${SVC}-db-secret \
              --from-literal=Database__Provider="PostgreSQL" \
              --from-literal=Database__Host="$PG_HOST" \
              --from-literal=Database__Port="$PG_PORT" \
              --from-literal=Database__Database="$SVC" \
              --from-literal=Database__Username="$PG_USER" \
              --from-literal=Database__Password="$PG_PASS" \
              --from-literal=Database__AutoMigrate="true" \
              --from-literal=Database__ConnectionStrings__PostgreSQL="Host=$PG_HOST;Port=$PG_PORT;Database=$SVC;Username=$PG_USER;Password=$PG_PASS;Include Error Detail=false" \
              --from-literal=ConnectionStrings__DefaultConnection="Host=$PG_HOST;Port=$PG_PORT;Database=$SVC;Username=$PG_USER;Password=$PG_PASS;Include Error Detail=false" \
              -n okla --dry-run=client -o yaml | kubectl apply -f -
          done

          # --- JWT secrets (shared by all services) ---
          kubectl create secret generic jwt-secrets \
            --from-literal=Jwt__Key="$JWT_KEY" \
            --from-literal=Jwt__Issuer="okla-api" \
            --from-literal=Jwt__Audience="okla-clients" \
            --from-literal=Jwt__ExpirationMinutes="60" \
            --from-literal=Jwt__RefreshExpirationDays="7" \
            -n okla --dry-run=client -o yaml | kubectl apply -f -

          # --- Redis secrets ---
          kubectl create secret generic redis-secrets \
            --from-literal=ConnectionStrings__Redis="redis:6379,password=$REDIS_PASS" \
            --from-literal=REDIS_PASSWORD="$REDIS_PASS" \
            -n okla --dry-run=client -o yaml | kubectl apply -f -

          # --- RabbitMQ secrets ---
          kubectl create secret generic rabbitmq-secrets \
            --from-literal=RABBITMQ_USER="$RABBITMQ_USER" \
            --from-literal=RABBITMQ_PASSWORD="$RABBITMQ_PASS" \
            --from-literal=RabbitMQ__UserName="$RABBITMQ_USER" \
            --from-literal=RabbitMQ__Password="$RABBITMQ_PASS" \
            -n okla --dry-run=client -o yaml | kubectl apply -f -

          # --- External services ---
          kubectl create secret generic external-services-secrets \
            --from-literal=STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }} \
            --from-literal=STRIPE_WEBHOOK_SECRET=${{ secrets.STRIPE_WEBHOOK_SECRET }} \
            --from-literal=SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }} \
            --from-literal=AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} \
            --from-literal=AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
            -n okla --dry-run=client -o yaml | kubectl apply -f -

          # --- Docker registry secret ---
          # âš ï¸ Uses GHCR_PAT (persistent Fine-grained PAT with read:packages scope)
          # instead of GITHUB_TOKEN (ephemeral, expires after workflow completes).
          # Without a persistent token, pods get ImagePullBackOff after workflow finishes.
          kubectl create secret docker-registry registry-credentials \
            --docker-server=ghcr.io \
            --docker-username=${{ github.repository_owner }} \
            --docker-password=${{ secrets.GHCR_PAT }} \
            -n okla --dry-run=client -o yaml | kubectl apply -f -

          # --- Consolidated okla-secrets (chatbot + shared) ---
          kubectl create secret generic okla-secrets \
            --from-literal=chatbot-db-connection="Host=$PG_HOST;Port=$PG_PORT;Database=chatbotservice;Username=$PG_USER;Password=$PG_PASS;SslMode=Prefer" \
            --from-literal=jwt-secret-key="$JWT_KEY" \
            --from-literal=rabbitmq-user="$RABBITMQ_USER" \
            --from-literal=rabbitmq-password="$RABBITMQ_PASS" \
            --from-literal=whatsapp-verify-token="${{ secrets.WHATSAPP_VERIFY_TOKEN }}" \
            --from-literal=whatsapp-access-token="${{ secrets.WHATSAPP_ACCESS_TOKEN }}" \
            --from-literal=whatsapp-phone-number-id="${{ secrets.WHATSAPP_PHONE_NUMBER_ID }}" \
            -n okla --dry-run=client -o yaml | kubectl apply -f -

          echo "âœ… All secrets created from GitHub Secrets (no hardcoded values)"

      - name: âš™ï¸ Apply ConfigMaps
        run: |
          kubectl apply -f k8s/configmaps.yaml

      - name: ðŸ—„ï¸ Deploy Infrastructure (PostgreSQL + Redis + RabbitMQ)
        run: |
          echo "ðŸ—„ï¸ Deploying consolidated infrastructure..."
          kubectl apply -f k8s/infrastructure.yaml

          echo "â³ Waiting for PostgreSQL to be ready..."
          kubectl rollout status statefulset/postgres -n okla --timeout=180s || true

          echo "â³ Waiting for Redis to be ready..."
          kubectl rollout status deployment/redis -n okla --timeout=60s || true

          echo "â³ Waiting for RabbitMQ to be ready..."
          kubectl rollout status deployment/rabbitmq -n okla --timeout=120s || true

          # Wait for databases to be fully initialized
          echo "â³ Waiting for infrastructure initialization..."
          sleep 30

      - name: Deploy services
        run: |
          SERVICES="${{ needs.prepare.outputs.services }}"

          echo "ðŸš€ Applying all deployments..."
          kubectl apply -f k8s/deployments.yaml

          # Deploy ChatbotService + LLM Server (separate manifest)
          echo "ðŸ¤– Applying ChatbotService + LLM Server..."
          kubectl apply -f k8s/chatbotservice.yaml

          # Restart deployments to pick up new secrets
          for SERVICE in $(echo $SERVICES | tr ',' ' '); do
            echo "ðŸ”„ Restarting $SERVICE..."
            kubectl rollout restart deployment/$SERVICE -n okla 2>/dev/null || true
          done

      - name: ðŸ“¡ Apply Services
        run: |
          kubectl apply -f k8s/services.yaml

      - name: ðŸŒ Apply Ingress
        run: |
          kubectl apply -f k8s/ingress.yaml

      - name: â³ Wait for rollout
        run: |
          SERVICES="${{ needs.prepare.outputs.services }}"

          for SERVICE in $(echo $SERVICES | tr ',' ' '); do
            echo "â³ Waiting for $SERVICE rollout..."
            kubectl rollout status deployment/$SERVICE -n okla --timeout=300s || true
          done

          # LLM Server needs extra time to load the model (~4.5GB)
          echo "â³ Waiting for LLM Server rollout (model loading)..."
          kubectl rollout status deployment/llm-server -n okla --timeout=600s || true

      - name: âœ… Verify deployment
        run: |
          echo "## ðŸ“Š Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get all pods
          echo "### Pods" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n okla >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          # Get all services
          echo "### Services" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get svc -n okla >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          # Get ingress
          echo "### Ingress" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get ingress -n okla >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: ðŸ”” Notify on Slack
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          fields: repo,message,commit,author,action,eventName,ref,workflow
          text: |
            Deployment to ${{ needs.prepare.outputs.environment }}
            Version: ${{ needs.prepare.outputs.version }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true

  # ============================================
  # Health Check
  # ============================================
  health-check:
    name: ðŸ¥ Health Check
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: ðŸ¥ Check endpoints
        run: |
          ENV="${{ needs.prepare.outputs.environment }}"

          if [ "$ENV" == "production" ]; then
            FRONTEND_URL="https://okla.do"
            API_URL="https://api.okla.do"
          else
            FRONTEND_URL="https://staging.okla.do"
            API_URL="https://api-staging.okla.do"
          fi

          echo "ðŸ” Checking $FRONTEND_URL..."
          curl -sf "$FRONTEND_URL/health" || echo "âš ï¸ Frontend health check failed"

          echo "ðŸ” Checking $API_URL..."
          curl -sf "$API_URL/health" || echo "âš ï¸ API health check failed"

      - name: ðŸ“Š Summary
        run: |
          echo "## âœ… Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.prepare.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.prepare.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### URLs" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.prepare.outputs.environment }}" == "production" ]; then
            echo "- Frontend: https://okla.do" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://api.okla.do" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Frontend: https://staging.okla.do" >> $GITHUB_STEP_SUMMARY
            echo "- API: https://api-staging.okla.do" >> $GITHUB_STEP_SUMMARY
          fi

  # ============================================
  # Rollback (Manual)
  # ============================================
  rollback:
    name: âª Rollback
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: [prepare, deploy]
    environment: ${{ needs.prepare.outputs.environment }}

    steps:
      - name: ðŸ”§ Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: ðŸ” Configure Kubernetes
        run: |
          doctl kubernetes cluster kubeconfig save ${{ secrets.DO_CLUSTER_NAME }}

      - name: âª Rollback deployments
        run: |
          SERVICES="${{ needs.prepare.outputs.services }}"

          for SERVICE in $(echo $SERVICES | tr ',' ' '); do
            echo "âª Rolling back $SERVICE..."
            kubectl rollout undo deployment/$SERVICE -n okla || true
          done

      - name: ðŸ“Š Rollback summary
        run: |
          echo "## âª Rollback Executed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Rolled back to previous version due to deployment failure." >> $GITHUB_STEP_SUMMARY
