## Code Bundle - Aggregated Files
## Microservicio: backend\MediaService
## Generado: 11/18/2025 12:55:29
## Carpetas excluidas: bin, obj, Properties

---- File: MediaService.sln ----

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MediaService.Api", "MediaService.Api\MediaService.Api.csproj", "{0CBBBFAB-A77F-499A-BFA1-015566A10141}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MediaService.Application", "MediaService.Application\MediaService.Application.csproj", "{3A044965-C9E1-4E6B-A3A8-0491E936FB8B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MediaService.Domain", "MediaService.Domain\MediaService.Domain.csproj", "{36EE6FD1-229F-408C-916C-83F70772B4C9}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MediaService.Infrastructure", "MediaService.Infrastructure\MediaService.Infrastructure.csproj", "{81D1D93D-267E-48C5-BAD5-296A337FE961}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "MediaService.Shared", "MediaService.Shared\MediaService.Shared.csproj", "{913331D5-28EF-475C-AB12-BAB41DF03DA3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{0CBBBFAB-A77F-499A-BFA1-015566A10141}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0CBBBFAB-A77F-499A-BFA1-015566A10141}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0CBBBFAB-A77F-499A-BFA1-015566A10141}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0CBBBFAB-A77F-499A-BFA1-015566A10141}.Release|Any CPU.Build.0 = Release|Any CPU
		{3A044965-C9E1-4E6B-A3A8-0491E936FB8B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3A044965-C9E1-4E6B-A3A8-0491E936FB8B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3A044965-C9E1-4E6B-A3A8-0491E936FB8B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3A044965-C9E1-4E6B-A3A8-0491E936FB8B}.Release|Any CPU.Build.0 = Release|Any CPU
		{36EE6FD1-229F-408C-916C-83F70772B4C9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{36EE6FD1-229F-408C-916C-83F70772B4C9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{36EE6FD1-229F-408C-916C-83F70772B4C9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{36EE6FD1-229F-408C-916C-83F70772B4C9}.Release|Any CPU.Build.0 = Release|Any CPU
		{81D1D93D-267E-48C5-BAD5-296A337FE961}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{81D1D93D-267E-48C5-BAD5-296A337FE961}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{81D1D93D-267E-48C5-BAD5-296A337FE961}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{81D1D93D-267E-48C5-BAD5-296A337FE961}.Release|Any CPU.Build.0 = Release|Any CPU
		{913331D5-28EF-475C-AB12-BAB41DF03DA3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{913331D5-28EF-475C-AB12-BAB41DF03DA3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{913331D5-28EF-475C-AB12-BAB41DF03DA3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{913331D5-28EF-475C-AB12-BAB41DF03DA3}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal

---- File: MediaService.Api\ApplicationServiceRegistration.cs ----
using FluentValidation;
using FluentValidation.AspNetCore;
using MediaService.Application.Common.Behaviours;
using MediatR;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.DependencyInjection;
using System.Reflection;

namespace MediaService.Application
{
    public static class ApplicationServiceRegistration
    {
        public static IServiceCollection AddApplication(this IServiceCollection services)
        {
            // Registra MediatR
            services.AddMediatR(cfg =>
            {
                cfg.RegisterServicesFromAssembly(Assembly.GetExecutingAssembly());
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(LoggingBehaviour<,>));
                cfg.AddBehavior(typeof(IPipelineBehavior<,>), typeof(ValidationBehaviour<,>));
            });

            // Registra los validadores de FluentValidation 
            services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());

            // Configura FluentValidation para ASP.NET Core
            services.Configure<ApiBehaviorOptions>(options =>
            {
                options.SuppressModelStateInvalidFilter = true;
            });

            return services;
        }
    }
}

---- File: MediaService.Api\appsettings.Development.json ----
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=MediaServiceDb;Trusted_Connection=true;MultipleActiveResultSets=true"
  },
  "Storage": {
    "Provider": "Local",
    "Local": {
      "BasePath": "wwwroot/uploads",
      "BaseUrl": "https://localhost:7000/uploads"
    },
    "Azure": {
      "ConnectionString": "",
      "ContainerName": "media-assets",
      "CdnBaseUrl": "",
      "MaxUploadSizeBytes": 104857600,
      "AllowedContentTypes": [
        "image/jpeg",
        "image/png",
        "image/gif",
        "video/mp4",
        "application/pdf"
      ],
      "SasTokenExpirationMinutes": 60
    },
    "S3": {
      "AccessKey": "",
      "SecretKey": "",
      "Region": "us-east-1",
      "BucketName": "media-service",
      "CdnBaseUrl": "",
      "MaxUploadSizeBytes": 104857600,
      "AllowedContentTypes": [
        "image/jpeg",
        "image/png",
        "image/gif",
        "video/mp4",
        "application/pdf"
      ],
      "PreSignedUrlExpirationMinutes": 60
    }
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "RabbitMQ": {
    "HostName": "localhost",
    "Port": 5672,
    "UserName": "guest",
    "Password": "guest",
    "VirtualHost": "/",
    "MediaEventsExchange": "media.events",
    "MediaCommandsExchange": "media.commands",
    "MediaUploadedQueue": "media.uploaded.queue",
    "MediaProcessedQueue": "media.processed.queue",
    "MediaDeletedQueue": "media.deleted.queue",
    "ProcessMediaQueue": "process.media.queue",
    "MediaUploadedRoutingKey": "media.uploaded",
    "MediaProcessedRoutingKey": "media.processed", 
    "MediaDeletedRoutingKey": "media.deleted",
    "ProcessMediaRoutingKey": "media.process"
  },
  "AllowedHosts": "*"
}

---- File: MediaService.Api\appsettings.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

---- File: MediaService.Api\appsettings.Production.json ----

---- File: MediaService.Api\Dockerfile.dev ----

---- File: MediaService.Api\Dockerfile.prod ----

---- File: MediaService.Api\MediaService.Api.csproj ----
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.8" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.4.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MediaService.Application\MediaService.Application.csproj" />
    <ProjectReference Include="..\MediaService.Shared\MediaService.Shared.csproj" />
    <ProjectReference Include="..\MediaService.Infrastructure\MediaService.Infrastructure.csproj" />
  </ItemGroup>

</Project>

---- File: MediaService.Api\MediaService.Api.http ----
@MediaService.Api_HostAddress = http://localhost:5213

GET {{MediaService.Api_HostAddress}}/weatherforecast/
Accept: application/json

###

---- File: MediaService.Api\Program.cs ----
using MediaService.Application;
using MediaService.Infrastructure;
using MediaService.Infrastructure.Extensions;
using MediaService.Infrastructure.Middleware;
using MediaService.Infrastructure.Messaging;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using MediaService.Infrastructure.HealthChecks;
using FluentValidation;
using Microsoft.AspNetCore.Mvc;

var builder = WebApplication.CreateBuilder(args);

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add application and infrastructure services
builder.Services.AddApplication();
builder.Services.AddInfrastructure(builder.Configuration);


builder.Services.Configure<ApiBehaviorOptions>(options =>
{
    options.SuppressModelStateInvalidFilter = true;
});

// Add RabbitMQ configuration
builder.Services.Configure<RabbitMQSettings>(options =>
{
    var rabbitMQConfig = builder.Configuration.GetSection("RabbitMQ");
    options.HostName = rabbitMQConfig["HostName"] ?? "localhost";
    options.Port = int.Parse(rabbitMQConfig["Port"] ?? "5672");
    options.UserName = rabbitMQConfig["UserName"] ?? "guest";
    options.Password = rabbitMQConfig["Password"] ?? "guest";
    options.VirtualHost = rabbitMQConfig["VirtualHost"] ?? "/";
    options.MediaEventsExchange = rabbitMQConfig["MediaEventsExchange"] ?? "media.events";
    options.MediaCommandsExchange = rabbitMQConfig["MediaCommandsExchange"] ?? "media.commands";
    options.MediaUploadedQueue = rabbitMQConfig["MediaUploadedQueue"] ?? "media.uploaded.queue";
    options.MediaProcessedQueue = rabbitMQConfig["MediaProcessedQueue"] ?? "media.processed.queue";
    options.MediaDeletedQueue = rabbitMQConfig["MediaDeletedQueue"] ?? "media.deleted.queue";
    options.ProcessMediaQueue = rabbitMQConfig["ProcessMediaQueue"] ?? "process.media.queue";
    options.MediaUploadedRoutingKey = rabbitMQConfig["MediaUploadedRoutingKey"] ?? "media.uploaded";
    options.MediaProcessedRoutingKey = rabbitMQConfig["MediaProcessedRoutingKey"] ?? "media.processed";
    options.MediaDeletedRoutingKey = rabbitMQConfig["MediaDeletedRoutingKey"] ?? "media.deleted";
    options.ProcessMediaRoutingKey = rabbitMQConfig["ProcessMediaRoutingKey"] ?? "media.process";
});

// Add RabbitMQ services
builder.Services.AddSingleton<IRabbitMQMediaProducer, RabbitMQMediaProducer>();
builder.Services.AddHostedService<RabbitMQMediaConsumer>();

// Add health checks
builder.Services.AddHealthChecks()
    .AddCheck<DatabaseHealthCheck>("database", HealthStatus.Unhealthy)
    .AddCheck<StorageHealthCheck>("storage", HealthStatus.Degraded);

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

// Use custom middleware
app.UseMiddleware<ErrorHandlingMiddleware>();

app.UseAuthorization();
app.MapControllers();

// Map health checks
app.MapHealthChecks("/health");

app.Run();

---- File: MediaService.Api\Controllers\HealthController.cs ----
// backend\MediaService\MediaService.Api\Controllers\HealthController.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Diagnostics.HealthChecks;

namespace MediaService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class HealthController : ControllerBase
{
    private readonly HealthCheckService _healthCheckService;

    public HealthController(HealthCheckService healthCheckService)
    {
        _healthCheckService = healthCheckService;
    }

    [HttpGet]
    public async Task<IActionResult> Get()
    {
        var report = await _healthCheckService.CheckHealthAsync();
        return report.Status == HealthStatus.Healthy ? Ok(report) : StatusCode(503, report);
    }
}

---- File: MediaService.Api\Controllers\MediaController.cs ----
using MediaService.Application.Features.Media.Commands.InitUpload;
using MediaService.Application.Features.Media.Commands.FinalizeUpload;
using MediaService.Application.Features.Media.Queries.GetMedia;
using MediaService.Shared;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace MediaService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class MediaController : ControllerBase
{
    private readonly IMediator _mediator;

    public MediaController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost("upload/init")]
    public async Task<ActionResult<ApiResponse<InitUploadResponse>>> InitUpload(InitUploadCommand command)
    {
        var result = await _mediator.Send(command);
        return Ok(result);
    }

    [HttpPost("upload/finalize/{mediaId}")]
    public async Task<ActionResult<ApiResponse<FinalizeUploadResponse>>> FinalizeUpload(string mediaId)
    {
        var command = new FinalizeUploadCommand(mediaId);
        var result = await _mediator.Send(command);
        return Ok(result);
    }

    [HttpGet("{mediaId}")]
    public async Task<ActionResult<ApiResponse<GetMediaResponse>>> GetMedia(string mediaId)
    {
        var query = new GetMediaQuery(mediaId);
        var result = await _mediator.Send(query);
        return Ok(result);
    }
}

---- File: MediaService.Application\MediaService.Application.csproj ----
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  
  <ItemGroup>
    <ProjectReference Include="..\MediaService.Domain\MediaService.Domain.csproj" />
    <ProjectReference Include="..\MediaService.Shared\MediaService.Shared.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="FluentValidation" Version="11.9.0" />
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
  </ItemGroup>



</Project>

---- File: MediaService.Application\Common\Behaviours\LoggingBehaviour.cs ----
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Common.Behaviours;

public class LoggingBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<LoggingBehaviour<TRequest, TResponse>> _logger;

    public LoggingBehaviour(ILogger<LoggingBehaviour<TRequest, TResponse>> logger)
    {
        _logger = logger;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        var requestType = request.GetType().Name;

        _logger.LogInformation("Handling {RequestName} ({RequestType})", requestName, requestType);

        try
        {
            var startTime = DateTime.UtcNow;
            var response = await next();
            var duration = DateTime.UtcNow - startTime;

            _logger.LogInformation("Handled {RequestName} successfully in {Duration}ms",
                requestName, duration.TotalMilliseconds);

            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error handling {RequestName}", requestName);
            throw;
        }
    }
}

---- File: MediaService.Application\Common\Behaviours\ValidationBehaviour.cs ----
using FluentValidation;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Common.Behaviours;

public class ValidationBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<ValidationBehaviour<TRequest, TResponse>> _logger;
    private readonly IEnumerable<IValidator<TRequest>> _validators;

    public ValidationBehaviour(
        ILogger<ValidationBehaviour<TRequest, TResponse>> logger,
        IEnumerable<IValidator<TRequest>> validators)
    {
        _logger = logger;
        _validators = validators;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        if (!_validators.Any())
        {
            return await next();
        }

        var context = new ValidationContext<TRequest>(request);

        var validationResults = await Task.WhenAll(
            _validators.Select(v => v.ValidateAsync(context, cancellationToken)));

        var failures = validationResults
            .Where(r => r.Errors.Any())
            .SelectMany(r => r.Errors)
            .ToList();

        if (failures.Any())
        {
            _logger.LogWarning("Validation failed for {RequestType}. Errors: {ValidationErrors}",
                typeof(TRequest).Name, string.Join("; ", failures.Select(f => f.ErrorMessage)));

            throw new ValidationException(failures);
        }

        _logger.LogDebug("Validation successful for {RequestType}", typeof(TRequest).Name);
        return await next();
    }
}

---- File: MediaService.Application\DTOs\MediaDto.cs ----
namespace MediaService.Application.DTOs;

public class MediaDto
{
    public string Id { get; set; } = string.Empty;
    public string OwnerId { get; set; } = string.Empty;
    public string? Context { get; set; }
    public string Type { get; set; } = string.Empty;
    public string OriginalFileName { get; set; } = string.Empty;
    public string ContentType { get; set; } = string.Empty;
    public long SizeBytes { get; set; }
    public string Status { get; set; } = string.Empty;
    public string? CdnUrl { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
    public string? ProcessingError { get; set; }
    public List<MediaVariantDto> Variants { get; set; } = new();

    public static MediaDto FromEntity(Domain.Entities.MediaAsset entity)
    {
        return new MediaDto
        {
            Id = entity.Id,
            OwnerId = entity.OwnerId,
            Context = entity.Context,
            Type = entity.Type.ToString(),
            OriginalFileName = entity.OriginalFileName,
            ContentType = entity.ContentType,
            SizeBytes = entity.SizeBytes,
            Status = entity.Status.ToString(),
            CdnUrl = entity.CdnUrl,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt,
            ProcessedAt = entity.ProcessedAt,
            ProcessingError = entity.ProcessingError,
            Variants = entity.Variants.Select(MediaVariantDto.FromEntity).ToList()
        };
    }
}

---- File: MediaService.Application\DTOs\MediaVariantDto.cs ----
namespace MediaService.Application.DTOs;

public class MediaVariantDto
{
    public string Id { get; set; } = string.Empty;
    public string MediaAssetId { get; set; } = string.Empty;
    public string Name { get; set; } = string.Empty;
    public string StorageKey { get; set; } = string.Empty;
    public string? CdnUrl { get; set; }
    public int? Width { get; set; }
    public int? Height { get; set; }
    public long SizeBytes { get; set; }
    public string? Format { get; set; }
    public int? Quality { get; set; }
    public string? VideoProfile { get; set; }
    public int? Bitrate { get; set; }
    public TimeSpan? Duration { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }

    public static MediaVariantDto FromEntity(Domain.Entities.MediaVariant entity)
    {
        return new MediaVariantDto
        {
            Id = entity.Id,
            MediaAssetId = entity.MediaAssetId,
            Name = entity.Name,
            StorageKey = entity.StorageKey,
            CdnUrl = entity.CdnUrl,
            Width = entity.Width,
            Height = entity.Height,
            SizeBytes = entity.SizeBytes,
            Format = entity.Format,
            Quality = entity.Quality,
            VideoProfile = entity.VideoProfile,
            Bitrate = entity.Bitrate,
            Duration = entity.Duration,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt
        };
    }
}

---- File: MediaService.Application\DTOs\UploadResponseDto.cs ----
namespace MediaService.Application.DTOs;

public class UploadResponseDto
{
    public string MediaId { get; set; } = string.Empty;
    public string UploadUrl { get; set; } = string.Empty;
    public DateTime ExpiresAt { get; set; }
    public Dictionary<string, string> UploadHeaders { get; set; } = new();
    public string StorageKey { get; set; } = string.Empty;
}

---- File: MediaService.Application\Features\Media\Commands\DeleteMedia\DeleteMediaCommand.cs ----
using MediaService.Shared;
using MediatR;

namespace MediaService.Application.Features.Media.Commands.DeleteMedia;

public class DeleteMediaCommand : IRequest<ApiResponse<DeleteMediaResponse>>
{
    public string MediaId { get; set; } = string.Empty;
    public string RequestedBy { get; set; } = string.Empty;
    public string? Reason { get; set; }

    public DeleteMediaCommand(string mediaId, string requestedBy, string? reason = null)
    {
        MediaId = mediaId;
        RequestedBy = requestedBy;
        Reason = reason;
    }
}

---- File: MediaService.Application\Features\Media\Commands\DeleteMedia\DeleteMediaCommandHandler.cs ----
using MediaService.Domain.Entities;
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Domain.Interfaces.Services;
using MediaService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Features.Media.Commands.DeleteMedia;

public class DeleteMediaCommandHandler : IRequestHandler<DeleteMediaCommand, ApiResponse<DeleteMediaResponse>>
{
    private readonly IMediaRepository _mediaRepository;
    private readonly IMediaVariantRepository _variantRepository;
    private readonly IMediaStorageService _storageService;
    private readonly ILogger<DeleteMediaCommandHandler> _logger;

    public DeleteMediaCommandHandler(
        IMediaRepository mediaRepository,
        IMediaVariantRepository variantRepository,
        IMediaStorageService storageService,
        ILogger<DeleteMediaCommandHandler> logger)
    {
        _mediaRepository = mediaRepository;
        _variantRepository = variantRepository;
        _storageService = storageService;
        _logger = logger;
    }

    public async Task<ApiResponse<DeleteMediaResponse>> Handle(DeleteMediaCommand request, CancellationToken cancellationToken)
    {
        try
        {
            var mediaAsset = await _mediaRepository.GetByIdAsync(request.MediaId, cancellationToken);
            if (mediaAsset == null)
                return ApiResponse<DeleteMediaResponse>.Fail("Media not found");

            var storageKeys = mediaAsset.GetAllStorageKeys();
            var deletedFiles = 0;

            foreach (var storageKey in storageKeys)
            {
                try
                {
                    await _storageService.DeleteFileAsync(storageKey);
                    deletedFiles++;
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to delete file from storage: {StorageKey}", storageKey);
                }
            }

            await _variantRepository.DeleteByMediaIdAsync(request.MediaId, cancellationToken);
            await _mediaRepository.DeleteAsync(mediaAsset, cancellationToken);

            var response = new DeleteMediaResponse(
                request.MediaId,
                true,
                deletedFiles,
                $"Successfully deleted media and {deletedFiles} associated files"
            );

            return ApiResponse<DeleteMediaResponse>.Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error deleting media");
            return ApiResponse<DeleteMediaResponse>.Fail("Error deleting media");
        }
    }
}

---- File: MediaService.Application\Features\Media\Commands\DeleteMedia\DeleteMediaCommandValidator.cs ----
using FluentValidation;

namespace MediaService.Application.Features.Media.Commands.DeleteMedia;

public class DeleteMediaCommandValidator : AbstractValidator<DeleteMediaCommand>
{
    public DeleteMediaCommandValidator()
    {
        RuleFor(x => x.MediaId).NotEmpty();
        RuleFor(x => x.RequestedBy).NotEmpty();
    }
}

---- File: MediaService.Application\Features\Media\Commands\DeleteMedia\DeleteMediaResponse.cs ----
namespace MediaService.Application.Features.Media.Commands.DeleteMedia;

public class DeleteMediaResponse
{
    public string MediaId { get; set; } = string.Empty;
    public bool Success { get; set; }
    public int DeletedFiles { get; set; }
    public string? Message { get; set; }

    public DeleteMediaResponse() { }

    public DeleteMediaResponse(string mediaId, bool success, int deletedFiles, string? message = null)
    {
        MediaId = mediaId;
        Success = success;
        DeletedFiles = deletedFiles;
        Message = message;
    }
}

---- File: MediaService.Application\Features\Media\Commands\FinalizeUpload\FinalizeUploadCommand.cs ----
using MediaService.Shared;
using MediatR;

namespace MediaService.Application.Features.Media.Commands.FinalizeUpload;

public class FinalizeUploadCommand : IRequest<ApiResponse<FinalizeUploadResponse>>
{
    public string MediaId { get; set; } = string.Empty;

    public FinalizeUploadCommand(string mediaId)
    {
        MediaId = mediaId;
    }
}

---- File: MediaService.Application\Features\Media\Commands\FinalizeUpload\FinalizeUploadCommandHandler.cs ----
using MediaService.Domain.Entities;
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Domain.Interfaces.Services;
using MediaService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Features.Media.Commands.FinalizeUpload;

public class FinalizeUploadCommandHandler : IRequestHandler<FinalizeUploadCommand, ApiResponse<FinalizeUploadResponse>>
{
    private readonly IMediaRepository _mediaRepository;
    private readonly IMediaStorageService _storageService;
    private readonly ILogger<FinalizeUploadCommandHandler> _logger;

    public FinalizeUploadCommandHandler(
        IMediaRepository mediaRepository,
        IMediaStorageService storageService,
        ILogger<FinalizeUploadCommandHandler> logger)
    {
        _mediaRepository = mediaRepository;
        _storageService = storageService;
        _logger = logger;
    }

    public async Task<ApiResponse<FinalizeUploadResponse>> Handle(FinalizeUploadCommand request, CancellationToken cancellationToken)
    {
        try
        {
            var mediaAsset = await _mediaRepository.GetByIdAsync(request.MediaId, cancellationToken);
            if (mediaAsset == null)
                return ApiResponse<FinalizeUploadResponse>.Fail("Media not found");

            var fileExists = await _storageService.FileExistsAsync(mediaAsset.StorageKey);
            if (!fileExists)
            {
                mediaAsset.MarkAsFailed("File not found in storage");
                await _mediaRepository.UpdateAsync(mediaAsset, cancellationToken);
                return ApiResponse<FinalizeUploadResponse>.Fail("Uploaded file not found");
            }

            var cdnUrl = await _storageService.GetFileUrlAsync(mediaAsset.StorageKey);
            mediaAsset.MarkAsProcessed(cdnUrl);
            await _mediaRepository.UpdateAsync(mediaAsset, cancellationToken);

            var response = new FinalizeUploadResponse(
                mediaAsset.Id,
                mediaAsset.Status.ToString(),
                cdnUrl,
                mediaAsset.ProcessedAt
            );

            return ApiResponse<FinalizeUploadResponse>.Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error finalizing upload");
            return ApiResponse<FinalizeUploadResponse>.Fail("Error finalizing upload");
        }
    }
}

---- File: MediaService.Application\Features\Media\Commands\FinalizeUpload\FinalizeUploadCommandValidator.cs ----
using FluentValidation;

namespace MediaService.Application.Features.Media.Commands.FinalizeUpload;

public class FinalizeUploadCommandValidator : AbstractValidator<FinalizeUploadCommand>
{
    public FinalizeUploadCommandValidator()
    {
        RuleFor(x => x.MediaId).NotEmpty();
    }
}

---- File: MediaService.Application\Features\Media\Commands\FinalizeUpload\FinalizeUploadResponse.cs ----
namespace MediaService.Application.Features.Media.Commands.FinalizeUpload;

public class FinalizeUploadResponse
{
    public string MediaId { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public string? CdnUrl { get; set; }
    public DateTime? ProcessedAt { get; set; }

    public FinalizeUploadResponse() { }

    public FinalizeUploadResponse(string mediaId, string status, string? cdnUrl = null, DateTime? processedAt = null)
    {
        MediaId = mediaId;
        Status = status;
        CdnUrl = cdnUrl;
        ProcessedAt = processedAt;
    }
}

---- File: MediaService.Application\Features\Media\Commands\InitUpload\InitUploadCommand.cs ----
using MediaService.Shared;
using MediatR;

namespace MediaService.Application.Features.Media.Commands.InitUpload;

public class InitUploadCommand : IRequest<ApiResponse<InitUploadResponse>>
{
    public string OwnerId { get; set; } = string.Empty;
    public string? Context { get; set; }
    public string FileName { get; set; } = string.Empty;
    public string ContentType { get; set; } = string.Empty;
    public long FileSize { get; set; }

    public InitUploadCommand(string ownerId, string? context, string fileName, string contentType, long fileSize)
    {
        OwnerId = ownerId;
        Context = context;
        FileName = fileName;
        ContentType = contentType;
        FileSize = fileSize;
    }
}


---- File: MediaService.Application\Features\Media\Commands\InitUpload\InitUploadCommandHandler.cs ----
using MediaService.Domain.Entities;
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Domain.Interfaces.Services;
using MediaService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Features.Media.Commands.InitUpload;

public class InitUploadCommandHandler : IRequestHandler<InitUploadCommand, ApiResponse<InitUploadResponse>>
{
    private readonly IMediaRepository _mediaRepository;
    private readonly IMediaStorageService _storageService;
    private readonly ILogger<InitUploadCommandHandler> _logger;

    public InitUploadCommandHandler(
        IMediaRepository mediaRepository,
        IMediaStorageService storageService,
        ILogger<InitUploadCommandHandler> logger)
    {
        _mediaRepository = mediaRepository;
        _storageService = storageService;
        _logger = logger;
    }

    public async Task<ApiResponse<InitUploadResponse>> Handle(InitUploadCommand request, CancellationToken cancellationToken)
    {
        try
        {
            var mediaType = DetermineMediaType(request.ContentType);
            var storageKey = await _storageService.GenerateStorageKeyAsync(
                request.OwnerId, request.Context, request.FileName);

            MediaAsset mediaAsset = mediaType switch
            {
                Domain.Enums.MediaType.Image => new ImageMedia(
                    request.OwnerId, request.Context, request.FileName,
                    request.ContentType, request.FileSize, storageKey, 0, 0),
                Domain.Enums.MediaType.Video => new VideoMedia(
                    request.OwnerId, request.Context, request.FileName,
                    request.ContentType, request.FileSize, storageKey),
                Domain.Enums.MediaType.Document => new DocumentMedia(
                    request.OwnerId, request.Context, request.FileName,
                    request.ContentType, request.FileSize, storageKey),
                _ => new MediaAsset(
                    request.OwnerId, request.Context, mediaType,
                    request.FileName, request.ContentType, request.FileSize, storageKey)
            };

            var uploadInfo = await _storageService.GenerateUploadUrlAsync(storageKey, request.ContentType);
            await _mediaRepository.AddAsync(mediaAsset, cancellationToken);

            var response = new InitUploadResponse(
                mediaAsset.Id,
                uploadInfo.UploadUrl,
                uploadInfo.ExpiresAt,
                uploadInfo.Headers,
                storageKey
            );

            return ApiResponse<InitUploadResponse>.Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error initializing upload");
            return ApiResponse<InitUploadResponse>.Fail("Error initializing upload");
        }
    }

    private static Domain.Enums.MediaType DetermineMediaType(string contentType)
    {
        return contentType.ToLower() switch
        {
            var ct when ct.StartsWith("image/") => Domain.Enums.MediaType.Image,
            var ct when ct.StartsWith("video/") => Domain.Enums.MediaType.Video,
            var ct when ct.StartsWith("audio/") => Domain.Enums.MediaType.Audio,
            _ => Domain.Enums.MediaType.Document
        };
    }
}

---- File: MediaService.Application\Features\Media\Commands\InitUpload\InitUploadCommandValidator.cs ----
using FluentValidation;
using MediaService.Shared;

namespace MediaService.Application.Features.Media.Commands.InitUpload;

public class InitUploadCommandValidator : AbstractValidator<InitUploadCommand>
{
    public InitUploadCommandValidator()
    {
        RuleFor(x => x.OwnerId).NotEmpty();
        RuleFor(x => x.FileName).NotEmpty();
        RuleFor(x => x.ContentType).NotEmpty();
        RuleFor(x => x.FileSize).GreaterThan(0);
    }
}

---- File: MediaService.Application\Features\Media\Commands\InitUpload\InitUploadResponse.cs ----
namespace MediaService.Application.Features.Media.Commands.InitUpload;

public class InitUploadResponse
{
    public string MediaId { get; set; } = string.Empty;
    public string UploadUrl { get; set; } = string.Empty;
    public DateTime ExpiresAt { get; set; }
    public Dictionary<string, string> UploadHeaders { get; set; } = new();
    public string StorageKey { get; set; } = string.Empty;

    public InitUploadResponse() { }

    public InitUploadResponse(string mediaId, string uploadUrl, DateTime expiresAt, Dictionary<string, string> uploadHeaders, string storageKey)
    {
        MediaId = mediaId;
        UploadUrl = uploadUrl;
        ExpiresAt = expiresAt;
        UploadHeaders = uploadHeaders;
        StorageKey = storageKey;
    }
}

---- File: MediaService.Application\Features\Media\Commands\ProcessMedia\ProcessMediaCommand.cs ----
using MediaService.Shared;
using MediatR;

namespace MediaService.Application.Features.Media.Commands.ProcessMedia;

public class ProcessMediaCommand : IRequest<ApiResponse<ProcessMediaResponse>>
{
    public string MediaId { get; set; } = string.Empty;
    public string? ProcessingType { get; set; }
    public Dictionary<string, object>? ProcessingOptions { get; set; }

    public ProcessMediaCommand(string mediaId, string? processingType = null, Dictionary<string, object>? processingOptions = null)
    {
        MediaId = mediaId;
        ProcessingType = processingType;
        ProcessingOptions = processingOptions;
    }
}

---- File: MediaService.Application\Features\Media\Commands\ProcessMedia\ProcessMediaCommandHandler.cs ----
using MediaService.Domain.Entities;
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Domain.Interfaces.Services;
using MediaService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Features.Media.Commands.ProcessMedia;

public class ProcessMediaCommandHandler : IRequestHandler<ProcessMediaCommand, ApiResponse<ProcessMediaResponse>>
{
    private readonly IMediaRepository _mediaRepository;
    private readonly IImageProcessor _imageProcessor;
    private readonly IVideoProcessor _videoProcessor;
    private readonly IMediaStorageService _storageService;
    private readonly ILogger<ProcessMediaCommandHandler> _logger;

    public ProcessMediaCommandHandler(
        IMediaRepository mediaRepository,
        IImageProcessor imageProcessor,
        IVideoProcessor videoProcessor,
        IMediaStorageService storageService,
        ILogger<ProcessMediaCommandHandler> logger)
    {
        _mediaRepository = mediaRepository;
        _imageProcessor = imageProcessor;
        _videoProcessor = videoProcessor;
        _storageService = storageService;
        _logger = logger;
    }

    public async Task<ApiResponse<ProcessMediaResponse>> Handle(ProcessMediaCommand request, CancellationToken cancellationToken)
    {
        try
        {
            var mediaAsset = await _mediaRepository.GetByIdAsync(request.MediaId, cancellationToken);
            if (mediaAsset == null)
                return ApiResponse<ProcessMediaResponse>.Fail("Media not found");

            mediaAsset.MarkAsProcessing();
            await _mediaRepository.UpdateAsync(mediaAsset, cancellationToken);

            int variantsGenerated = 0;
            string status = "processed";
            string? message = null;

            try
            {
                switch (mediaAsset.Type)
                {
                    case Domain.Enums.MediaType.Image:
                        variantsGenerated = await ProcessImageAsync((ImageMedia)mediaAsset, cancellationToken);
                        message = $"Generated {variantsGenerated} image variants";
                        break;
                    case Domain.Enums.MediaType.Video:
                        variantsGenerated = await ProcessVideoAsync((VideoMedia)mediaAsset, cancellationToken);
                        message = $"Generated {variantsGenerated} video variants";
                        break;
                    default:
                        message = "No processing required for this media type";
                        break;
                }

                var cdnUrl = await _storageService.GetFileUrlAsync(mediaAsset.StorageKey);
                mediaAsset.MarkAsProcessed(cdnUrl);
            }
            catch (Exception ex)
            {
                mediaAsset.MarkAsFailed($"Processing failed: {ex.Message}");
                status = "failed";
                message = ex.Message;
            }

            await _mediaRepository.UpdateAsync(mediaAsset, cancellationToken);

            var response = new ProcessMediaResponse(
                mediaAsset.Id,
                status,
                variantsGenerated,
                message,
                mediaAsset.ProcessedAt
            );

            return ApiResponse<ProcessMediaResponse>.Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing media");
            return ApiResponse<ProcessMediaResponse>.Fail("Error processing media");
        }
    }

    private async Task<int> ProcessImageAsync(ImageMedia image, CancellationToken cancellationToken)
    {
        using var originalStream = await _storageService.DownloadFileAsync(image.StorageKey);
        var imageInfo = await _imageProcessor.GetImageInfoAsync(originalStream);
        image.SetDimensions(imageInfo.Width, imageInfo.Height);

        var variants = new[]
        {
            new { Name = "thumb", Width = 200, Height = 200, Quality = 80 },
            new { Name = "small", Width = 400, Height = 400, Quality = 80 },
            new { Name = "medium", Width = 800, Height = 800, Quality = 85 }
        };

        var variantsGenerated = 0;

        foreach (var variant in variants)
        {
            try
            {
                originalStream.Position = 0;
                using var variantStream = await _imageProcessor.CreateThumbnailAsync(
                    originalStream, variant.Width, variant.Height);

                var variantStorageKey = $"{image.StorageKey}_{variant.Name}";
                await _storageService.UploadFileAsync(variantStorageKey, variantStream, image.ContentType);

                var mediaVariant = new MediaVariant(
                    image.Id, variant.Name, variantStorageKey,
                    variant.Width, variant.Height, variantStream.Length,
                    ".jpg", variant.Quality);

                image.AddVariant(mediaVariant);
                variantsGenerated++;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to create variant {VariantName}", variant.Name);
            }
        }

        return variantsGenerated;
    }

    private async Task<int> ProcessVideoAsync(VideoMedia video, CancellationToken cancellationToken)
    {
        using var originalStream = await _storageService.DownloadFileAsync(video.StorageKey);
        var videoInfo = await _videoProcessor.GetVideoInfoAsync(originalStream);
        video.SetDuration(videoInfo.Duration);
        video.SetDimensions(videoInfo.Width, videoInfo.Height);

        var variantsGenerated = 0;

        try
        {
            originalStream.Position = 0;
            var thumbnails = await _videoProcessor.GenerateThumbnailsAsync(originalStream, 3, 320, 180);

            for (int i = 0; i < thumbnails.Count; i++)
            {
                var thumbnailStorageKey = $"{video.StorageKey}_thumb_{i + 1}.jpg";
                await _storageService.UploadFileAsync(thumbnailStorageKey, thumbnails[i], "image/jpeg");

                var thumbnailVariant = new MediaVariant(
                    video.Id, $"thumb_{i + 1}", thumbnailStorageKey,
                    320, 180, thumbnails[i].Length, ".jpg", 85);

                video.AddVariant(thumbnailVariant);
                variantsGenerated++;
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to generate thumbnails for video");
        }

        return variantsGenerated;
    }
}

---- File: MediaService.Application\Features\Media\Commands\ProcessMedia\ProcessMediaResponse.cs ----
namespace MediaService.Application.Features.Media.Commands.ProcessMedia;

public class ProcessMediaResponse
{
    public string MediaId { get; set; } = string.Empty;
    public string Status { get; set; } = string.Empty;
    public int VariantsGenerated { get; set; }
    public string? Message { get; set; }
    public DateTime? ProcessedAt { get; set; }

    public ProcessMediaResponse() { }

    public ProcessMediaResponse(string mediaId, string status, int variantsGenerated, string? message = null, DateTime? processedAt = null)
    {
        MediaId = mediaId;
        Status = status;
        VariantsGenerated = variantsGenerated;
        Message = message;
        ProcessedAt = processedAt;
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMedia\GetMediaQuery.cs ----
using MediaService.Application.DTOs;
using MediaService.Shared;
using MediatR;

namespace MediaService.Application.Features.Media.Queries.GetMedia;

public class GetMediaQuery : IRequest<ApiResponse<GetMediaResponse>>
{
    public string MediaId { get; set; } = string.Empty;
    public bool IncludeVariants { get; set; } = true;

    public GetMediaQuery(string mediaId, bool includeVariants = true)
    {
        MediaId = mediaId;
        IncludeVariants = includeVariants;
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMedia\GetMediaQueryHandler.cs ----
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Features.Media.Queries.GetMedia;

public class GetMediaQueryHandler : IRequestHandler<GetMediaQuery, ApiResponse<GetMediaResponse>>
{
    private readonly IMediaRepository _mediaRepository;
    private readonly ILogger<GetMediaQueryHandler> _logger;

    public GetMediaQueryHandler(
        IMediaRepository mediaRepository,
        ILogger<GetMediaQueryHandler> logger)
    {
        _mediaRepository = mediaRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<GetMediaResponse>> Handle(GetMediaQuery request, CancellationToken cancellationToken)
    {
        try
        {
            var mediaAsset = await _mediaRepository.GetByIdAsync(request.MediaId, cancellationToken);
            if (mediaAsset == null)
                return ApiResponse<GetMediaResponse>.Fail("Media not found");

            var mediaDto = DTOs.MediaDto.FromEntity(mediaAsset);
            var response = new GetMediaResponse(mediaDto);

            return ApiResponse<GetMediaResponse>.Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media");
            return ApiResponse<GetMediaResponse>.Fail("Error retrieving media");
        }
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMedia\GetMediaResponse.cs ----
using MediaService.Application.DTOs;

namespace MediaService.Application.Features.Media.Queries.GetMedia;

public class GetMediaResponse
{
    public MediaDto Media { get; set; } = new();

    public GetMediaResponse() { }

    public GetMediaResponse(MediaDto media)
    {
        Media = media;
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMediaByOwner\GetMediaByOwnerQuery.cs ----
using MediaService.Application.DTOs;
using MediaService.Shared;
using MediatR;

namespace MediaService.Application.Features.Media.Queries.GetMediaByOwner;

public class GetMediaByOwnerQuery : IRequest<ApiResponse<GetMediaByOwnerResponse>>
{
    public string OwnerId { get; set; } = string.Empty;
    public string? Context { get; set; }
    public string? MediaType { get; set; }
    public DateTime? FromDate { get; set; }
    public DateTime? ToDate { get; set; }
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;
    public bool IncludeVariants { get; set; } = false;

    public GetMediaByOwnerQuery(string ownerId, string? context = null)
    {
        OwnerId = ownerId;
        Context = context;
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMediaByOwner\GetMediaByOwnerQueryHandler.cs ----
using MediaService.Application.DTOs;
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Features.Media.Queries.GetMediaByOwner;

public class GetMediaByOwnerQueryHandler : IRequestHandler<GetMediaByOwnerQuery, ApiResponse<GetMediaByOwnerResponse>>
{
    private readonly IMediaRepository _mediaRepository;
    private readonly ILogger<GetMediaByOwnerQueryHandler> _logger;

    public GetMediaByOwnerQueryHandler(
        IMediaRepository mediaRepository,
        ILogger<GetMediaByOwnerQueryHandler> logger)
    {
        _mediaRepository = mediaRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<GetMediaByOwnerResponse>> Handle(GetMediaByOwnerQuery request, CancellationToken cancellationToken)
    {
        try
        {
            Domain.Enums.MediaType? mediaType = null;
            if (!string.IsNullOrEmpty(request.MediaType) &&
                Enum.TryParse<Domain.Enums.MediaType>(request.MediaType, true, out var parsedType))
            {
                mediaType = parsedType;
            }

            var (items, totalCount) = await _mediaRepository.GetPaginatedAsync(
                ownerId: request.OwnerId,
                context: request.Context,
                type: mediaType,
                fromDate: request.FromDate,
                toDate: request.ToDate,
                page: request.Page,
                pageSize: request.PageSize);

            var mediaDtos = items.Select(DTOs.MediaDto.FromEntity).ToList();
            var paginatedResult = new PaginatedResult<MediaDto>
            {
                Items = mediaDtos,
                TotalCount = totalCount,
                Page = request.Page,
                PageSize = request.PageSize
            };

            var response = new GetMediaByOwnerResponse(request.OwnerId, paginatedResult);
            return ApiResponse<GetMediaByOwnerResponse>.Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media for owner");
            return ApiResponse<GetMediaByOwnerResponse>.Fail("Error retrieving media for owner");
        }
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMediaByOwner\GetMediaByOwnerResponse.cs ----
using MediaService.Application.DTOs;
using MediaService.Shared;

namespace MediaService.Application.Features.Media.Queries.GetMediaByOwner;

public class GetMediaByOwnerResponse
{
    public string OwnerId { get; set; } = string.Empty;
    public PaginatedResult<MediaDto> Media { get; set; } = new();

    public GetMediaByOwnerResponse() { }

    public GetMediaByOwnerResponse(string ownerId, PaginatedResult<MediaDto> media)
    {
        OwnerId = ownerId;
        Media = media;
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMediaVariants\GetMediaVariantsQuery.cs ----
using MediaService.Application.DTOs;
using MediaService.Shared;
using MediatR;

namespace MediaService.Application.Features.Media.Queries.GetMediaVariants;

public class GetMediaVariantsQuery : IRequest<ApiResponse<GetMediaVariantsResponse>>
{
    public string MediaId { get; set; } = string.Empty;
    public string? VariantName { get; set; }

    public GetMediaVariantsQuery(string mediaId, string? variantName = null)
    {
        MediaId = mediaId;
        VariantName = variantName;
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMediaVariants\GetMediaVariantsQueryHandler.cs ----
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Features.Media.Queries.GetMediaVariants;

public class GetMediaVariantsQueryHandler : IRequestHandler<GetMediaVariantsQuery, ApiResponse<GetMediaVariantsResponse>>
{
    private readonly IMediaVariantRepository _variantRepository;
    private readonly IMediaRepository _mediaRepository;
    private readonly ILogger<GetMediaVariantsQueryHandler> _logger;

    public GetMediaVariantsQueryHandler(
        IMediaVariantRepository variantRepository,
        IMediaRepository mediaRepository,
        ILogger<GetMediaVariantsQueryHandler> logger)
    {
        _variantRepository = variantRepository;
        _mediaRepository = mediaRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<GetMediaVariantsResponse>> Handle(GetMediaVariantsQuery request, CancellationToken cancellationToken)
    {
        try
        {
            var mediaExists = await _mediaRepository.ExistsAsync(request.MediaId, cancellationToken);
            if (!mediaExists)
                return ApiResponse<GetMediaVariantsResponse>.Fail("Media not found");

            List<Domain.Entities.MediaVariant> variants;

            if (!string.IsNullOrEmpty(request.VariantName))
            {
                var variant = await _variantRepository.GetByMediaIdAndNameAsync(request.MediaId, request.VariantName, cancellationToken);
                variants = variant != null ? new List<Domain.Entities.MediaVariant> { variant } : new List<Domain.Entities.MediaVariant>();
            }
            else
            {
                var variantList = await _variantRepository.GetByMediaIdAsync(request.MediaId, cancellationToken);
                variants = variantList.ToList();
            }

            var variantDtos = variants.Select(DTOs.MediaVariantDto.FromEntity).ToList();
            var response = new GetMediaVariantsResponse(request.MediaId, variantDtos);

            return ApiResponse<GetMediaVariantsResponse>.Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media variants");
            return ApiResponse<GetMediaVariantsResponse>.Fail("Error retrieving media variants");
        }
    }
}

---- File: MediaService.Application\Features\Media\Queries\GetMediaVariants\GetMediaVariantsResponse.cs ----
using MediaService.Application.DTOs;

namespace MediaService.Application.Features.Media.Queries.GetMediaVariants;

public class GetMediaVariantsResponse
{
    public string MediaId { get; set; } = string.Empty;
    public List<MediaVariantDto> Variants { get; set; } = new();

    public GetMediaVariantsResponse() { }

    public GetMediaVariantsResponse(string mediaId, List<MediaVariantDto> variants)
    {
        MediaId = mediaId;
        Variants = variants;
    }
}

---- File: MediaService.Application\Features\Media\Queries\ListMedia\ListMediaQuery.cs ----
using MediaService.Application.DTOs;
using MediaService.Shared;
using MediatR;

namespace MediaService.Application.Features.Media.Queries.ListMedia;

public class ListMediaQuery : IRequest<ApiResponse<ListMediaResponse>>
{
    public string? OwnerId { get; set; }
    public string? Context { get; set; }
    public string? MediaType { get; set; }
    public string? Status { get; set; }
    public DateTime? FromDate { get; set; }
    public DateTime? ToDate { get; set; }
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;
    public string? SortBy { get; set; }
    public bool SortDescending { get; set; } = true;
    public bool IncludeVariants { get; set; } = false;

    public ListMediaQuery() { }

    public ListMediaQuery(
        string? ownerId = null,
        string? context = null,
        DateTime? fromDate = null,
        DateTime? toDate = null,
        int page = 1,
        int pageSize = 50)
    {
        OwnerId = ownerId;
        Context = context;
        FromDate = fromDate;
        ToDate = toDate;
        Page = page;
        PageSize = pageSize;
    }
}

---- File: MediaService.Application\Features\Media\Queries\ListMedia\ListMediaQueryHandler.cs ----
using MediaService.Application.DTOs;
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace MediaService.Application.Features.Media.Queries.ListMedia;

public class ListMediaQueryHandler : IRequestHandler<ListMediaQuery, ApiResponse<ListMediaResponse>>
{
    private readonly IMediaRepository _mediaRepository;
    private readonly ILogger<ListMediaQueryHandler> _logger;

    public ListMediaQueryHandler(
        IMediaRepository mediaRepository,
        ILogger<ListMediaQueryHandler> logger)
    {
        _mediaRepository = mediaRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<ListMediaResponse>> Handle(ListMediaQuery request, CancellationToken cancellationToken)
    {
        try
        {
            Domain.Enums.MediaType? mediaType = null;
            if (!string.IsNullOrEmpty(request.MediaType) &&
                Enum.TryParse<Domain.Enums.MediaType>(request.MediaType, true, out var parsedType))
            {
                mediaType = parsedType;
            }

            var (items, totalCount) = await _mediaRepository.GetPaginatedAsync(
                ownerId: request.OwnerId,
                context: request.Context,
                type: mediaType,
                fromDate: request.FromDate,
                toDate: request.ToDate,
                page: request.Page,
                pageSize: request.PageSize);

            var mediaDtos = items.Select(DTOs.MediaDto.FromEntity).ToList();
            var result = new PaginatedResult<MediaDto>
            {
                Items = mediaDtos,
                TotalCount = totalCount,
                Page = request.Page,
                PageSize = request.PageSize
            };

            var response = new ListMediaResponse(result);
            return ApiResponse<ListMediaResponse>.Ok(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving media list");
            return ApiResponse<ListMediaResponse>.Fail("Error retrieving media list");
        }
    }
}

---- File: MediaService.Application\Features\Media\Queries\ListMedia\ListMediaResponse.cs ----
using MediaService.Application.DTOs;
using MediaService.Shared;

namespace MediaService.Application.Features.Media.Queries.ListMedia;

public class ListMediaResponse
{
    public PaginatedResult<MediaDto> Media { get; set; } = new();

    public ListMediaResponse() { }

    public ListMediaResponse(PaginatedResult<MediaDto> media)
    {
        Media = media;
    }
}

---- File: MediaService.Domain\MediaService.Domain.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MediatR.Contracts" Version="1.0.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MediaService.Shared\MediaService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: MediaService.Domain\Common\DomainEvent.cs ----
using MediatR;

namespace MediaService.Domain.Common;

/// <summary>
/// Base class for domain events
/// </summary>
public abstract class DomainEvent : INotification
{
    /// <summary>
    /// When the event occurred
    /// </summary>
    public DateTime OccurredOn { get; protected set; } = DateTime.UtcNow;

    /// <summary>
    /// Unique identifier for the event
    /// </summary>
    public string EventId { get; protected set; } = Guid.NewGuid().ToString();

    /// <summary>
    /// Correlation ID for tracing
    /// </summary>
    public string? CorrelationId { get; set; }

    /// <summary>
    /// User ID who triggered the event
    /// </summary>
    public string? UserId { get; set; }

    /// <summary>
    /// Service that raised the event
    /// </summary>
    public string ServiceName { get; set; } = "MediaService";

    /// <summary>
    /// Additional event data
    /// </summary>
    public Dictionary<string, object> Metadata { get; set; } = new();

    protected DomainEvent()
    {
    }

    protected DomainEvent(string serviceName)
    {
        ServiceName = serviceName;
    }
}

---- File: MediaService.Domain\Common\EntityBase.cs ----
using MediatR;

namespace MediaService.Domain.Common;

/// <summary>
/// Base class for all entities in the domain
/// </summary>
public abstract class EntityBase : IEquatable<EntityBase>
{
    private readonly List<INotification> _domainEvents = new();

    /// <summary>
    /// Unique identifier for the entity
    /// </summary>
    public string Id { get; protected set; } = Guid.NewGuid().ToString();

    /// <summary>
    /// When the entity was created
    /// </summary>
    public DateTime CreatedAt { get; protected set; } = DateTime.UtcNow;

    /// <summary>
    /// When the entity was last updated
    /// </summary>
    public DateTime? UpdatedAt { get; protected set; }

    /// <summary>
    /// Domain events raised by this entity
    /// </summary>
    public IReadOnlyCollection<INotification> DomainEvents => _domainEvents.AsReadOnly();

    /// <summary>
    /// Adds a domain event to the entity
    /// </summary>
    public void AddDomainEvent(INotification eventItem)
    {
        _domainEvents.Add(eventItem);
    }

    /// <summary>
    /// Removes a domain event from the entity
    /// </summary>
    public void RemoveDomainEvent(INotification eventItem)
    {
        _domainEvents.Remove(eventItem);
    }

    /// <summary>
    /// Clears all domain events from the entity
    /// </summary>
    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }

    /// <summary>
    /// Marks the entity as updated and sets the UpdatedAt timestamp
    /// </summary>
    public void MarkAsUpdated()
    {
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Sets the creation timestamp (used for importing existing data)
    /// </summary>
    protected void SetCreatedAt(DateTime createdAt)
    {
        CreatedAt = createdAt;
    }

    /// <summary>
    /// Determines whether the specified object is equal to the current object
    /// </summary>
    public override bool Equals(object? obj)
    {
        if (obj is null) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != GetType()) return false;
        return Equals((EntityBase)obj);
    }

    /// <summary>
    /// Determines whether the specified entity is equal to the current entity
    /// </summary>
    public bool Equals(EntityBase? other)
    {
        if (other is null) return false;
        if (ReferenceEquals(this, other)) return true;
        return Id == other.Id;
    }

    /// <summary>
    /// Serves as the default hash function
    /// </summary>
    public override int GetHashCode()
    {
        return Id.GetHashCode();
    }

    /// <summary>
    /// Equality operator
    /// </summary>
    public static bool operator ==(EntityBase? left, EntityBase? right)
    {
        if (left is null && right is null) return true;
        if (left is null || right is null) return false;
        return left.Equals(right);
    }

    /// <summary>
    /// Inequality operator
    /// </summary>
    public static bool operator !=(EntityBase? left, EntityBase? right)
    {
        return !(left == right);
    }

    /// <summary>
    /// Gets the components that are used for equality comparison
    /// </summary>
    protected virtual IEnumerable<object> GetEqualityComponents()
    {
        yield return Id;
    }

    /// <summary>
    /// Returns a string that represents the current entity
    /// </summary>
    public override string ToString()
    {
        return $"{GetType().Name} [Id={Id}]";
    }

    /// <summary>
    /// Validates the entity state
    /// </summary>
    public virtual bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(Id) && CreatedAt <= DateTime.UtcNow;
    }

    /// <summary>
    /// Creates a shallow copy of the entity
    /// </summary>
    public virtual EntityBase ShallowCopy()
    {
        return (EntityBase)MemberwiseClone();
    }
}

/// <summary>
/// Marker interface for aggregate roots
/// </summary>
public interface IAggregateRoot { }

---- File: MediaService.Domain\Common\ValueObject.cs ----
namespace MediaService.Domain.Common;

/// <summary>
/// Base class for value objects
/// </summary>
public abstract class ValueObject
{
    protected static bool EqualOperator(ValueObject left, ValueObject right)
    {
        if (ReferenceEquals(left, null) ^ ReferenceEquals(right, null))
        {
            return false;
        }
        return ReferenceEquals(left, null) || left.Equals(right);
    }

    protected static bool NotEqualOperator(ValueObject left, ValueObject right)
    {
        return !EqualOperator(left, right);
    }

    protected abstract IEnumerable<object> GetEqualityComponents();

    public override bool Equals(object obj)
    {
        if (obj == null || obj.GetType() != GetType())
        {
            return false;
        }

        var other = (ValueObject)obj;
        return GetEqualityComponents().SequenceEqual(other.GetEqualityComponents());
    }

    public override int GetHashCode()
    {
        return GetEqualityComponents()
            .Select(x => x != null ? x.GetHashCode() : 0)
            .Aggregate((x, y) => x ^ y);
    }

    public static bool operator ==(ValueObject one, ValueObject two)
    {
        return EqualOperator(one, two);
    }

    public static bool operator !=(ValueObject one, ValueObject two)
    {
        return NotEqualOperator(one, two);
    }
}

---- File: MediaService.Domain\Entities\DocumentMedia.cs ----
namespace MediaService.Domain.Entities;

/// <summary>
/// Represents a document media asset
/// </summary>
public class DocumentMedia : MediaAsset
{
    public int? PageCount { get; private set; }
    public string? Author { get; private set; }
    public string? Title { get; private set; }
    public string? Description { get; private set; }
    public bool IsSearchable { get; private set; }
    public string? Language { get; private set; }

    public DocumentMedia(
        string ownerId,
        string? context,
        string originalFileName,
        string contentType,
        long sizeBytes,
        string storageKey)
        : base(ownerId, context, Enums.MediaType.Document, originalFileName, contentType, sizeBytes, storageKey)
    {
    }

    public void SetPageCount(int pageCount)
    {
        if (pageCount < 0) throw new ArgumentException("Page count cannot be negative", nameof(pageCount));

        PageCount = pageCount;
        MarkAsUpdated();
    }

    public void SetAuthor(string author)
    {
        Author = author;
        MarkAsUpdated();
    }

    public void SetTitle(string title)
    {
        Title = title;
        MarkAsUpdated();
    }

    public void SetDescription(string description)
    {
        Description = description;
        MarkAsUpdated();
    }

    public void SetSearchable(bool searchable)
    {
        IsSearchable = searchable;
        MarkAsUpdated();
    }

    public void SetLanguage(string language)
    {
        Language = language;
        MarkAsUpdated();
    }

    public bool IsPdf()
    {
        return ContentType?.ToLower() == "application/pdf";
    }

    public bool IsWordDocument()
    {
        return ContentType?.ToLower() is "application/msword" or
            "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    }

    public override bool IsValid()
    {
        return base.IsValid();
    }
}

---- File: MediaService.Domain\Entities\ImageMedia.cs ----
namespace MediaService.Domain.Entities;

/// <summary>
/// Represents an image media asset
/// </summary>
public class ImageMedia : MediaAsset
{
    public int Width { get; private set; }
    public int Height { get; private set; }
    public string? HashSha256 { get; private set; }
    public bool IsPrimary { get; private set; }
    public string? AltText { get; private set; }

    public ImageMedia(
        string ownerId,
        string? context,
        string originalFileName,
        string contentType,
        long sizeBytes,
        string storageKey,
        int width,
        int height)
        : base(ownerId, context, Enums.MediaType.Image, originalFileName, contentType, sizeBytes, storageKey)
    {
        Width = width > 0 ? width : throw new ArgumentException("Width must be greater than 0", nameof(width));
        Height = height > 0 ? height : throw new ArgumentException("Height must be greater than 0", nameof(height));
    }

    public void SetDimensions(int width, int height)
    {
        if (width <= 0) throw new ArgumentException("Width must be greater than 0", nameof(width));
        if (height <= 0) throw new ArgumentException("Height must be greater than 0", nameof(height));

        Width = width;
        Height = height;
        MarkAsUpdated();
    }

    public void SetHash(string hash)
    {
        HashSha256 = hash ?? throw new ArgumentNullException(nameof(hash));
        MarkAsUpdated();
    }

    public void SetAsPrimary(bool isPrimary = true)
    {
        IsPrimary = isPrimary;
        MarkAsUpdated();
    }

    public void SetAltText(string altText)
    {
        AltText = altText;
        MarkAsUpdated();
    }

    public double GetAspectRatio()
    {
        return Height > 0 ? (double)Width / Height : 0;
    }

    public string GetOrientation()
    {
        if (Width == Height) return "Square";
        return Width > Height ? "Landscape" : "Portrait";
    }

    public override bool IsValid()
    {
        return base.IsValid() &&
               Width > 0 &&
               Height > 0;
    }
}

---- File: MediaService.Domain\Entities\MediaAsset.cs ----
using MediaService.Domain.Common;
using MediaService.Domain.Events;

namespace MediaService.Domain.Entities;

/// <summary>
/// Represents a media asset (image, video, document, audio)
/// </summary>
public class MediaAsset : EntityBase, IAggregateRoot
{
    public string OwnerId { get; private set; } = string.Empty;
    public string? Context { get; private set; }
    public Enums.MediaType Type { get; private set; }
    public string OriginalFileName { get; private set; } = string.Empty;
    public string ContentType { get; private set; } = string.Empty;
    public long SizeBytes { get; private set; }
    public Enums.MediaStatus Status { get; private set; }
    public string? ProcessingError { get; private set; }
    public string StorageKey { get; private set; } = string.Empty;
    public string? CdnUrl { get; private set; }
    public DateTime? ProcessedAt { get; private set; }

    // Navigation properties
    public virtual ICollection<MediaVariant> Variants { get; private set; } = new List<MediaVariant>();

    // Private constructor for Entity Framework
    protected MediaAsset() { }

    public MediaAsset(
        string ownerId,
        string? context,
        Enums.MediaType type,
        string originalFileName,
        string contentType,
        long sizeBytes,
        string storageKey)
    {
        Id = GenerateMediaId(type);
        OwnerId = ownerId ?? throw new ArgumentNullException(nameof(ownerId));
        Context = context;
        Type = type;
        OriginalFileName = originalFileName ?? throw new ArgumentNullException(nameof(originalFileName));
        ContentType = contentType ?? throw new ArgumentNullException(nameof(contentType));
        SizeBytes = sizeBytes > 0 ? sizeBytes : throw new ArgumentException("File size must be greater than 0", nameof(sizeBytes));
        StorageKey = storageKey ?? throw new ArgumentNullException(nameof(storageKey));
        Status = Enums.MediaStatus.Uploaded;

        AddDomainEvent(new MediaUploadedEvent(Id, OwnerId, Context, Type, OriginalFileName, ContentType, SizeBytes, StorageKey));
    }

    private string GenerateMediaId(Enums.MediaType type)
    {
        var prefix = type switch
        {
            Enums.MediaType.Image => "img_",
            Enums.MediaType.Video => "vid_",
            Enums.MediaType.Document => "doc_",
            Enums.MediaType.Audio => "aud_",
            _ => "med_"
        };
        return $"{prefix}{Guid.NewGuid():N}";
    }

    public void MarkAsProcessing()
    {
        Status = Enums.MediaStatus.Processing;
        MarkAsUpdated();
    }

    public void MarkAsProcessed(string cdnUrl)
    {
        Status = Enums.MediaStatus.Processed;
        CdnUrl = cdnUrl;
        ProcessedAt = DateTime.UtcNow;
        MarkAsUpdated();

        AddDomainEvent(new MediaProcessedEvent(Id, OwnerId, Type, Enums.ProcessingStatus.Completed, Variants.Count, cdnUrl));
    }

    public void MarkAsFailed(string error)
    {
        Status = Enums.MediaStatus.Failed;
        ProcessingError = error;
        MarkAsUpdated();

        AddDomainEvent(new MediaProcessedEvent(Id, OwnerId, Type, Enums.ProcessingStatus.Failed, 0, null, null, error));
    }

    public void AddVariant(MediaVariant variant)
    {
        Variants.Add(variant);
        MarkAsUpdated();
    }

    public void RemoveVariant(MediaVariant variant)
    {
        Variants.Remove(variant);
        MarkAsUpdated();
    }

    public void UpdateContext(string? newContext)
    {
        Context = newContext;
        MarkAsUpdated();
    }

    public List<string> GetAllStorageKeys()
    {
        var keys = new List<string> { StorageKey };
        keys.AddRange(Variants.Select(v => v.StorageKey));
        return keys;
    }

    public override bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(Id) &&
               !string.IsNullOrWhiteSpace(OwnerId) &&
               !string.IsNullOrWhiteSpace(OriginalFileName) &&
               !string.IsNullOrWhiteSpace(ContentType) &&
               !string.IsNullOrWhiteSpace(StorageKey) &&
               SizeBytes > 0 &&
               Enum.IsDefined(typeof(Enums.MediaType), Type) &&
               Enum.IsDefined(typeof(Enums.MediaStatus), Status);
    }

    public string GetUserDisplayName()
    {
        return OwnerId switch
        {
            "system" => "System",
            "anonymous" => "Anonymous",
            _ => OwnerId
        };
    }

    public string GetSummary()
    {
        var status = Status.ToString().ToUpper();
        var user = GetUserDisplayName();
        return $"{Type} upload by {user} - {status}";
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Id;
        yield return OwnerId;
        yield return Type;
        yield return CreatedAt;
    }

    public override string ToString()
    {
        return $"{GetType().Name} [Id={Id}, Type={Type}, Owner={GetUserDisplayName()}, Status={Status}]";
    }
}

---- File: MediaService.Domain\Entities\MediaVariant.cs ----
using MediaService.Domain.Common;

namespace MediaService.Domain.Entities;

/// <summary>
/// Represents a variant of a media asset (thumbnails, different sizes, formats, etc.)
/// </summary>
public class MediaVariant : EntityBase
{
    public string MediaAssetId { get; private set; } = string.Empty;
    public string Name { get; private set; } = string.Empty; // "thumb", "small", "medium", "large", "hls"
    public string StorageKey { get; private set; } = string.Empty;
    public string? CdnUrl { get; private set; }
    public int? Width { get; private set; }
    public int? Height { get; private set; }
    public long SizeBytes { get; private set; }
    public string? Format { get; private set; }
    public int? Quality { get; private set; }
    public string? VideoProfile { get; private set; }
    public int? Bitrate { get; private set; }
    public TimeSpan? Duration { get; private set; }

    // Navigation property
    public virtual MediaAsset MediaAsset { get; private set; } = null!;

    // Private constructor for Entity Framework
    private MediaVariant() { }

    public MediaVariant(
        string mediaAssetId,
        string name,
        string storageKey,
        int? width = null,
        int? height = null,
        long sizeBytes = 0,
        string? format = null,
        int? quality = null,
        string? videoProfile = null,
        int? bitrate = null,
        TimeSpan? duration = null)
    {
        MediaAssetId = mediaAssetId ?? throw new ArgumentNullException(nameof(mediaAssetId));
        Name = name ?? throw new ArgumentNullException(nameof(name));
        StorageKey = storageKey ?? throw new ArgumentNullException(nameof(storageKey));
        Width = width;
        Height = height;
        SizeBytes = sizeBytes;
        Format = format;
        Quality = quality;
        VideoProfile = videoProfile;
        Bitrate = bitrate;
        Duration = duration;
    }

    public void SetCdnUrl(string cdnUrl)
    {
        CdnUrl = cdnUrl;
        MarkAsUpdated();
    }

    public void SetSize(long sizeBytes)
    {
        if (sizeBytes < 0) throw new ArgumentException("Size cannot be negative", nameof(sizeBytes));

        SizeBytes = sizeBytes;
        MarkAsUpdated();
    }

    public void SetDimensions(int width, int height)
    {
        if (width <= 0) throw new ArgumentException("Width must be greater than 0", nameof(width));
        if (height <= 0) throw new ArgumentException("Height must be greater than 0", nameof(height));

        Width = width;
        Height = height;
        MarkAsUpdated();
    }

    public void SetQuality(int quality)
    {
        if (quality < 0 || quality > 100)
            throw new ArgumentException("Quality must be between 0 and 100", nameof(quality));

        Quality = quality;
        MarkAsUpdated();
    }

    public void SetBitrate(int bitrate)
    {
        if (bitrate <= 0) throw new ArgumentException("Bitrate must be greater than 0", nameof(bitrate));

        Bitrate = bitrate;
        MarkAsUpdated();
    }

    public void SetDuration(TimeSpan duration)
    {
        if (duration <= TimeSpan.Zero)
            throw new ArgumentException("Duration must be greater than zero", nameof(duration));

        Duration = duration;
        MarkAsUpdated();
    }

    public double GetAspectRatio()
    {
        if (!Width.HasValue || !Height.HasValue || Height.Value == 0)
            return 0;

        return (double)Width.Value / Height.Value;
    }

    public string GetResolution()
    {
        if (!Width.HasValue || !Height.HasValue)
            return "Unknown";

        return $"{Width}x{Height}";
    }

    public override bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(MediaAssetId) &&
               !string.IsNullOrWhiteSpace(Name) &&
               !string.IsNullOrWhiteSpace(StorageKey) &&
               SizeBytes >= 0;
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Id;
        yield return MediaAssetId;
        yield return Name;
    }

    public override string ToString()
    {
        return $"{GetType().Name} [Id={Id}, Name={Name}, MediaAssetId={MediaAssetId}]";
    }
}

---- File: MediaService.Domain\Entities\VideoMedia.cs ----
namespace MediaService.Domain.Entities;

/// <summary>
/// Represents a video media asset
/// </summary>
public class VideoMedia : MediaAsset
{
    public TimeSpan? Duration { get; private set; }
    public int? Width { get; private set; }
    public int? Height { get; private set; }
    public string? VideoCodec { get; private set; }
    public string? AudioCodec { get; private set; }
    public double? FrameRate { get; private set; }
    public int? Bitrate { get; private set; }
    public string StorageKeyInput { get; private set; } = string.Empty;
    public string StorageKeyHls { get; private set; } = string.Empty;
    public bool HasHlsStream { get; private set; }

    public VideoMedia(
        string ownerId,
        string? context,
        string originalFileName,
        string contentType,
        long sizeBytes,
        string storageKey)
        : base(ownerId, context, Enums.MediaType.Video, originalFileName, contentType, sizeBytes, storageKey)
    {
        StorageKeyInput = storageKey;
    }

    public void SetDuration(TimeSpan duration)
    {
        if (duration <= TimeSpan.Zero)
            throw new ArgumentException("Duration must be greater than zero", nameof(duration));

        Duration = duration;
        MarkAsUpdated();
    }

    public void SetDimensions(int width, int height)
    {
        if (width <= 0) throw new ArgumentException("Width must be greater than 0", nameof(width));
        if (height <= 0) throw new ArgumentException("Height must be greater than 0", nameof(height));

        Width = width;
        Height = height;
        MarkAsUpdated();
    }

    public void SetCodecs(string videoCodec, string audioCodec)
    {
        VideoCodec = videoCodec ?? throw new ArgumentNullException(nameof(videoCodec));
        AudioCodec = audioCodec ?? throw new ArgumentNullException(nameof(audioCodec));
        MarkAsUpdated();
    }

    public void SetFrameRate(double frameRate)
    {
        if (frameRate <= 0) throw new ArgumentException("Frame rate must be greater than 0", nameof(frameRate));

        FrameRate = frameRate;
        MarkAsUpdated();
    }

    public void SetBitrate(int bitrate)
    {
        if (bitrate <= 0) throw new ArgumentException("Bitrate must be greater than 0", nameof(bitrate));

        Bitrate = bitrate;
        MarkAsUpdated();
    }

    public void SetHlsStream(string hlsStorageKey)
    {
        StorageKeyHls = hlsStorageKey ?? throw new ArgumentNullException(nameof(hlsStorageKey));
        HasHlsStream = true;
        MarkAsUpdated();
    }

    public double GetAspectRatio()
    {
        if (!Width.HasValue || !Height.HasValue || Height.Value == 0)
            return 0;

        return (double)Width.Value / Height.Value;
    }

    public string GetResolution()
    {
        if (!Width.HasValue || !Height.HasValue)
            return "Unknown";

        return $"{Width}x{Height}";
    }

    public override bool IsValid()
    {
        return base.IsValid() &&
               !string.IsNullOrWhiteSpace(StorageKeyInput);
    }
}

---- File: MediaService.Domain\Enums\MediaStatus.cs ----
namespace MediaService.Domain.Enums;

/// <summary>
/// Status of media processing
/// </summary>
public enum MediaStatus
{
    /// <summary>
    /// Media has been uploaded but not processed
    /// </summary>
    Uploaded = 1,

    /// <summary>
    /// Media is currently being processed
    /// </summary>
    Processing = 2,

    /// <summary>
    /// Media has been successfully processed
    /// </summary>
    Processed = 3,

    /// <summary>
    /// Media processing failed
    /// </summary>
    Failed = 4
}

---- File: MediaService.Domain\Enums\MediaType.cs ----
namespace MediaService.Domain.Enums;

/// <summary>
/// Types of media supported by the service
/// </summary>
public enum MediaType
{
    /// <summary>
    /// Image files (JPEG, PNG, GIF, WebP, etc.)
    /// </summary>
    Image = 1,

    /// <summary>
    /// Video files (MP4, AVI, MOV, etc.)
    /// </summary>
    Video = 2,

    /// <summary>
    /// Document files (PDF, DOC, DOCX, etc.)
    /// </summary>
    Document = 3,

    /// <summary>
    /// Audio files (MP3, WAV, AAC, etc.)
    /// </summary>
    Audio = 4
}

---- File: MediaService.Domain\Enums\ProcessingStatus.cs ----
namespace MediaService.Domain.Enums;

/// <summary>
/// Status of media processing operations
/// </summary>
public enum ProcessingStatus
{
    /// <summary>
    /// Processing has been queued
    /// </summary>
    Queued = 1,

    /// <summary>
    /// Processing is in progress
    /// </summary>
    InProgress = 2,

    /// <summary>
    /// Processing completed successfully
    /// </summary>
    Completed = 3,

    /// <summary>
    /// Processing failed
    /// </summary>
    Failed = 4,

    /// <summary>
    /// Processing was cancelled
    /// </summary>
    Cancelled = 5
}

---- File: MediaService.Domain\Events\MediaDeletedEvent.cs ----
using MediaService.Domain.Common;

namespace MediaService.Domain.Events;

/// <summary>
/// Event raised when a media file is deleted
/// </summary>
public class MediaDeletedEvent : DomainEvent
{
    /// <summary>
    /// ID of the deleted media
    /// </summary>
    public string MediaId { get; }

    /// <summary>
    /// ID of the media owner
    /// </summary>
    public string OwnerId { get; }

    /// <summary>
    /// Type of media deleted
    /// </summary>
    public Enums.MediaType MediaType { get; }

    /// <summary>
    /// Storage keys that were deleted
    /// </summary>
    public List<string> DeletedStorageKeys { get; }

    /// <summary>
    /// Reason for deletion
    /// </summary>
    public string? Reason { get; }

    /// <summary>
    /// User ID who performed the deletion
    /// </summary>
    public string DeletedBy { get; }

    public MediaDeletedEvent(
        string mediaId,
        string ownerId,
        Enums.MediaType mediaType,
        List<string> deletedStorageKeys,
        string deletedBy,
        string? reason = null)
    {
        MediaId = mediaId;
        OwnerId = ownerId;
        MediaType = mediaType;
        DeletedStorageKeys = deletedStorageKeys;
        DeletedBy = deletedBy;
        Reason = reason;

        // Set metadata
        Metadata["mediaId"] = mediaId;
        Metadata["ownerId"] = ownerId;
        Metadata["mediaType"] = mediaType.ToString();
        Metadata["deletedStorageKeys"] = deletedStorageKeys;
        Metadata["deletedBy"] = deletedBy;
        Metadata["storageKeysCount"] = deletedStorageKeys.Count;

        if (!string.IsNullOrEmpty(reason))
            Metadata["reason"] = reason;
    }
}

---- File: MediaService.Domain\Events\MediaProcessedEvent.cs ----
using MediaService.Domain.Common;

namespace MediaService.Domain.Events;

/// <summary>
/// Event raised when a media file is processed
/// </summary>
public class MediaProcessedEvent : DomainEvent
{
    /// <summary>
    /// ID of the processed media
    /// </summary>
    public string MediaId { get; }

    /// <summary>
    /// ID of the media owner
    /// </summary>
    public string OwnerId { get; }

    /// <summary>
    /// Type of media processed
    /// </summary>
    public Enums.MediaType MediaType { get; }

    /// <summary>
    /// Processing status
    /// </summary>
    public Enums.ProcessingStatus Status { get; }

    /// <summary>
    /// Error message if processing failed
    /// </summary>
    public string? ErrorMessage { get; }

    /// <summary>
    /// Number of variants generated
    /// </summary>
    public int VariantsGenerated { get; }

    /// <summary>
    /// CDN URL for the processed media
    /// </summary>
    public string? CdnUrl { get; }

    /// <summary>
    /// Processing duration in milliseconds
    /// </summary>
    public long? ProcessingDurationMs { get; }

    public MediaProcessedEvent(
        string mediaId,
        string ownerId,
        Enums.MediaType mediaType,
        Enums.ProcessingStatus status,
        int variantsGenerated = 0,
        string? cdnUrl = null,
        long? processingDurationMs = null,
        string? errorMessage = null)
    {
        MediaId = mediaId;
        OwnerId = ownerId;
        MediaType = mediaType;
        Status = status;
        VariantsGenerated = variantsGenerated;
        CdnUrl = cdnUrl;
        ProcessingDurationMs = processingDurationMs;
        ErrorMessage = errorMessage;

        // Set metadata
        Metadata["mediaId"] = mediaId;
        Metadata["ownerId"] = ownerId;
        Metadata["mediaType"] = mediaType.ToString();
        Metadata["status"] = status.ToString();
        Metadata["variantsGenerated"] = variantsGenerated;

        if (!string.IsNullOrEmpty(cdnUrl))
            Metadata["cdnUrl"] = cdnUrl;

        if (processingDurationMs.HasValue)
            Metadata["processingDurationMs"] = processingDurationMs.Value;

        if (!string.IsNullOrEmpty(errorMessage))
            Metadata["errorMessage"] = errorMessage;
    }
}

---- File: MediaService.Domain\Events\MediaUploadedEvent.cs ----
using MediaService.Domain.Common;

namespace MediaService.Domain.Events;

/// <summary>
/// Event raised when a media file is uploaded
/// </summary>
public class MediaUploadedEvent : DomainEvent
{
    /// <summary>
    /// ID of the uploaded media
    /// </summary>
    public string MediaId { get; }

    /// <summary>
    /// ID of the user who uploaded the media
    /// </summary>
    public string OwnerId { get; }

    /// <summary>
    /// Context of the upload (profile, product, etc.)
    /// </summary>
    public string? Context { get; }

    /// <summary>
    /// Type of media uploaded
    /// </summary>
    public Enums.MediaType MediaType { get; }

    /// <summary>
    /// Original file name
    /// </summary>
    public string FileName { get; }

    /// <summary>
    /// Content type of the uploaded file
    /// </summary>
    public string ContentType { get; }

    /// <summary>
    /// Size of the uploaded file in bytes
    /// </summary>
    public long FileSize { get; }

    /// <summary>
    /// Storage key for the uploaded file
    /// </summary>
    public string StorageKey { get; }

    public MediaUploadedEvent(
        string mediaId,
        string ownerId,
        string? context,
        Enums.MediaType mediaType,
        string fileName,
        string contentType,
        long fileSize,
        string storageKey)
    {
        MediaId = mediaId;
        OwnerId = ownerId;
        Context = context;
        MediaType = mediaType;
        FileName = fileName;
        ContentType = contentType;
        FileSize = fileSize;
        StorageKey = storageKey;

        // Set metadata
        Metadata["mediaId"] = mediaId;
        Metadata["ownerId"] = ownerId;
        Metadata["mediaType"] = mediaType.ToString();
        Metadata["fileSize"] = fileSize;

        if (!string.IsNullOrEmpty(context))
            Metadata["context"] = context;
    }
}

---- File: MediaService.Domain\Exceptions\MediaNotFoundException.cs ----
namespace MediaService.Domain.Exceptions;

/// <summary>
/// Exception thrown when a media entity is not found
/// </summary>
public class MediaNotFoundException : Exception
{
    public string MediaId { get; }

    public MediaNotFoundException(string mediaId)
        : base($"Media with ID '{mediaId}' was not found.")
    {
        MediaId = mediaId;
    }

    public MediaNotFoundException(string mediaId, Exception innerException)
        : base($"Media with ID '{mediaId}' was not found.", innerException)
    {
        MediaId = mediaId;
    }
}

---- File: MediaService.Domain\Exceptions\MediaProcessingException.cs ----
namespace MediaService.Domain.Exceptions;

/// <summary>
/// Exception thrown when media processing fails
/// </summary>
public class MediaProcessingException : Exception
{
    public string MediaId { get; }
    public string? ProcessingStep { get; }

    public MediaProcessingException(string mediaId, string message)
        : base($"Processing failed for media '{mediaId}': {message}")
    {
        MediaId = mediaId;
    }

    public MediaProcessingException(string mediaId, string processingStep, string message)
        : base($"Processing failed for media '{mediaId}' at step '{processingStep}': {message}")
    {
        MediaId = mediaId;
        ProcessingStep = processingStep;
    }

    public MediaProcessingException(string mediaId, string message, Exception innerException)
        : base($"Processing failed for media '{mediaId}': {message}", innerException)
    {
        MediaId = mediaId;
    }

    public MediaProcessingException(string mediaId, string processingStep, string message, Exception innerException)
        : base($"Processing failed for media '{mediaId}' at step '{processingStep}': {message}", innerException)
    {
        MediaId = mediaId;
        ProcessingStep = processingStep;
    }
}

---- File: MediaService.Domain\Exceptions\MediaValidationException.cs ----
namespace MediaService.Domain.Exceptions;

/// <summary>
/// Exception thrown when media validation fails
/// </summary>
public class MediaValidationException : Exception
{
    public string? Field { get; }
    public string? ValidationError { get; }

    public MediaValidationException(string message)
        : base(message)
    {
    }

    public MediaValidationException(string message, Exception innerException)
        : base(message, innerException)
    {
    }

    public MediaValidationException(string field, string validationError)
        : base($"Validation failed for field '{field}': {validationError}")
    {
        Field = field;
        ValidationError = validationError;
    }

    public MediaValidationException(string field, string validationError, Exception innerException)
        : base($"Validation failed for field '{field}': {validationError}", innerException)
    {
        Field = field;
        ValidationError = validationError;
    }
}

---- File: MediaService.Domain\Interfaces\IUnitOfWork.cs ----
namespace MediaService.Domain.Interfaces;

/// <summary>
/// Unit of Work pattern interface for managing transactions
/// </summary>
public interface IUnitOfWork
{
    /// <summary>
    /// Saves all changes made in this context to the database
    /// </summary>
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Saves all changes and dispatches domain events
    /// </summary>
    Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Begins a transaction
    /// </summary>
    Task BeginTransactionAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Commits the transaction
    /// </summary>
    Task CommitTransactionAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Rolls back the transaction
    /// </summary>
    Task RollbackTransactionAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if a transaction is active
    /// </summary>
    bool HasActiveTransaction { get; }
}

---- File: MediaService.Domain\Interfaces\Repositories\IMediaRepository.cs ----
using MediaService.Domain.Entities;

namespace MediaService.Domain.Interfaces.Repositories;

/// <summary>
/// Repository interface for media asset operations
/// </summary>
public interface IMediaRepository
{
    /// <summary>
    /// Gets a media asset by its unique identifier
    /// </summary>
    Task<MediaAsset?> GetByIdAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all media assets for a specific owner
    /// </summary>
    Task<IEnumerable<MediaAsset>> GetByOwnerIdAsync(string ownerId, string? context = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets media assets by type
    /// </summary>
    Task<IEnumerable<MediaAsset>> GetByTypeAsync(Enums.MediaType type, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets media assets by status
    /// </summary>
    Task<IEnumerable<MediaAsset>> GetByStatusAsync(Enums.MediaStatus status, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets unprocessed images for processing
    /// </summary>
    Task<IEnumerable<ImageMedia>> GetUnprocessedImagesAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets unprocessed videos for processing
    /// </summary>
    Task<IEnumerable<VideoMedia>> GetUnprocessedVideosAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets paginated media assets with filtering and sorting
    /// </summary>
    Task<(IEnumerable<MediaAsset> items, int totalCount)> GetPaginatedAsync(
        string? ownerId = null,
        string? context = null,
        Enums.MediaType? type = null,
        Enums.MediaStatus? status = null,
        DateTime? fromDate = null,
        DateTime? toDate = null,
        int page = 1,
        int pageSize = 50,
        string? sortBy = null,
        bool sortDescending = true);

    /// <summary>
    /// Adds a new media asset
    /// </summary>
    Task AddAsync(MediaAsset mediaAsset, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing media asset
    /// </summary>
    Task UpdateAsync(MediaAsset mediaAsset, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a media asset
    /// </summary>
    Task DeleteAsync(MediaAsset mediaAsset, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes multiple media assets
    /// </summary>
    Task DeleteRangeAsync(IEnumerable<MediaAsset> mediaAssets, CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if a media asset exists with the given ID
    /// </summary>
    Task<bool> ExistsAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the total count of media assets
    /// </summary>
    Task<int> GetTotalCountAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets statistics about media assets
    /// </summary>
    Task<MediaStatistics> GetStatisticsAsync(DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default);
}

/// <summary>
/// Statistics about media assets
/// </summary>
public class MediaStatistics
{
    public int TotalMedia { get; set; }
    public int Images { get; set; }
    public int Videos { get; set; }
    public int Documents { get; set; }
    public int Audio { get; set; }
    public int Processed { get; set; }
    public int Processing { get; set; }
    public int Failed { get; set; }
    public long TotalStorageBytes { get; set; }
    public DateTime? FirstMediaDate { get; set; }
    public DateTime? LastMediaDate { get; set; }
    public Dictionary<string, int> MediaByContext { get; set; } = new();
}

---- File: MediaService.Domain\Interfaces\Repositories\IMediaVariantRepository.cs ----
using MediaService.Domain.Entities;

namespace MediaService.Domain.Interfaces.Repositories;

/// <summary>
/// Repository interface for media variant operations
/// </summary>
public interface IMediaVariantRepository
{
    /// <summary>
    /// Gets a media variant by its unique identifier
    /// </summary>
    Task<MediaVariant?> GetByIdAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all variants for a specific media asset
    /// </summary>
    Task<IEnumerable<MediaVariant>> GetByMediaIdAsync(string mediaId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a specific variant by name for a media asset
    /// </summary>
    Task<MediaVariant?> GetByMediaIdAndNameAsync(string mediaId, string variantName, CancellationToken cancellationToken = default);

    /// <summary>
    /// Adds a new media variant
    /// </summary>
    Task AddAsync(MediaVariant mediaVariant, CancellationToken cancellationToken = default);

    /// <summary>
    /// Adds multiple media variants
    /// </summary>
    Task AddRangeAsync(IEnumerable<MediaVariant> mediaVariants, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing media variant
    /// </summary>
    Task UpdateAsync(MediaVariant mediaVariant, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a media variant
    /// </summary>
    Task DeleteAsync(MediaVariant mediaVariant, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes all variants for a media asset
    /// </summary>
    Task DeleteByMediaIdAsync(string mediaId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if a variant exists for a media asset
    /// </summary>
    Task<bool> ExistsAsync(string mediaId, string variantName, CancellationToken cancellationToken = default);
}

---- File: MediaService.Domain\Services\IImageProcessor.cs ----
namespace MediaService.Domain.Interfaces.Services;

/// <summary>
/// Interface for image processing operations
/// </summary>
public interface IImageProcessor
{
    /// <summary>
    /// Processes an image and creates variants
    /// </summary>
    Task<ImageProcessingResult> ProcessImageAsync(Stream imageStream, string originalFileName, IEnumerable<ImageVariantConfig> variants);

    /// <summary>
    /// Gets image information without processing
    /// </summary>
    Task<ImageInfo> GetImageInfoAsync(Stream imageStream);

    /// <summary>
    /// Validates if an image can be processed
    /// </summary>
    Task<bool> ValidateImageAsync(Stream imageStream, string contentType);

    /// <summary>
    /// Optimizes an image for web delivery
    /// </summary>
    Task<Stream> OptimizeImageAsync(Stream imageStream, string contentType, int quality);

    /// <summary>
    /// Creates a thumbnail from an image
    /// </summary>
    Task<Stream> CreateThumbnailAsync(Stream imageStream, int width, int height, string resizeMode = "Max");
}

/// <summary>
/// Image processing result
/// </summary>
public class ImageProcessingResult
{
    public bool Success { get; set; }
    public string? ErrorMessage { get; set; }
    public List<ProcessedVariant> Variants { get; set; } = new();
    public ImageInfo OriginalImageInfo { get; set; } = new();
}

/// <summary>
/// Processed image variant
/// </summary>
public class ProcessedVariant
{
    public string Name { get; set; } = string.Empty;
    public Stream ImageStream { get; set; } = Stream.Null;
    public string ContentType { get; set; } = string.Empty;
    public long SizeBytes { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
    public string StorageKey { get; set; } = string.Empty;
}

/// <summary>
/// Image information
/// </summary>
public class ImageInfo
{
    public int Width { get; set; }
    public int Height { get; set; }
    public string Format { get; set; } = string.Empty;
    public string ColorSpace { get; set; } = string.Empty;
    public bool HasAlpha { get; set; }
    public int Quality { get; set; }
    public long FileSize { get; set; }
}

/// <summary>
/// Image variant configuration
/// </summary>
public class ImageVariantConfig
{
    public string Name { get; set; } = string.Empty;
    public int MaxWidth { get; set; }
    public int MaxHeight { get; set; }
    public int Quality { get; set; } = 85;
    public string Format { get; set; } = string.Empty;
    public bool MaintainAspectRatio { get; set; } = true;
    public string ResizeMode { get; set; } = "Max";
}

---- File: MediaService.Domain\Services\IMediaStorageService.cs ----
namespace MediaService.Domain.Interfaces.Services;

/// <summary>
/// Interface for media storage operations
/// </summary>
public interface IMediaStorageService
{
    /// <summary>
    /// Generates an upload URL for direct client upload
    /// </summary>
    Task<UploadUrlResponse> GenerateUploadUrlAsync(string storageKey, string contentType, TimeSpan? expiry = null);

    /// <summary>
    /// Validates a file before upload
    /// </summary>
    Task<bool> ValidateFileAsync(string contentType, long fileSize);

    /// <summary>
    /// Generates a storage key for a file
    /// </summary>
    Task<string> GenerateStorageKeyAsync(string ownerId, string? context, string fileName);

    /// <summary>
    /// Checks if a file exists in storage
    /// </summary>
    Task<bool> FileExistsAsync(string storageKey);

    /// <summary>
    /// Downloads a file from storage
    /// </summary>
    Task<Stream> DownloadFileAsync(string storageKey);

    /// <summary>
    /// Uploads a file to storage
    /// </summary>
    Task UploadFileAsync(string storageKey, Stream fileStream, string contentType);

    /// <summary>
    /// Deletes a file from storage
    /// </summary>
    Task DeleteFileAsync(string storageKey);

    /// <summary>
    /// Gets the public URL for a file
    /// </summary>
    Task<string> GetFileUrlAsync(string storageKey);

    /// <summary>
    /// Copies a file within storage
    /// </summary>
    Task CopyFileAsync(string sourceKey, string destinationKey);

    /// <summary>
    /// Checks if the storage service is healthy
    /// </summary>
    Task<bool> IsHealthyAsync();
}

/// <summary>
/// Response for upload URL generation
/// </summary>
public class UploadUrlResponse
{
    public string UploadUrl { get; set; } = string.Empty;
    public DateTime ExpiresAt { get; set; }
    public Dictionary<string, string> Headers { get; set; } = new();
    public string StorageKey { get; set; } = string.Empty;
}

---- File: MediaService.Domain\Services\IVideoProcessor.cs ----
namespace MediaService.Domain.Interfaces.Services;

/// <summary>
/// Interface for video processing operations
/// </summary>
public interface IVideoProcessor
{
    /// <summary>
    /// Processes a video and creates variants/transcodes
    /// </summary>
    Task<VideoProcessingResult> ProcessVideoAsync(Stream videoStream, string originalFileName, VideoProcessingConfig config);

    /// <summary>
    /// Gets video information without processing
    /// </summary>
    Task<VideoInfo> GetVideoInfoAsync(Stream videoStream);

    /// <summary>
    /// Validates if a video can be processed
    /// </summary>
    Task<bool> ValidateVideoAsync(Stream videoStream, string contentType);

    /// <summary>
    /// Generates thumbnails from a video
    /// </summary>
    Task<List<Stream>> GenerateThumbnailsAsync(Stream videoStream, int count, int? width = null, int? height = null);

    /// <summary>
    /// Extracts audio from a video
    /// </summary>
    Task<Stream> ExtractAudioAsync(Stream videoStream, string audioFormat);
}

/// <summary>
/// Video processing result
/// </summary>
public class VideoProcessingResult
{
    public bool Success { get; set; }
    public string? ErrorMessage { get; set; }
    public VideoInfo OriginalVideoInfo { get; set; } = new();
    public List<ProcessedVideoVariant> Variants { get; set; } = new();
    public List<ProcessedThumbnail> Thumbnails { get; set; } = new();
    public Stream? AudioTrack { get; set; }
    public TimeSpan ProcessingDuration { get; set; }
}

/// <summary>
/// Processed video variant
/// </summary>
public class ProcessedVideoVariant
{
    public string Name { get; set; } = string.Empty;
    public Stream VideoStream { get; set; } = Stream.Null;
    public string ContentType { get; set; } = string.Empty;
    public long SizeBytes { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
    public string VideoCodec { get; set; } = string.Empty;
    public string AudioCodec { get; set; } = string.Empty;
    public TimeSpan Duration { get; set; }
    public int Bitrate { get; set; }
    public string StorageKey { get; set; } = string.Empty;
}

/// <summary>
/// Processed thumbnail
/// </summary>
public class ProcessedThumbnail
{
    public int Index { get; set; }
    public TimeSpan Timestamp { get; set; }
    public Stream ImageStream { get; set; } = Stream.Null;
    public string ContentType { get; set; } = string.Empty;
    public long SizeBytes { get; set; }
    public int Width { get; set; }
    public int Height { get; set; }
    public string StorageKey { get; set; } = string.Empty;
}

/// <summary>
/// Video information
/// </summary>
public class VideoInfo
{
    public int Width { get; set; }
    public int Height { get; set; }
    public string Format { get; set; } = string.Empty;
    public string VideoCodec { get; set; } = string.Empty;
    public string AudioCodec { get; set; } = string.Empty;
    public TimeSpan Duration { get; set; }
    public int Bitrate { get; set; }
    public double FrameRate { get; set; }
    public long FileSize { get; set; }
}

/// <summary>
/// Video processing configuration
/// </summary>
public class VideoProcessingConfig
{
    public bool GenerateHls { get; set; } = true;
    public int HlsSegmentSeconds { get; set; } = 4;
    public List<VideoBitrateProfile> BitrateLadder { get; set; } = new();
    public bool GenerateThumbnails { get; set; } = true;
    public int ThumbnailCount { get; set; } = 10;
    public int ThumbnailIntervalSeconds { get; set; } = 10;
    public bool ExtractAudio { get; set; } = true;
    public string OutputFormat { get; set; } = "h264";
    public string AudioFormat { get; set; } = "aac";
}

/// <summary>
/// Video bitrate profile
/// </summary>
public class VideoBitrateProfile
{
    public string Name { get; set; } = string.Empty;
    public int Height { get; set; }
    public string VideoBitrate { get; set; } = string.Empty;
    public string AudioBitrate { get; set; } = string.Empty;
    public string VideoCodec { get; set; } = "libx264";
    public string AudioCodec { get; set; } = "aac";
    public string Profile { get; set; } = "main";
    public string Level { get; set; } = "3.1";
}

---- File: MediaService.Infrastructure\MediaService.Infrastructure.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\MediaService.Domain\MediaService.Domain.csproj" />
    <ProjectReference Include="..\MediaService.Application\MediaService.Application.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Http" Version="2.2.2" />
    <PackageReference Include="Microsoft.Extensions.Http" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="8.0.0" />
    
    <!-- AGREGAR ESTOS PAQUETES DE FLUENTVALIDATION -->
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.0" />
    <PackageReference Include="FluentValidation.AspNetCore" Version="11.3.0" />
    
    <PackageReference Include="AWSSDK.S3" Version="3.7.304.13" />
    <PackageReference Include="Azure.Storage.Blobs" Version="12.19.1" />
    <PackageReference Include="SixLabors.ImageSharp" Version="3.1.12" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.SqlServer" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="8.0.0" />
    <PackageReference Include="RabbitMQ.Client" Version="6.8.1" />
  </ItemGroup>

</Project>

---- File: MediaService.Infrastructure\Extensions\ServiceCollectionExtensions.cs ----
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Domain.Interfaces.Services;
using MediaService.Infrastructure.HealthChecks;
using MediaService.Infrastructure.Middleware;
using MediaService.Infrastructure.Persistence;
using MediaService.Infrastructure.Repositories;
using MediaService.Infrastructure.Services.Processing;
using MediaService.Infrastructure.Services.Storage;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.Extensions.Logging;

namespace MediaService.Infrastructure.Extensions;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
    {

        // DbContext
        services.AddDbContext<ApplicationDbContext>(options =>
        {
            var connectionString = configuration.GetConnectionString("DefaultConnection");
            if (string.IsNullOrEmpty(connectionString))
            {
                connectionString = "Server=(localdb)\\mssqllocaldb;Database=MediaServiceDb;Trusted_Connection=true;MultipleActiveResultSets=true";
            }
            options.UseSqlServer(connectionString, sqlOptions =>
            {
                sqlOptions.MigrationsAssembly(typeof(ApplicationDbContext).Assembly.FullName);
                sqlOptions.EnableRetryOnFailure(
                    maxRetryCount: 5,
                    maxRetryDelay: TimeSpan.FromSeconds(30),
                    errorNumbersToAdd: null);
            });
        });

        // Repositories
        services.AddScoped<IMediaRepository, MediaRepository>();
        services.AddScoped<IMediaVariantRepository, MediaVariantRepository>();

        // Storage Services
        services.Configure<LocalStorageOptions>(configuration.GetSection("Storage:Local"));
        services.Configure<AzureBlobStorageOptions>(configuration.GetSection("Storage:Azure"));
        services.Configure<S3StorageOptions>(configuration.GetSection("Storage:S3"));

        // Storage Services - Registro dinámico
        var storageProvider = configuration["Storage:Provider"]?.ToLowerInvariant() ?? "local";
        switch (storageProvider)
        {
            case "azure":
                services.AddScoped<IMediaStorageService, AzureBlobStorageService>();
                break;
            case "s3":
            case "aws":
                services.AddScoped<IMediaStorageService, S3StorageService>();
                break;
            case "local":
            default:
                services.AddScoped<IMediaStorageService>(provider =>
                {
                    var logger = provider.GetRequiredService<ILogger<LocalStorageService>>();
                    var basePath = configuration["Storage:Local:BasePath"] ?? "wwwroot/uploads";
                    var baseUrl = configuration["Storage:Local:BaseUrl"] ?? "https://localhost:7000/uploads";

                    return new LocalStorageService(basePath, baseUrl, logger);
                });
                break;
        }

        // Processing Services
        services.AddScoped<IImageProcessor, ImageSharpProcessor>();
        services.AddScoped<IVideoProcessor, FfmpegVideoProcessor>();

        // Health Checks
        services.AddHealthChecks()
            .AddCheck<DatabaseHealthCheck>(
                "database",
                failureStatus: HealthStatus.Unhealthy,
                tags: new[] { "ready" })
            .AddCheck<StorageHealthCheck>(
                "storage",
                failureStatus: HealthStatus.Degraded,
                tags: new[] { "ready" })
            .AddDbContextCheck<ApplicationDbContext>(
                "db-context",
                failureStatus: HealthStatus.Unhealthy,
                tags: new[] { "ready" });

        // Middleware
        services.AddTransient<ErrorHandlingMiddleware>();

        // Servicios de infraestructura adicionales
        services.AddSingleton<IFileValidator, FileValidator>();
        services.AddScoped<IStorageHealthChecker, StorageHealthChecker>();

        return services;
    }

    public static IServiceCollection AddInfrastructureHealthChecks(this IServiceCollection services, IConfiguration configuration)
    {
        var connectionString = configuration.GetConnectionString("DefaultConnection");
        if (!string.IsNullOrEmpty(connectionString))
        {
            services.AddHealthChecks()
                .AddSqlServer(
                    connectionString: connectionString,
                    healthQuery: "SELECT 1;",
                    name: "sqlserver",
                    failureStatus: HealthStatus.Unhealthy,
                    tags: new[] { "database", "sql" });
        }

        return services;
    }
}

// Interfaces y clases adicionales necesarias
public interface IFileValidator
{
    bool ValidateFile(Stream fileStream, string contentType, long maxFileSize);
    bool IsImage(string contentType);
    bool IsVideo(string contentType);
    bool IsDocument(string contentType);
}

public class FileValidator : IFileValidator
{
    private readonly HashSet<string> _imageTypes = new()
    {
        "image/jpeg", "image/png", "image/gif", "image/webp", "image/bmp", "image/svg+xml"
    };

    private readonly HashSet<string> _videoTypes = new()
    {
        "video/mp4", "video/avi", "video/mov", "video/wmv", "video/flv", "video/webm"
    };

    private readonly HashSet<string> _documentTypes = new()
    {
        "application/pdf", "application/msword",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.ms-excel",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    };

    public bool ValidateFile(Stream fileStream, string contentType, long maxFileSize)
    {
        if (fileStream.Length > maxFileSize)
            return false;

        if (!IsImage(contentType) && !IsVideo(contentType) && !IsDocument(contentType))
            return false;

        return true;
    }

    public bool IsImage(string contentType) => _imageTypes.Contains(contentType?.ToLowerInvariant() ?? "");
    public bool IsVideo(string contentType) => _videoTypes.Contains(contentType?.ToLowerInvariant() ?? "");
    public bool IsDocument(string contentType) => _documentTypes.Contains(contentType?.ToLowerInvariant() ?? "");
}

public interface IStorageHealthChecker
{
    Task<bool> CheckStorageHealthAsync();
}

public class StorageHealthChecker : IStorageHealthChecker
{
    private readonly IMediaStorageService _storageService;
    private readonly ILogger<StorageHealthChecker> _logger;

    public StorageHealthChecker(IMediaStorageService storageService, ILogger<StorageHealthChecker> logger)
    {
        _storageService = storageService;
        _logger = logger;
    }

    public async Task<bool> CheckStorageHealthAsync()
    {
        try
        {
            return await _storageService.IsHealthyAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error checking storage health");
            return false;
        }
    }
}

// Health Check para S3 (implementación básica)
public class S3HealthCheck : IHealthCheck
{
    public Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        return Task.FromResult(HealthCheckResult.Healthy("S3 storage is accessible"));
    }
}

// Clases de opciones
public class LocalStorageOptions
{
    public string BasePath { get; set; } = "wwwroot/uploads";
    public string BaseUrl { get; set; } = "https://localhost:7000/uploads";
}

public class AzureBlobStorageOptions
{
    public string ConnectionString { get; set; } = string.Empty;
    public string ContainerName { get; set; } = "media";
    public string CdnBaseUrl { get; set; } = string.Empty;
    public long MaxUploadSizeBytes { get; set; } = 104857600;
    public string[] AllowedContentTypes { get; set; } = Array.Empty<string>();
    public int SasTokenExpirationMinutes { get; set; } = 60;
}

public class S3StorageOptions
{
    public string AccessKey { get; set; } = string.Empty;
    public string SecretKey { get; set; } = string.Empty;
    public string Region { get; set; } = "us-east-1";
    public string BucketName { get; set; } = "media-service";
    public string CdnBaseUrl { get; set; } = string.Empty;
    public long MaxUploadSizeBytes { get; set; } = 104857600;
    public string[] AllowedContentTypes { get; set; } = Array.Empty<string>();
    public int PreSignedUrlExpirationMinutes { get; set; } = 60;
}

---- File: MediaService.Infrastructure\HealthChecks\DatabaseHealthCheck.cs ----
using Microsoft.Extensions.Diagnostics.HealthChecks;
using MediaService.Infrastructure.Persistence;

namespace MediaService.Infrastructure.HealthChecks;

public class DatabaseHealthCheck : IHealthCheck
{
    private readonly ApplicationDbContext _context;

    public DatabaseHealthCheck(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            var canConnect = await _context.Database.CanConnectAsync(cancellationToken);
            if (canConnect)
            {
                return HealthCheckResult.Healthy("Database is available.");
            }
            else
            {
                return HealthCheckResult.Unhealthy("Cannot connect to database.");
            }
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Database health check failed.", ex);
        }
    }
}

---- File: MediaService.Infrastructure\HealthChecks\StorageHealthCheck.cs ----
using Microsoft.Extensions.Diagnostics.HealthChecks;
using MediaService.Domain.Interfaces.Services;

namespace MediaService.Infrastructure.HealthChecks;

public class StorageHealthCheck : IHealthCheck
{
    private readonly IMediaStorageService _storageService;

    public StorageHealthCheck(IMediaStorageService storageService)
    {
        _storageService = storageService;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            var isHealthy = await _storageService.IsHealthyAsync();
            if (isHealthy)
            {
                return HealthCheckResult.Healthy("Storage service is available.");
            }
            else
            {
                return HealthCheckResult.Unhealthy("Storage service is unavailable.");
            }
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Storage health check failed.", ex);
        }
    }
}

---- File: MediaService.Infrastructure\Messaging\RabbitMQMediaConsumer.cs ----
using System.Text;
using System.Text.Json;
using MediatR;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using MediaService.Application.Features.Media.Commands.ProcessMedia; // ✅ Agregar using
using MediaService.Shared; // ✅ Agregar using

namespace MediaService.Infrastructure.Messaging;

public class RabbitMQMediaConsumer : BackgroundService
{
    private readonly RabbitMQSettings _settings;
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<RabbitMQMediaConsumer> _logger;
    private IConnection? _connection;
    private IModel? _channel;
    private bool _disposed = false;

    public RabbitMQMediaConsumer(
        IOptions<RabbitMQSettings> settings,
        IServiceProvider serviceProvider,
        ILogger<RabbitMQMediaConsumer> logger)
    {
        _settings = settings.Value;
        _serviceProvider = serviceProvider;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await InitializeConnectionAsync();

        var consumer = new AsyncEventingBasicConsumer(_channel);
        consumer.Received += async (model, ea) =>
        {
            await ProcessMessageAsync(ea);
        };

        // Start consuming from the process media queue
        _channel!.BasicConsume( // ✅ Agregar null-forgiving operator
            queue: _settings.ProcessMediaQueue,
            autoAck: false,
            consumer: consumer);

        _logger.LogInformation("RabbitMQ Media Consumer started listening on queue: {Queue}", _settings.ProcessMediaQueue);

        while (!stoppingToken.IsCancellationRequested)
        {
            await Task.Delay(1000, stoppingToken);
        }
    }

    private async Task InitializeConnectionAsync()
    {
        try
        {
            var factory = new ConnectionFactory
            {
                HostName = _settings.HostName,
                Port = _settings.Port,
                UserName = _settings.UserName,
                Password = _settings.Password,
                VirtualHost = _settings.VirtualHost,
                DispatchConsumersAsync = true
            };

            _connection = factory.CreateConnection();
            _channel = _connection.CreateModel();

            // Ensure exchanges and queues are declared (same as producer)
            _channel.ExchangeDeclare(_settings.MediaCommandsExchange, ExchangeType.Direct, durable: true);
            _channel.QueueDeclare(_settings.ProcessMediaQueue, durable: true, exclusive: false, autoDelete: false);
            _channel.QueueBind(_settings.ProcessMediaQueue, _settings.MediaCommandsExchange, _settings.ProcessMediaRoutingKey);

            // Configure quality of service
            _channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize RabbitMQ connection for consumer");
            throw;
        }
    }

    private async Task ProcessMessageAsync(BasicDeliverEventArgs ea)
    {
        string message = string.Empty;
        ulong deliveryTag = ea.DeliveryTag;

        try
        {
            var body = ea.Body.ToArray();
            message = Encoding.UTF8.GetString(body);

            _logger.LogDebug("Received message from RabbitMQ: {Message}", message);

            // Process based on routing key
            switch (ea.RoutingKey)
            {
                case var key when key == _settings.ProcessMediaRoutingKey:
                    await ProcessMediaCommandAsync(message);
                    break;
                default:
                    _logger.LogWarning("Unknown routing key: {RoutingKey}", ea.RoutingKey);
                    break;
            }

            // Acknowledge the message - ✅ Corregir referencia nula
            if (_channel != null && _channel.IsOpen)
            {
                _channel.BasicAck(deliveryTag, multiple: false);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing message from RabbitMQ. Message: {Message}", message);

            // Reject and requeue the message - ✅ Corregir referencia nula
            if (_channel != null && _channel.IsOpen)
            {
                _channel.BasicNack(deliveryTag, multiple: false, requeue: false);
            }
        }
    }

    private async Task ProcessMediaCommandAsync(string message)
    {
        try
        {
            using var scope = _serviceProvider.CreateScope();
            var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();

            // ✅ Usar la clase de comando real en lugar de la clase helper
            var commandData = JsonSerializer.Deserialize<ProcessMediaCommandData>(message, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            });

            if (commandData == null)
            {
                _logger.LogWarning("Failed to deserialize process media command: {Message}", message);
                return;
            }

            _logger.LogInformation("Processing media command for {MediaId}", commandData.MediaId);

            // ✅ Crear el comando real de MediatR
            var command = new ProcessMediaCommand(
                commandData.MediaId,
                commandData.ProcessingType,
                commandData.ProcessingOptions);

            // Send the command through MediatR pipeline
            var result = await mediator.Send(command);

            // ✅ CORRECCIÓN: Acceder a las propiedades correctamente
            if (result.Success) // ✅ Ya no da error CS1061
            {
                _logger.LogInformation("Successfully processed media {MediaId}", commandData.MediaId);
            }
            else
            {
                _logger.LogWarning("Failed to process media {MediaId}: {Error}", commandData.MediaId, result.Error);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to process media command: {Message}", message);
            throw;
        }
    }

    // ✅ Clase auxiliar para deserialización
    private class ProcessMediaCommandData
    {
        public string MediaId { get; set; } = string.Empty;
        public string? ProcessingType { get; set; }
        public Dictionary<string, object>? ProcessingOptions { get; set; }
        public DateTime Timestamp { get; set; }
        public string CommandId { get; set; } = string.Empty;
    }

    public override void Dispose()
    {
        if (!_disposed)
        {
            _channel?.Close();
            _connection?.Close();
            _channel?.Dispose();
            _connection?.Dispose();
            base.Dispose();
            _disposed = true;
        }
    }
}

---- File: MediaService.Infrastructure\Messaging\RabbitMQMediaProducer.cs ----
using System.Text;
using System.Text.Json;
using MediaService.Domain.Common;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;

namespace MediaService.Infrastructure.Messaging;

public interface IRabbitMQMediaProducer
{
    Task PublishDomainEventAsync(DomainEvent domainEvent);
    Task PublishProcessMediaCommandAsync(string mediaId, string? processingType = null);
    bool IsConnected { get; }
}

public class RabbitMQMediaProducer : IRabbitMQMediaProducer, IDisposable
{
    private readonly RabbitMQSettings _settings;
    private readonly ILogger<RabbitMQMediaProducer> _logger;
    private IConnection? _connection;
    private IModel? _channel;
    private bool _disposed = false;

    public bool IsConnected => _connection?.IsOpen == true && _channel?.IsOpen == true;

    public RabbitMQMediaProducer(IOptions<RabbitMQSettings> settings, ILogger<RabbitMQMediaProducer> logger)
    {
        _settings = settings.Value;
        _logger = logger;
        InitializeConnection();
    }

    private void InitializeConnection()
    {
        try
        {
            var factory = new ConnectionFactory
            {
                HostName = _settings.HostName,
                Port = _settings.Port,
                UserName = _settings.UserName,
                Password = _settings.Password,
                VirtualHost = _settings.VirtualHost,
                DispatchConsumersAsync = true
            };

            _connection = factory.CreateConnection();
            _channel = _connection.CreateModel();

            // Declare exchanges
            _channel.ExchangeDeclare(
                exchange: _settings.MediaEventsExchange,
                type: ExchangeType.Topic,
                durable: true,
                autoDelete: false);

            _channel.ExchangeDeclare(
                exchange: _settings.MediaCommandsExchange,
                type: ExchangeType.Direct,
                durable: true,
                autoDelete: false);

            // Declare queues for events
            _channel.QueueDeclare(
                queue: _settings.MediaUploadedQueue,
                durable: true,
                exclusive: false,
                autoDelete: false);

            _channel.QueueDeclare(
                queue: _settings.MediaProcessedQueue,
                durable: true,
                exclusive: false,
                autoDelete: false);

            _channel.QueueDeclare(
                queue: _settings.MediaDeletedQueue,
                durable: true,
                exclusive: false,
                autoDelete: false);

            _channel.QueueDeclare(
                queue: _settings.ProcessMediaQueue,
                durable: true,
                exclusive: false,
                autoDelete: false);

            // Bind queues to exchanges
            _channel.QueueBind(
                queue: _settings.MediaUploadedQueue,
                exchange: _settings.MediaEventsExchange,
                routingKey: _settings.MediaUploadedRoutingKey);

            _channel.QueueBind(
                queue: _settings.MediaProcessedQueue,
                exchange: _settings.MediaEventsExchange,
                routingKey: _settings.MediaProcessedRoutingKey);

            _channel.QueueBind(
                queue: _settings.MediaDeletedQueue,
                exchange: _settings.MediaEventsExchange,
                routingKey: _settings.MediaDeletedRoutingKey);

            _channel.QueueBind(
                queue: _settings.ProcessMediaQueue,
                exchange: _settings.MediaCommandsExchange,
                routingKey: _settings.ProcessMediaRoutingKey);

            _logger.LogInformation("RabbitMQ Media Producer initialized successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize RabbitMQ connection");
            throw;
        }
    }

    public async Task PublishDomainEventAsync(DomainEvent domainEvent)
    {
        if (!IsConnected)
        {
            throw new InvalidOperationException("RabbitMQ connection is not available");
        }

        try
        {
            var routingKey = GetRoutingKeyForDomainEvent(domainEvent);
            var exchange = _settings.MediaEventsExchange;

            var message = JsonSerializer.Serialize(domainEvent, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = false
            });

            var body = Encoding.UTF8.GetBytes(message);

            var properties = _channel!.CreateBasicProperties();
            properties.Persistent = true;
            properties.ContentType = "application/json";
            properties.MessageId = domainEvent.EventId;
            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());
            properties.Headers = new Dictionary<string, object>
            {
                ["EventType"] = domainEvent.GetType().Name,
                ["ServiceName"] = domainEvent.ServiceName,
                ["OccurredOn"] = domainEvent.OccurredOn.ToString("O")
            };

            if (!string.IsNullOrEmpty(domainEvent.CorrelationId))
            {
                properties.CorrelationId = domainEvent.CorrelationId;
            }

            if (!string.IsNullOrEmpty(domainEvent.UserId))
            {
                properties.Headers["UserId"] = domainEvent.UserId;
            }

            _channel.BasicPublish(
                exchange: exchange,
                routingKey: routingKey,
                basicProperties: properties,
                body: body);

            _logger.LogDebug("Published domain event {EventType} with ID {EventId} to {Exchange}/{RoutingKey}",
                domainEvent.GetType().Name, domainEvent.EventId, exchange, routingKey);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to publish domain event {EventId}", domainEvent.EventId);
            throw;
        }
    }

    public async Task PublishProcessMediaCommandAsync(string mediaId, string? processingType = null)
    {
        if (!IsConnected)
        {
            throw new InvalidOperationException("RabbitMQ connection is not available");
        }

        try
        {
            var command = new
            {
                MediaId = mediaId,
                ProcessingType = processingType,
                Timestamp = DateTime.UtcNow,
                CommandId = Guid.NewGuid().ToString()
            };

            var message = JsonSerializer.Serialize(command, new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                WriteIndented = false
            });

            var body = Encoding.UTF8.GetBytes(message);

            var properties = _channel!.CreateBasicProperties();
            properties.Persistent = true;
            properties.ContentType = "application/json";
            properties.MessageId = command.CommandId;
            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());

            _channel.BasicPublish(
                exchange: _settings.MediaCommandsExchange,
                routingKey: _settings.ProcessMediaRoutingKey,
                basicProperties: properties,
                body: body);

            _logger.LogInformation("Published process media command for {MediaId}", mediaId);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to publish process media command for {MediaId}", mediaId);
            throw;
        }
    }

    private string GetRoutingKeyForDomainEvent(DomainEvent domainEvent)
    {
        return domainEvent switch
        {
            Domain.Events.MediaUploadedEvent => _settings.MediaUploadedRoutingKey,
            Domain.Events.MediaProcessedEvent => _settings.MediaProcessedRoutingKey,
            Domain.Events.MediaDeletedEvent => _settings.MediaDeletedRoutingKey,
            _ => $"media.unknown.{domainEvent.GetType().Name.ToLower()}"
        };
    }

    public void Dispose()
    {
        if (!_disposed)
        {
            _channel?.Close();
            _connection?.Close();
            _channel?.Dispose();
            _connection?.Dispose();
            _disposed = true;
        }
    }
}

---- File: MediaService.Infrastructure\Messaging\RabbitMQSettings.cs ----
using Microsoft.Extensions.Configuration;

namespace MediaService.Infrastructure.Messaging;

public class RabbitMQSettings
{
    public string HostName { get; set; } = "localhost";
    public int Port { get; set; } = 5672;
    public string UserName { get; set; } = "guest";
    public string Password { get; set; } = "guest";
    public string VirtualHost { get; set; } = "/";

    // Exchanges
    public string MediaEventsExchange { get; set; } = "media.events";
    public string MediaCommandsExchange { get; set; } = "media.commands";

    // Queues
    public string MediaUploadedQueue { get; set; } = "media.uploaded.queue";
    public string MediaProcessedQueue { get; set; } = "media.processed.queue";
    public string MediaDeletedQueue { get; set; } = "media.deleted.queue";
    public string ProcessMediaQueue { get; set; } = "process.media.queue";

    // Routing Keys
    public string MediaUploadedRoutingKey { get; set; } = "media.uploaded";
    public string MediaProcessedRoutingKey { get; set; } = "media.processed";
    public string MediaDeletedRoutingKey { get; set; } = "media.deleted";
    public string ProcessMediaRoutingKey { get; set; } = "media.process";

    public static RabbitMQSettings FromConfiguration(IConfiguration configuration)
    {
        return new RabbitMQSettings
        {
            HostName = configuration["RabbitMQ:HostName"] ?? "localhost",
            Port = int.Parse(configuration["RabbitMQ:Port"] ?? "5672"),
            UserName = configuration["RabbitMQ:UserName"] ?? "guest",
            Password = configuration["RabbitMQ:Password"] ?? "guest",
            VirtualHost = configuration["RabbitMQ:VirtualHost"] ?? "/",
            MediaEventsExchange = configuration["RabbitMQ:MediaEventsExchange"] ?? "media.events",
            MediaCommandsExchange = configuration["RabbitMQ:MediaCommandsExchange"] ?? "media.commands",
            MediaUploadedQueue = configuration["RabbitMQ:MediaUploadedQueue"] ?? "media.uploaded.queue",
            MediaProcessedQueue = configuration["RabbitMQ:MediaProcessedQueue"] ?? "media.processed.queue",
            MediaDeletedQueue = configuration["RabbitMQ:MediaDeletedQueue"] ?? "media.deleted.queue",
            ProcessMediaQueue = configuration["RabbitMQ:ProcessMediaQueue"] ?? "process.media.queue"
        };
    }
}

---- File: MediaService.Infrastructure\Middleware\ErrorHandlingMiddleware.cs ----
using System.Net;
using System.Text.Json;
using MediaService.Shared;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using System.Threading.Tasks;

namespace MediaService.Infrastructure.Middleware;

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred.");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var code = HttpStatusCode.InternalServerError;
        var error = "An unexpected error occurred.";

        // Mapear diferentes excepciones a diferentes códigos de estado
        if (exception is UnauthorizedAccessException)
        {
            code = HttpStatusCode.Unauthorized;
            error = "Unauthorized access.";
        }
        else if (exception is ArgumentException || exception is InvalidOperationException)
        {
            code = HttpStatusCode.BadRequest;
            error = exception.Message;
        }
        else if (exception is KeyNotFoundException)
        {
            code = HttpStatusCode.NotFound;
            error = "Resource not found.";
        }

        var result = JsonSerializer.Serialize(ApiResponse.Fail(error));
        context.Response.ContentType = "application/json";
        context.Response.StatusCode = (int)code;
        await context.Response.WriteAsync(result);
    }
}

---- File: MediaService.Infrastructure\Persistence\ApplicationDbContext.cs ----
using MediaService.Domain.Entities;
using MediaService.Infrastructure.Persistence.Configurations;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;

namespace MediaService.Infrastructure.Persistence
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options)
        {
        }

        // DbSets para todas las entidades
        public DbSet<MediaAsset> MediaAssets { get; set; }
        public DbSet<MediaVariant> MediaVariants { get; set; }
        public DbSet<ImageMedia> ImageMedia { get; set; }
        public DbSet<VideoMedia> VideoMedia { get; set; }
        public DbSet<DocumentMedia> DocumentMedia { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Aplicar configuraciones desde el assembly
            modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);

            // Configuraciones específicas
            modelBuilder.Entity<MediaAsset>(entity =>
            {
                entity.ToTable("media_assets");
                entity.HasKey(e => e.Id);
                entity.HasIndex(e => e.CreatedAt);
                entity.HasIndex(e => e.Status);
                entity.HasIndex(e => e.ContentType);

                // Relación con variantes
                entity.HasMany(e => e.Variants)
                      .WithOne(v => v.MediaAsset)
                      .HasForeignKey(v => v.MediaAssetId)
                      .OnDelete(DeleteBehavior.Cascade);

                // Discriminador para herencia TPH
                entity.HasDiscriminator<string>("MediaType")
                      .HasValue<ImageMedia>("Image")
                      .HasValue<VideoMedia>("Video")
                      .HasValue<DocumentMedia>("Document")
                      .HasValue<MediaAsset>("Other");
            });

            modelBuilder.Entity<MediaVariant>(entity =>
            {
                entity.ToTable("media_variants");
                entity.HasKey(e => e.Id);
                entity.HasIndex(e => new { e.MediaAssetId, e.Name }).IsUnique();
                entity.HasIndex(e => e.Width);
                entity.HasIndex(e => e.Height);
                entity.HasIndex(e => e.Quality);
            });

            modelBuilder.Entity<ImageMedia>(entity =>
            {
                entity.HasBaseType<MediaAsset>();
                entity.ToTable("image_media");
            });

            modelBuilder.Entity<VideoMedia>(entity =>
            {
                entity.HasBaseType<MediaAsset>();
                entity.ToTable("video_media");
            });

            modelBuilder.Entity<DocumentMedia>(entity =>
            {
                entity.HasBaseType<MediaAsset>();
                entity.ToTable("document_media");
            });
        }
        public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            var entries = ChangeTracker.Entries()
                .Where(e => e.Entity is Domain.Common.EntityBase && (
                        e.State == EntityState.Added
                        || e.State == EntityState.Modified));

            foreach (var entityEntry in entries)
            {
                var entity = (Domain.Common.EntityBase)entityEntry.Entity;

                if (entityEntry.State == EntityState.Added)
                {
                    var createdAtProperty = entity.GetType().GetProperty("CreatedAt");
                    if (createdAtProperty != null && createdAtProperty.CanWrite)
                    {
                        createdAtProperty.SetValue(entity, DateTime.UtcNow);
                    }
                }

                entity.MarkAsUpdated();
            }

            return await base.SaveChangesAsync(cancellationToken);
        }
    }
}

---- File: MediaService.Infrastructure\Persistence\Configurations\ImageMediaConfiguration.cs ----
using MediaService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace MediaService.Infrastructure.Persistence.Configurations;

public class ImageMediaConfiguration : IEntityTypeConfiguration<ImageMedia>
{
    public void Configure(EntityTypeBuilder<ImageMedia> builder)
    {
        builder.ToTable("image_media");

        builder.Property(x => x.Width)
            .IsRequired();

        builder.Property(x => x.Height)
            .IsRequired();

        builder.Property(x => x.HashSha256)
            .HasMaxLength(64);

        builder.Property(x => x.AltText)
            .HasMaxLength(500);

        // Índices específicos para imágenes
        builder.HasIndex(x => x.Width);
        builder.HasIndex(x => x.Height);
        builder.HasIndex(x => x.IsPrimary);
    }
}

---- File: MediaService.Infrastructure\Persistence\Configurations\MediaAssetConfiguration.cs ----
using MediaService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace MediaService.Infrastructure.Persistence.Configurations;

public class MediaAssetConfiguration : IEntityTypeConfiguration<MediaAsset>
{
    public void Configure(EntityTypeBuilder<MediaAsset> builder)
    {
        builder.ToTable("media_assets");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.OwnerId)
            .HasMaxLength(100)
            .IsRequired();

        builder.Property(x => x.Context)
            .HasMaxLength(50);

        builder.Property(x => x.Type)
            .HasConversion<string>()
            .HasMaxLength(20)
            .IsRequired();

        builder.Property(x => x.OriginalFileName)
            .HasMaxLength(255)
            .IsRequired();

        builder.Property(x => x.ContentType)
            .HasMaxLength(100)
            .IsRequired();

        builder.Property(x => x.SizeBytes)
            .IsRequired();

        builder.Property(x => x.Status)
            .HasConversion<string>()
            .HasMaxLength(20)
            .IsRequired();

        builder.Property(x => x.ProcessingError)
            .HasMaxLength(1000);

        builder.Property(x => x.StorageKey)
            .HasMaxLength(1024)
            .IsRequired();

        builder.Property(x => x.CdnUrl)
            .HasMaxLength(1024);

        builder.Property(x => x.CreatedAt)
            .IsRequired();

        builder.Property(x => x.UpdatedAt);

        builder.Property(x => x.ProcessedAt);

        // Índices para mejor performance
        builder.HasIndex(x => x.OwnerId);
        builder.HasIndex(x => x.Context);
        builder.HasIndex(x => x.Type);
        builder.HasIndex(x => x.Status);
        builder.HasIndex(x => x.CreatedAt);
        builder.HasIndex(x => new { x.OwnerId, x.Context });
    }
}

---- File: MediaService.Infrastructure\Persistence\Configurations\MediaVariantConfiguration.cs ----
using MediaService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace MediaService.Infrastructure.Persistence.Configurations;

public class MediaVariantConfiguration : IEntityTypeConfiguration<MediaVariant>
{
    public void Configure(EntityTypeBuilder<MediaVariant> builder)
    {
        builder.ToTable("media_variants");

        builder.HasKey(x => x.Id);

        builder.Property(x => x.Id)
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.MediaAssetId)
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.Name)
            .HasMaxLength(50)
            .IsRequired();

        builder.Property(x => x.StorageKey)
            .HasMaxLength(1024)
            .IsRequired();

        builder.Property(x => x.CdnUrl)
            .HasMaxLength(1024);

        builder.Property(x => x.Format)
            .HasMaxLength(20);

        builder.Property(x => x.VideoProfile)
            .HasMaxLength(50);

        builder.Property(x => x.CreatedAt)
            .IsRequired();

        builder.Property(x => x.UpdatedAt);

        // Relación con MediaAsset
        builder.HasOne(x => x.MediaAsset)
            .WithMany(x => x.Variants)
            .HasForeignKey(x => x.MediaAssetId)
            .OnDelete(DeleteBehavior.Cascade);

        // Índices compuestos para mejor performance
        builder.HasIndex(x => x.MediaAssetId);
        builder.HasIndex(x => new { x.MediaAssetId, x.Name })
            .IsUnique();
        builder.HasIndex(x => x.StorageKey);
    }
}

---- File: MediaService.Infrastructure\Persistence\Configurations\VideoMediaConfiguration.cs ----
using MediaService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace MediaService.Infrastructure.Persistence.Configurations;

public class VideoMediaConfiguration : IEntityTypeConfiguration<VideoMedia>
{
    public void Configure(EntityTypeBuilder<VideoMedia> builder)
    {
        builder.ToTable("video_media");

        builder.Property(x => x.Duration);

        builder.Property(x => x.Width);

        builder.Property(x => x.Height);

        builder.Property(x => x.VideoCodec)
            .HasMaxLength(50);

        builder.Property(x => x.AudioCodec)
            .HasMaxLength(50);

        builder.Property(x => x.FrameRate);

        builder.Property(x => x.Bitrate);

        builder.Property(x => x.StorageKeyInput)
            .HasMaxLength(1024)
            .IsRequired();

        builder.Property(x => x.StorageKeyHls)
            .HasMaxLength(1024);

        // Índices específicos para videos
        builder.HasIndex(x => x.Duration);
        builder.HasIndex(x => x.HasHlsStream);
    }
}

---- File: MediaService.Infrastructure\Repositories\MediaRepository.cs ----
using MediaService.Domain.Entities;
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;

namespace MediaService.Infrastructure.Repositories;

public class MediaRepository : IMediaRepository
{
    private readonly ApplicationDbContext _context;

    public MediaRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<MediaAsset?> GetByIdAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _context.MediaAssets
            .Include(x => x.Variants)
            .FirstOrDefaultAsync(x => x.Id == id, cancellationToken);
    }

    public async Task<IEnumerable<MediaAsset>> GetByOwnerIdAsync(string ownerId, string? context = null, CancellationToken cancellationToken = default)
    {
        var query = _context.MediaAssets
            .Where(x => x.OwnerId == ownerId);

        if (!string.IsNullOrEmpty(context))
        {
            query = query.Where(x => x.Context == context);
        }

        return await query
            .Include(x => x.Variants)
            .OrderByDescending(x => x.CreatedAt)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<MediaAsset>> GetByTypeAsync(Domain.Enums.MediaType type, CancellationToken cancellationToken = default)
    {
        return await _context.MediaAssets
            .Where(x => x.Type == type)
            .Include(x => x.Variants)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<MediaAsset>> GetByStatusAsync(Domain.Enums.MediaStatus status, CancellationToken cancellationToken = default)
    {
        return await _context.MediaAssets
            .Where(x => x.Status == status)
            .Include(x => x.Variants)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<ImageMedia>> GetUnprocessedImagesAsync(CancellationToken cancellationToken = default)
    {
        return await _context.ImageMedia
            .Where(x => x.Status == Domain.Enums.MediaStatus.Uploaded)
            .Include(x => x.Variants)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<VideoMedia>> GetUnprocessedVideosAsync(CancellationToken cancellationToken = default)
    {
        return await _context.VideoMedia
            .Where(x => x.Status == Domain.Enums.MediaStatus.Uploaded)
            .Include(x => x.Variants)
            .ToListAsync(cancellationToken);
    }

    public async Task<(IEnumerable<MediaAsset> items, int totalCount)> GetPaginatedAsync(
        string? ownerId = null,
        string? context = null,
        Domain.Enums.MediaType? type = null,
        Domain.Enums.MediaStatus? status = null,
        DateTime? fromDate = null,
        DateTime? toDate = null,
        int page = 1,
        int pageSize = 50,
        string? sortBy = null,
        bool sortDescending = true)
    {
        var query = _context.MediaAssets.AsQueryable();

        if (!string.IsNullOrEmpty(ownerId))
        {
            query = query.Where(x => x.OwnerId == ownerId);
        }

        if (!string.IsNullOrEmpty(context))
        {
            query = query.Where(x => x.Context == context);
        }

        if (type.HasValue)
        {
            query = query.Where(x => x.Type == type.Value);
        }

        if (status.HasValue)
        {
            query = query.Where(x => x.Status == status.Value);
        }

        if (fromDate.HasValue)
        {
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        }

        if (toDate.HasValue)
        {
            query = query.Where(x => x.CreatedAt <= toDate.Value);
        }

        var totalCount = await query.CountAsync();

        // Sorting
        if (!string.IsNullOrEmpty(sortBy))
        {
            switch (sortBy.ToLower())
            {
                case "createdat":
                    query = sortDescending ? query.OrderByDescending(x => x.CreatedAt) : query.OrderBy(x => x.CreatedAt);
                    break;
                case "sizebytes":
                    query = sortDescending ? query.OrderByDescending(x => x.SizeBytes) : query.OrderBy(x => x.SizeBytes);
                    break;
                default:
                    query = sortDescending ? query.OrderByDescending(x => x.CreatedAt) : query.OrderBy(x => x.CreatedAt);
                    break;
            }
        }
        else
        {
            query = query.OrderByDescending(x => x.CreatedAt);
        }

        var items = await query
            .Include(x => x.Variants)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        return (items, totalCount);
    }

    public async Task AddAsync(MediaAsset mediaAsset, CancellationToken cancellationToken = default)
    {
        _context.MediaAssets.Add(mediaAsset);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task UpdateAsync(MediaAsset mediaAsset, CancellationToken cancellationToken = default)
    {
        _context.MediaAssets.Update(mediaAsset);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task DeleteAsync(MediaAsset mediaAsset, CancellationToken cancellationToken = default)
    {
        _context.MediaAssets.Remove(mediaAsset);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task DeleteRangeAsync(IEnumerable<MediaAsset> mediaAssets, CancellationToken cancellationToken = default)
    {
        _context.MediaAssets.RemoveRange(mediaAssets);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task<bool> ExistsAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _context.MediaAssets
            .AnyAsync(x => x.Id == id, cancellationToken);
    }

    public async Task<int> GetTotalCountAsync(CancellationToken cancellationToken = default)
    {
        return await _context.MediaAssets.CountAsync(cancellationToken);
    }

    public async Task<MediaStatistics> GetStatisticsAsync(DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default)
    {
        var query = _context.MediaAssets.AsQueryable();

        if (fromDate.HasValue)
        {
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        }

        if (toDate.HasValue)
        {
            query = query.Where(x => x.CreatedAt <= toDate.Value);
        }

        var totalMedia = await query.CountAsync(cancellationToken);
        var images = await query.CountAsync(x => x.Type == Domain.Enums.MediaType.Image, cancellationToken);
        var videos = await query.CountAsync(x => x.Type == Domain.Enums.MediaType.Video, cancellationToken);
        var documents = await query.CountAsync(x => x.Type == Domain.Enums.MediaType.Document, cancellationToken);
        var audio = await query.CountAsync(x => x.Type == Domain.Enums.MediaType.Audio, cancellationToken);
        var processed = await query.CountAsync(x => x.Status == Domain.Enums.MediaStatus.Processed, cancellationToken);
        var processing = await query.CountAsync(x => x.Status == Domain.Enums.MediaStatus.Processing, cancellationToken);
        var failed = await query.CountAsync(x => x.Status == Domain.Enums.MediaStatus.Failed, cancellationToken);
        var totalStorageBytes = await query.SumAsync(x => x.SizeBytes, cancellationToken);
        var firstMediaDate = await query.MinAsync(x => (DateTime?)x.CreatedAt, cancellationToken);
        var lastMediaDate = await query.MaxAsync(x => (DateTime?)x.CreatedAt, cancellationToken);

        var mediaByContext = await query
            .Where(x => x.Context != null)
            .GroupBy(x => x.Context!)
            .Select(g => new { Context = g.Key, Count = g.Count() })
            .ToDictionaryAsync(x => x.Context, x => x.Count, cancellationToken);

        return new MediaStatistics
        {
            TotalMedia = totalMedia,
            Images = images,
            Videos = videos,
            Documents = documents,
            Audio = audio,
            Processed = processed,
            Processing = processing,
            Failed = failed,
            TotalStorageBytes = totalStorageBytes,
            FirstMediaDate = firstMediaDate,
            LastMediaDate = lastMediaDate,
            MediaByContext = mediaByContext
        };
    }
}

---- File: MediaService.Infrastructure\Repositories\MediaVariantRepository.cs ----
using MediaService.Domain.Entities;
using MediaService.Domain.Interfaces.Repositories;
using MediaService.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace MediaService.Infrastructure.Repositories;

public class MediaVariantRepository : IMediaVariantRepository
{
    private readonly ApplicationDbContext _context;

    public MediaVariantRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<MediaVariant?> GetByIdAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _context.MediaVariants
            .FirstOrDefaultAsync(v => v.Id == id, cancellationToken);
    }

    public async Task<IEnumerable<MediaVariant>> GetByMediaIdAsync(string mediaId, CancellationToken cancellationToken = default)
    {
        return await _context.MediaVariants
            .Where(v => v.MediaAssetId == mediaId)
            .OrderBy(v => v.Name)
            .ToListAsync(cancellationToken);
    }

    public async Task<MediaVariant?> GetByMediaIdAndNameAsync(string mediaId, string variantName, CancellationToken cancellationToken = default)
    {
        return await _context.MediaVariants
            .FirstOrDefaultAsync(v => v.MediaAssetId == mediaId && v.Name == variantName, cancellationToken);
    }

    public async Task AddAsync(MediaVariant mediaVariant, CancellationToken cancellationToken = default)
    {
        await _context.MediaVariants.AddAsync(mediaVariant, cancellationToken);
    }

    public async Task AddRangeAsync(IEnumerable<MediaVariant> mediaVariants, CancellationToken cancellationToken = default)
    {
        await _context.MediaVariants.AddRangeAsync(mediaVariants, cancellationToken);
    }

    public async Task UpdateAsync(MediaVariant mediaVariant, CancellationToken cancellationToken = default)
    {
        _context.MediaVariants.Update(mediaVariant);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task DeleteAsync(MediaVariant mediaVariant, CancellationToken cancellationToken = default)
    {
        _context.MediaVariants.Remove(mediaVariant);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task DeleteByMediaIdAsync(string mediaId, CancellationToken cancellationToken = default)
    {
        var variants = await _context.MediaVariants
            .Where(v => v.MediaAssetId == mediaId)
            .ToListAsync(cancellationToken);

        _context.MediaVariants.RemoveRange(variants);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task<bool> ExistsAsync(string mediaId, string variantName, CancellationToken cancellationToken = default)
    {
        return await _context.MediaVariants
            .AnyAsync(v => v.MediaAssetId == mediaId && v.Name == variantName, cancellationToken);
    }

    public async Task<int> CountByMediaIdAsync(string mediaId, CancellationToken cancellationToken = default)
    {
        return await _context.MediaVariants
            .CountAsync(v => v.MediaAssetId == mediaId, cancellationToken);
    }

    public async Task<IEnumerable<MediaVariant>> GetByDimensionsAsync(int? minWidth = null, int? maxWidth = null,
                                                                     int? minHeight = null, int? maxHeight = null,
                                                                     CancellationToken cancellationToken = default)
    {
        var query = _context.MediaVariants.AsQueryable();

        if (minWidth.HasValue)
            query = query.Where(v => v.Width >= minWidth.Value);

        if (maxWidth.HasValue)
            query = query.Where(v => v.Width <= maxWidth.Value);

        if (minHeight.HasValue)
            query = query.Where(v => v.Height >= minHeight.Value);

        if (maxHeight.HasValue)
            query = query.Where(v => v.Height <= maxHeight.Value);

        return await query.ToListAsync(cancellationToken);
    }
}

---- File: MediaService.Infrastructure\Services\Processing\FfmpegVideoProcessor.cs ----
using MediaService.Domain.Interfaces.Services;
using Microsoft.Extensions.Logging;

namespace MediaService.Infrastructure.Services.Processing;

public class FfmpegVideoProcessor : IVideoProcessor
{
    private readonly ILogger<FfmpegVideoProcessor> _logger;

    public FfmpegVideoProcessor(ILogger<FfmpegVideoProcessor> logger)
    {
        _logger = logger;
    }

    public async Task<VideoProcessingResult> ProcessVideoAsync(Stream videoStream, string originalFileName, VideoProcessingConfig config)
    {
        _logger.LogInformation("Processing video: {FileName}", originalFileName);

        // Implementación básica - en producción integrar con FFmpeg
        var result = new VideoProcessingResult
        {
            Success = true,
            OriginalVideoInfo = new VideoInfo(),
            Variants = new List<ProcessedVideoVariant>(),
            Thumbnails = new List<ProcessedThumbnail>(),
            ProcessingDuration = TimeSpan.Zero
        };

        return await Task.FromResult(result);
    }

    public async Task<VideoInfo> GetVideoInfoAsync(Stream videoStream)
    {
        // Implementación básica
        return await Task.FromResult(new VideoInfo
        {
            Width = 1920,
            Height = 1080,
            Duration = TimeSpan.FromMinutes(2),
            Bitrate = 5000000,
            FileSize = videoStream.Length
        });
    }

    public async Task<bool> ValidateVideoAsync(Stream videoStream, string contentType)
    {
        var allowedTypes = new[] { "video/mp4", "video/avi", "video/mov" };
        return allowedTypes.Contains(contentType);
    }

    public async Task<List<Stream>> GenerateThumbnailsAsync(Stream videoStream, int count, int? width = null, int? height = null)
    {
        // Implementación básica - generar thumbnails vacíos
        var thumbnails = new List<Stream>();
        for (int i = 0; i < count; i++)
        {
            thumbnails.Add(new MemoryStream());
        }
        return await Task.FromResult(thumbnails);
    }

    public async Task<Stream> ExtractAudioAsync(Stream videoStream, string audioFormat)
    {
        // Implementación básica
        return await Task.FromResult(Stream.Null);
    }
}

---- File: MediaService.Infrastructure\Services\Processing\IImageProcessor.cs ----

---- File: MediaService.Infrastructure\Services\Processing\ImageSharpProcessor.cs ----
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Formats;
using SixLabors.ImageSharp.Formats.Jpeg;
using SixLabors.ImageSharp.Formats.Png;
using SixLabors.ImageSharp.Processing;
using MediaService.Domain.Interfaces.Services;
using Microsoft.Extensions.Logging;
using DomainImageInfo = MediaService.Domain.Interfaces.Services.ImageInfo;

namespace MediaService.Infrastructure.Services.Processing;

public class ImageSharpProcessor : IImageProcessor
{
    private readonly ILogger<ImageSharpProcessor> _logger;

    public ImageSharpProcessor(ILogger<ImageSharpProcessor> logger)
    {
        _logger = logger;
    }

    public async Task<ImageProcessingResult> ProcessImageAsync(Stream imageStream, string originalFileName, IEnumerable<ImageVariantConfig> variants)
    {
        var result = new ImageProcessingResult();

        try
        {
            imageStream.Position = 0;
            using var image = await Image.LoadAsync(imageStream);
            result.OriginalImageInfo = new DomainImageInfo
            {
                Width = image.Width,
                Height = image.Height,
                Format = image.Metadata.DecodedImageFormat?.Name ?? "Unknown",
                FileSize = imageStream.Length
            };

            foreach (var variantConfig in variants)
            {
                try
                {
                    imageStream.Position = 0;
                    using var variantImage = await Image.LoadAsync(imageStream);
                    var processedVariant = await ProcessVariantAsync(variantImage, variantConfig);
                    result.Variants.Add(processedVariant);
                }
                catch (Exception ex)
                {
                    _logger.LogWarning(ex, "Failed to process variant {VariantName}", variantConfig.Name);
                }
            }

            result.Success = true;
        }
        catch (Exception ex)
        {
            result.Success = false;
            result.ErrorMessage = ex.Message;
            _logger.LogError(ex, "Image processing failed");
        }

        return result;
    }

    public async Task<DomainImageInfo> GetImageInfoAsync(Stream imageStream)
    {
        try
        {
            imageStream.Position = 0;
            using var image = await Image.LoadAsync(imageStream);
            return new DomainImageInfo
            {
                Width = image.Width,
                Height = image.Height,
                Format = image.Metadata.DecodedImageFormat?.Name ?? "Unknown",
                FileSize = imageStream.Length
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get image info");
            throw;
        }
    }

    public async Task<bool> ValidateImageAsync(Stream imageStream, string contentType)
    {
        try
        {
            imageStream.Position = 0;
            using var image = await Image.LoadAsync(imageStream);
            return image.Width > 0 && image.Height > 0;
        }
        catch
        {
            return false;
        }
    }

    public async Task<Stream> OptimizeImageAsync(Stream imageStream, string contentType, int quality)
    {
        try
        {
            imageStream.Position = 0;
            using var image = await Image.LoadAsync(imageStream);

            var encoder = GetEncoder(contentType, quality);
            var outputStream = new MemoryStream();

            await image.SaveAsync(outputStream, encoder);
            outputStream.Position = 0;

            return outputStream;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Image optimization failed");
            throw;
        }
    }

    public async Task<Stream> CreateThumbnailAsync(Stream imageStream, int width, int height, string resizeMode = "Max")
    {
        try
        {
            imageStream.Position = 0;
            using var image = await Image.LoadAsync(imageStream);

            var resizeOptions = new ResizeOptions
            {
                Size = new Size(width, height),
                Mode = GetResizeMode(resizeMode)
            };

            image.Mutate(x => x.Resize(resizeOptions));

            var outputStream = new MemoryStream();
            await image.SaveAsync(outputStream, new JpegEncoder { Quality = 80 });
            outputStream.Position = 0;

            return outputStream;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Thumbnail creation failed");
            throw;
        }
    }

    private async Task<ProcessedVariant> ProcessVariantAsync(Image image, ImageVariantConfig config)
    {
        var resizeOptions = new ResizeOptions
        {
            Size = new Size(config.MaxWidth, config.MaxHeight),
            Mode = GetResizeMode(config.ResizeMode)
        };

        image.Mutate(x => x.Resize(resizeOptions));

        var encoder = GetEncoder(config.Format, config.Quality);
        var outputStream = new MemoryStream();

        await image.SaveAsync(outputStream, encoder);
        outputStream.Position = 0;

        return new ProcessedVariant
        {
            Name = config.Name,
            ImageStream = outputStream,
            ContentType = GetContentType(config.Format),
            SizeBytes = outputStream.Length,
            Width = image.Width,
            Height = image.Height,
            StorageKey = $"{config.Name}_{image.Width}x{image.Height}"
        };
    }

    private static ResizeMode GetResizeMode(string mode)
    {
        return mode.ToLower() switch
        {
            "crop" => ResizeMode.Crop,
            "pad" => ResizeMode.Pad,
            "boxpad" => ResizeMode.BoxPad,
            "max" => ResizeMode.Max,
            "min" => ResizeMode.Min,
            "stretch" => ResizeMode.Stretch,
            _ => ResizeMode.Max
        };
    }

    private static IImageEncoder GetEncoder(string format, int quality)
    {
        return format.ToLower() switch
        {
            "png" => new PngEncoder(),
            "webp" => new SixLabors.ImageSharp.Formats.Webp.WebpEncoder { Quality = quality },
            _ => new JpegEncoder { Quality = quality }
        };
    }

    private static string GetContentType(string format)
    {
        return format.ToLower() switch
        {
            "png" => "image/png",
            "webp" => "image/webp",
            _ => "image/jpeg"
        };
    }
}

---- File: MediaService.Infrastructure\Services\Processing\IVideoProcessor.cs ----

---- File: MediaService.Infrastructure\Services\Storage\AzureBlobStorageOptions.cs ----
namespace MediaService.Infrastructure.Services.Storage;

public class AzureBlobStorageOptions
{
    public string ConnectionString { get; set; } = string.Empty;
    public string ContainerName { get; set; } = "media";
    public string CdnBaseUrl { get; set; } = string.Empty;
    public long MaxUploadSizeBytes { get; set; } = 104857600;
    public string[] AllowedContentTypes { get; set; } = Array.Empty<string>();
    public int SasTokenExpirationMinutes { get; set; } = 60;
}

---- File: MediaService.Infrastructure\Services\Storage\AzureBlobStorageService.cs ----
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Azure.Storage.Sas;
using MediaService.Domain.Interfaces.Services;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using MediaService.Infrastructure.Services.Storage;

namespace MediaService.Infrastructure.Services.Storage;

public class AzureBlobStorageService : IMediaStorageService
{
    private readonly BlobServiceClient _blobServiceClient;
    private readonly AzureBlobStorageOptions _options;
    private readonly ILogger<AzureBlobStorageService> _logger;

    public AzureBlobStorageService(IOptions<AzureBlobStorageOptions> options, ILogger<AzureBlobStorageService> logger)
    {
        _options = options.Value;
        _logger = logger;
        _blobServiceClient = new BlobServiceClient(_options.ConnectionString);
    }

    public async Task<UploadUrlResponse> GenerateUploadUrlAsync(string storageKey, string contentType, TimeSpan? expiry = null)
    {
        var containerClient = _blobServiceClient.GetBlobContainerClient(_options.ContainerName);
        await containerClient.CreateIfNotExistsAsync(PublicAccessType.None);

        var blobClient = containerClient.GetBlobClient(storageKey);

        var sasBuilder = new BlobSasBuilder
        {
            BlobContainerName = _options.ContainerName,
            BlobName = storageKey,
            Resource = "b",
            ExpiresOn = DateTimeOffset.UtcNow.Add(expiry ?? TimeSpan.FromMinutes(_options.SasTokenExpirationMinutes))
        };

        sasBuilder.SetPermissions(BlobSasPermissions.Create | BlobSasPermissions.Write);

        var sasUri = blobClient.GenerateSasUri(sasBuilder);

        var response = new UploadUrlResponse
        {
            UploadUrl = sasUri.ToString(),
            ExpiresAt = sasBuilder.ExpiresOn.UtcDateTime,
            Headers = new Dictionary<string, string>
            {
                ["x-ms-blob-type"] = "BlockBlob",
                ["Content-Type"] = contentType
            },
            StorageKey = storageKey
        };

        return response;
    }

    public async Task<bool> ValidateFileAsync(string contentType, long fileSize)
    {
        var allowedTypes = _options.AllowedContentTypes ?? new[] { "image/jpeg", "image/png", "video/mp4" };
        var maxSize = _options.MaxUploadSizeBytes;

        var isValidType = allowedTypes.Contains(contentType);
        var isValidSize = fileSize <= maxSize;

        return isValidType && isValidSize;
    }

    public async Task<string> GenerateStorageKeyAsync(string ownerId, string? context, string fileName)
    {
        var safeFileName = Path.GetFileNameWithoutExtension(fileName)
            .Replace(" ", "_")
            .ToLowerInvariant();
        var extension = Path.GetExtension(fileName).ToLowerInvariant();
        var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
        var random = Path.GetRandomFileName().Replace(".", "").Substring(0, 8);

        var key = $"{ownerId}/{context ?? "default"}/{timestamp}_{random}_{safeFileName}{extension}";
        return key;
    }

    public async Task<bool> FileExistsAsync(string storageKey)
    {
        var containerClient = _blobServiceClient.GetBlobContainerClient(_options.ContainerName);
        var blobClient = containerClient.GetBlobClient(storageKey);
        return await blobClient.ExistsAsync();
    }

    public async Task<string> GetFileUrlAsync(string storageKey)
    {
        if (!string.IsNullOrEmpty(_options.CdnBaseUrl))
        {
            return $"{_options.CdnBaseUrl}/{storageKey}";
        }

        var containerClient = _blobServiceClient.GetBlobContainerClient(_options.ContainerName);
        var blobClient = containerClient.GetBlobClient(storageKey);
        return blobClient.Uri.ToString();
    }

    public async Task UploadFileAsync(string storageKey, Stream fileStream, string contentType)
    {
        var containerClient = _blobServiceClient.GetBlobContainerClient(_options.ContainerName);
        await containerClient.CreateIfNotExistsAsync(PublicAccessType.None);

        var blobClient = containerClient.GetBlobClient(storageKey);

        var blobHttpHeaders = new BlobHttpHeaders { ContentType = contentType };
        await blobClient.UploadAsync(fileStream, new BlobUploadOptions { HttpHeaders = blobHttpHeaders });
    }

    public async Task<Stream> DownloadFileAsync(string storageKey)
    {
        var containerClient = _blobServiceClient.GetBlobContainerClient(_options.ContainerName);
        var blobClient = containerClient.GetBlobClient(storageKey);

        var response = await blobClient.DownloadAsync();
        return response.Value.Content;
    }

    public async Task DeleteFileAsync(string storageKey)
    {
        var containerClient = _blobServiceClient.GetBlobContainerClient(_options.ContainerName);
        var blobClient = containerClient.GetBlobClient(storageKey);

        await blobClient.DeleteIfExistsAsync();
    }

    public async Task CopyFileAsync(string sourceKey, string destinationKey)
    {
        var containerClient = _blobServiceClient.GetBlobContainerClient(_options.ContainerName);
        var sourceBlob = containerClient.GetBlobClient(sourceKey);
        var destBlob = containerClient.GetBlobClient(destinationKey);

        await destBlob.StartCopyFromUriAsync(sourceBlob.Uri);
    }

    public async Task<bool> IsHealthyAsync()
    {
        try
        {
            await _blobServiceClient.GetPropertiesAsync();
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Azure Blob Storage health check failed");
            return false;
        }
    }
}

---- File: MediaService.Infrastructure\Services\Storage\IMediaStorageService.cs ----

---- File: MediaService.Infrastructure\Services\Storage\LocalStorageOptions.cs ----
namespace MediaService.Infrastructure.Services.Storage;

public class LocalStorageOptions
{
    public string BasePath { get; set; } = "wwwroot/uploads";
    public string BaseUrl { get; set; } = "https://localhost:7000/uploads";
}

---- File: MediaService.Infrastructure\Services\Storage\LocalStorageService.cs ----
using MediaService.Domain.Interfaces.Services;
using Microsoft.Extensions.Logging;
using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace MediaService.Infrastructure.Services.Storage;

public class LocalStorageService : IMediaStorageService
{
    private readonly string _basePath;
    private readonly string _baseUrl;
    private readonly ILogger<LocalStorageService> _logger;

    public LocalStorageService(string basePath, string baseUrl, ILogger<LocalStorageService> logger)
    {
        _basePath = basePath ?? throw new ArgumentNullException(nameof(basePath));
        _baseUrl = baseUrl ?? throw new ArgumentNullException(nameof(baseUrl));
        _logger = logger;

        // Asegurarse de que el directorio base exista
        if (!Directory.Exists(_basePath))
        {
            Directory.CreateDirectory(_basePath);
        }
    }

    public async Task<UploadUrlResponse> GenerateUploadUrlAsync(string storageKey, string contentType, TimeSpan? expiry = null)
    {
        var uploadUrl = $"{_baseUrl.TrimEnd('/')}/{storageKey.TrimStart('/')}";
        var expiresAt = DateTime.UtcNow.Add(expiry ?? TimeSpan.FromHours(1));

        _logger.LogInformation("URL de subida generada: {Url}", uploadUrl);

        return new UploadUrlResponse
        {
            UploadUrl = uploadUrl,
            ExpiresAt = expiresAt,
            Headers = new Dictionary<string, string>
            {
                ["Content-Type"] = contentType
            },
            StorageKey = storageKey
        };
    }

    public async Task<bool> ValidateFileAsync(string contentType, long fileSize)
    {
        // Lógica de validación básica
        var allowedTypes = new[] { "image/jpeg", "image/png", "image/gif", "video/mp4", "application/pdf" };
        var maxSize = 100 * 1024 * 1024; // 100MB

        return allowedTypes.Contains(contentType) && fileSize <= maxSize;
    }

    public async Task<string> GenerateStorageKeyAsync(string ownerId, string? context, string fileName)
    {
        var safeFileName = Path.GetFileNameWithoutExtension(fileName)
            .Replace(" ", "_")
            .ToLowerInvariant();
        var extension = Path.GetExtension(fileName).ToLowerInvariant();
        var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
        var random = Path.GetRandomFileName().Replace(".", "").Substring(0, 8);

        var key = $"{ownerId}/{context ?? "default"}/{timestamp}_{random}_{safeFileName}{extension}";
        return key;
    }

    public async Task<bool> FileExistsAsync(string storageKey)
    {
        var fullPath = GetFullPath(storageKey);
        return File.Exists(fullPath);
    }

    public async Task<Stream> DownloadFileAsync(string storageKey)
    {
        var fullPath = GetFullPath(storageKey);

        if (!File.Exists(fullPath))
        {
            throw new FileNotFoundException($"Archivo no encontrado: {storageKey}");
        }

        return File.OpenRead(fullPath);
    }

    public async Task UploadFileAsync(string storageKey, Stream fileStream, string contentType)
    {
        var fullPath = GetFullPath(storageKey);
        var directory = Path.GetDirectoryName(fullPath);

        // Crear directorio si no existe
        if (!Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }

        // Subir archivo
        using (var file = File.Create(fullPath))
        {
            await fileStream.CopyToAsync(file);
        }

        _logger.LogInformation("Archivo subido exitosamente: {StorageKey}", storageKey);
    }

    public async Task DeleteFileAsync(string storageKey)
    {
        var fullPath = GetFullPath(storageKey);

        if (File.Exists(fullPath))
        {
            File.Delete(fullPath);
            _logger.LogInformation("Archivo eliminado: {StorageKey}", storageKey);
        }
    }

    public async Task<string> GetFileUrlAsync(string storageKey)
    {
        return $"{_baseUrl.TrimEnd('/')}/{storageKey.TrimStart('/')}";
    }

    public async Task CopyFileAsync(string sourceKey, string destinationKey)
    {
        var sourceFullPath = GetFullPath(sourceKey);
        var destFullPath = GetFullPath(destinationKey);
        var destDirectory = Path.GetDirectoryName(destFullPath);

        // Crear directorio de destino si no existe
        if (!Directory.Exists(destDirectory))
        {
            Directory.CreateDirectory(destDirectory);
        }

        File.Copy(sourceFullPath, destFullPath, overwrite: true);
        _logger.LogInformation("Archivo copiado de {Source} a {Destination}", sourceKey, destinationKey);
    }

    public async Task MoveFileAsync(string sourceKey, string destinationKey)
    {
        var sourceFullPath = GetFullPath(sourceKey);
        var destFullPath = GetFullPath(destinationKey);
        var destDirectory = Path.GetDirectoryName(destFullPath);

        // Crear directorio de destino si no existe
        if (!Directory.Exists(destDirectory))
        {
            Directory.CreateDirectory(destDirectory);
        }

        File.Move(sourceFullPath, destFullPath);
        _logger.LogInformation("Archivo movido de {Source} a {Destination}", sourceKey, destinationKey);
    }

    public async Task<bool> IsHealthyAsync()
    {
        try
        {
            // Verificar que el directorio base sea accesible
            if (!Directory.Exists(_basePath))
            {
                Directory.CreateDirectory(_basePath);
            }

            // Intentar crear y eliminar un archivo de prueba
            var testFilePath = Path.Combine(_basePath, $"healthcheck_{Guid.NewGuid()}.tmp");

            await File.WriteAllTextAsync(testFilePath, "healthcheck");
            File.Delete(testFilePath);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Health check falló para LocalStorageService");
            return false;
        }
    }

    public async Task<long> GetFileSizeAsync(string storageKey)
    {
        var fullPath = GetFullPath(storageKey);

        if (!File.Exists(fullPath))
        {
            throw new FileNotFoundException($"Archivo no encontrado: {storageKey}");
        }

        var fileInfo = new FileInfo(fullPath);
        return fileInfo.Length;
    }

    private string GetFullPath(string storageKey)
    {
        // Prevenir path traversal attacks
        var fullPath = Path.GetFullPath(Path.Combine(_basePath, storageKey));

        if (!fullPath.StartsWith(_basePath))
        {
            throw new UnauthorizedAccessException("Acceso no autorizado a la ruta del archivo");
        }

        return fullPath;
    }
}

---- File: MediaService.Infrastructure\Services\Storage\S3StorageOptions.cs ----
namespace MediaService.Infrastructure.Services.Storage;

public class S3StorageOptions
{
    public string AccessKey { get; set; } = string.Empty;
    public string SecretKey { get; set; } = string.Empty;
    public string Region { get; set; } = "us-east-1";
    public string BucketName { get; set; } = "media-service";
    public string CdnBaseUrl { get; set; } = string.Empty;
    public long MaxUploadSizeBytes { get; set; } = 104857600;
    public string[] AllowedContentTypes { get; set; } = Array.Empty<string>();
    public int PreSignedUrlExpirationMinutes { get; set; } = 60;
}

---- File: MediaService.Infrastructure\Services\Storage\S3StorageService.cs ----
using Amazon.S3;
using Amazon.S3.Model;
using Amazon.S3.Transfer;
using MediaService.Domain.Interfaces.Services;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace MediaService.Infrastructure.Services.Storage;

public class S3StorageService : IMediaStorageService
{
    private readonly IAmazonS3 _s3Client;
    private readonly S3StorageOptions _options;
    private readonly ILogger<S3StorageService> _logger;

    public S3StorageService(IOptions<S3StorageOptions> options, ILogger<S3StorageService> logger)
    {
        _options = options.Value;
        _logger = logger;
        _s3Client = new AmazonS3Client(_options.AccessKey, _options.SecretKey, _options.Region);
    }

    public async Task<UploadUrlResponse> GenerateUploadUrlAsync(string storageKey, string contentType, TimeSpan? expiry = null)
    {
        var expires = DateTime.UtcNow.Add(expiry ?? TimeSpan.FromMinutes(_options.PreSignedUrlExpirationMinutes));

        var request = new GetPreSignedUrlRequest
        {
            BucketName = _options.BucketName,
            Key = storageKey,
            Verb = HttpVerb.PUT,
            Expires = expires,
            ContentType = contentType
        };

        var uploadUrl = _s3Client.GetPreSignedURL(request);

        var response = new UploadUrlResponse
        {
            UploadUrl = uploadUrl,
            ExpiresAt = expires,
            Headers = new Dictionary<string, string>
            {
                ["Content-Type"] = contentType
            },
            StorageKey = storageKey
        };

        return response;
    }

    public async Task<bool> ValidateFileAsync(string contentType, long fileSize)
    {
        var allowedTypes = _options.AllowedContentTypes;
        var maxSize = _options.MaxUploadSizeBytes;

        var isValidType = allowedTypes.Contains(contentType);
        var isValidSize = fileSize <= maxSize;

        return isValidType && isValidSize;
    }

    public Task<string> GenerateStorageKeyAsync(string ownerId, string? context, string fileName)
    {
        var safeFileName = Path.GetFileNameWithoutExtension(fileName)
            .Replace(" ", "_")
            .ToLowerInvariant();
        var extension = Path.GetExtension(fileName).ToLowerInvariant();
        var timestamp = DateTime.UtcNow.ToString("yyyyMMdd_HHmmss");
        var random = Path.GetRandomFileName().Replace(".", "").Substring(0, 8);

        var key = $"{ownerId}/{context ?? "default"}/{timestamp}_{random}_{safeFileName}{extension}";
        return Task.FromResult(key);
    }

    public async Task<bool> FileExistsAsync(string storageKey)
    {
        try
        {
            var request = new GetObjectMetadataRequest
            {
                BucketName = _options.BucketName,
                Key = storageKey
            };

            await _s3Client.GetObjectMetadataAsync(request);
            return true;
        }
        catch (AmazonS3Exception ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
            return false;
        }
    }

    public async Task<string> GetFileUrlAsync(string storageKey)
    {
        if (!string.IsNullOrEmpty(_options.CdnBaseUrl))
        {
            return $"{_options.CdnBaseUrl}/{storageKey}";
        }

        var request = new GetPreSignedUrlRequest
        {
            BucketName = _options.BucketName,
            Key = storageKey,
            Expires = DateTime.UtcNow.AddHours(1)
        };

        return _s3Client.GetPreSignedURL(request);
    }

    public async Task UploadFileAsync(string storageKey, Stream fileStream, string contentType)
    {
        var transferUtility = new TransferUtility(_s3Client);

        var request = new TransferUtilityUploadRequest
        {
            BucketName = _options.BucketName,
            Key = storageKey,
            InputStream = fileStream,
            ContentType = contentType,
            AutoCloseStream = false
        };

        await transferUtility.UploadAsync(request);
    }

    public async Task<Stream> DownloadFileAsync(string storageKey)
    {
        var request = new GetObjectRequest
        {
            BucketName = _options.BucketName,
            Key = storageKey
        };

        var response = await _s3Client.GetObjectAsync(request);
        return response.ResponseStream;
    }

    public async Task DeleteFileAsync(string storageKey)
    {
        var request = new DeleteObjectRequest
        {
            BucketName = _options.BucketName,
            Key = storageKey
        };

        await _s3Client.DeleteObjectAsync(request);
    }

    public async Task CopyFileAsync(string sourceKey, string destinationKey)
    {
        var request = new CopyObjectRequest
        {
            SourceBucket = _options.BucketName,
            SourceKey = sourceKey,
            DestinationBucket = _options.BucketName,
            DestinationKey = destinationKey
        };

        await _s3Client.CopyObjectAsync(request);
    }

    public async Task<bool> IsHealthyAsync()
    {
        try
        {
            await _s3Client.ListBucketsAsync();
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "S3 storage health check failed");
            return false;
        }
    }
}

---- File: MediaService.Shared\ApiResponse.cs ----
using System.Text.Json;

namespace MediaService.Shared;

/// <summary>
/// Generic wrapper for API responses
/// </summary>
/// <typeparam name="T">Type of the data payload</typeparam>
public class ApiResponse<T>
{
    /// <summary>Indicates if the operation was successful</summary>
    public bool Success { get; set; }

    /// <summary>Data returned when Success is true</summary>
    public T? Data { get; set; }

    /// <summary>Error message when Success is false</summary>
    public string? Error { get; set; }

    /// <summary>Additional metadata about the response</summary>
    public Dictionary<string, object>? Metadata { get; set; }

    /// <summary>Timestamp when the response was generated</summary>
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    /// <summary>Creates a successful response with the provided data</summary>
    public static ApiResponse<T> Ok(T data, Dictionary<string, object>? metadata = null)
    {
        return new ApiResponse<T>
        {
            Success = true,
            Data = data,
            Metadata = metadata,
            Timestamp = DateTime.UtcNow
        };
    }

    /// <summary>Creates a failed response with the provided error message</summary>
    public static ApiResponse<T> Fail(string errorMessage, Dictionary<string, object>? metadata = null)
    {
        return new ApiResponse<T>
        {
            Success = false,
            Error = errorMessage,
            Metadata = metadata,
            Timestamp = DateTime.UtcNow
        };
    }

    /// <summary>Creates a failed response with validation errors</summary>
    public static ApiResponse<T> ValidationFail(Dictionary<string, string[]> errors)
    {
        return new ApiResponse<T>
        {
            Success = false,
            Error = "Validation failed",
            Metadata = new Dictionary<string, object> { ["validationErrors"] = errors },
            Timestamp = DateTime.UtcNow
        };
    }
}

/// <summary>
/// Non-generic API response for void operations
/// </summary>
public class ApiResponse
{
    /// <summary>Indicates if the operation was successful</summary>
    public bool Success { get; set; }

    /// <summary>Error message when Success is false</summary>
    public string? Error { get; set; }

    /// <summary>Additional metadata about the response</summary>
    public Dictionary<string, object>? Metadata { get; set; }

    /// <summary>Timestamp when the response was generated</summary>
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    /// <summary>Creates a successful response</summary>
    public static ApiResponse Ok(Dictionary<string, object>? metadata = null)
    {
        return new ApiResponse
        {
            Success = true,
            Metadata = metadata,
            Timestamp = DateTime.UtcNow
        };
    }

    /// <summary>Creates a failed response with the provided error message</summary>
    public static ApiResponse Fail(string errorMessage, Dictionary<string, object>? metadata = null)
    {
        return new ApiResponse
        {
            Success = false,
            Error = errorMessage,
            Metadata = metadata,
            Timestamp = DateTime.UtcNow
        };
    }
}

/// <summary>
/// Paginated result wrapper
/// </summary>
/// <typeparam name="T">Type of the items</typeparam>
public class PaginatedResult<T>
{
    public List<T> Items { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    public bool HasPreviousPage => Page > 1;
    public bool HasNextPage => Page < TotalPages;
    public string? SortBy { get; set; }
    public bool SortDescending { get; set; } = true;

    public PaginatedResult() { }

    public PaginatedResult(List<T> items, int totalCount, int page, int pageSize)
    {
        Items = items;
        TotalCount = totalCount;
        Page = page;
        PageSize = pageSize;
    }

    public static PaginatedResult<T> Create(List<T> items, int totalCount, int page, int pageSize)
    {
        return new PaginatedResult<T>(items, totalCount, page, pageSize);
    }

    public static PaginatedResult<T> Empty(int page = 1, int pageSize = 50)
    {
        return new PaginatedResult<T>(new List<T>(), 0, page, pageSize);
    }
}

/// <summary>
/// Extension methods for ApiResponse to handle paginated results
/// </summary>
public static class ApiResponseExtensions
{
    /// <summary>
    /// Creates a successful response with paginated data
    /// </summary>
    public static ApiResponse<PaginatedResult<T>> OkPaginated<T>(
        PaginatedResult<T> result,
        Dictionary<string, object>? metadata = null,
        string? correlationId = null)
    {
        var response = new ApiResponse<PaginatedResult<T>>
        {
            Success = true,
            Data = result,
            Metadata = metadata ?? new Dictionary<string, object>(),
            Timestamp = DateTime.UtcNow
        };

        if (!string.IsNullOrEmpty(correlationId))
        {
            response.Metadata["correlationId"] = correlationId;
        }

        // Add pagination metadata
        response.Metadata["pagination"] = new Dictionary<string, object>
        {
            ["currentPage"] = result.Page,
            ["pageSize"] = result.PageSize,
            ["totalCount"] = result.TotalCount,
            ["totalPages"] = result.TotalPages,
            ["hasPreviousPage"] = result.HasPreviousPage,
            ["hasNextPage"] = result.HasNextPage
        };

        return response;
    }

    /// <summary>
    /// Creates a successful response with paginated data (alternative method)
    /// </summary>
    public static ApiResponse<PaginatedResult<T>> Ok<T>(
        PaginatedResult<T> result,
        Dictionary<string, object>? metadata = null)
    {
        return OkPaginated(result, metadata);
    }
}

---- File: MediaService.Shared\Constants.cs ----
namespace MediaService.Shared;

/// <summary>
/// Application constants
/// </summary>
public static class Constants
{
    /// <summary>
    /// Cache key patterns
    /// </summary>
    public static class CacheKeys
    {
        public const string MediaById = "media_{0}";
        public const string UserMediaList = "user_media_{0}";
        public const string UploadUrl = "upload_url_{0}";
        public const string RecentMedia = "recent_media";
        public const string MediaStatistics = "media_statistics";
        public const string ProcessingQueue = "processing_queue";
        public const string DailyStats = "daily_stats_{0}";
    }

    /// <summary>
    /// Policy names for authorization
    /// </summary>
    public static class Policies
    {
        public const string RequireAdminRole = "RequireAdminRole";
        public const string RequireUploadPermission = "RequireUploadPermission";
        public const string RequireViewMedia = "RequireViewMedia";
        public const string RequireDeleteMedia = "RequireDeleteMedia";
        public const string AllowAnonymous = "AllowAnonymous";
    }

    /// <summary>
    /// Role names
    /// </summary>
    public static class Roles
    {
        public const string Administrator = "Administrator";
        public const string ContentManager = "ContentManager";
        public const string User = "User";
        public const string System = "System";
    }

    /// <summary>
    /// Claim types
    /// </summary>
    public static class ClaimTypes
    {
        public const string UserId = "sub";
        public const string Email = "email";
        public const string Name = "name";
        public const string Role = "role";
        public const string Permissions = "permissions";
    }

    /// <summary>
    /// HTTP header names
    /// </summary>
    public static class Headers
    {
        public const string ApiKey = "X-API-Key";
        public const string CorrelationId = "X-Correlation-ID";
        public const string UserAgent = "User-Agent";
        public const string ForwardedFor = "X-Forwarded-For";
        public const string RequestId = "X-Request-ID";
        public const string UploadToken = "X-Upload-Token";
    }

    /// <summary>
    /// Media action types
    /// </summary>
    public static class MediaActions
    {
        // Upload actions
        public const string Upload = "UPLOAD";
        public const string InitUpload = "INIT_UPLOAD";
        public const string FinalizeUpload = "FINALIZE_UPLOAD";
        public const string CancelUpload = "CANCEL_UPLOAD";

        // Management actions
        public const string View = "VIEW";
        public const string Download = "DOWNLOAD";
        public const string Delete = "DELETE";
        public const string Update = "UPDATE";
        public const string List = "LIST";

        // Processing actions
        public const string Process = "PROCESS";
        public const string Reprocess = "REPROCESS";
        public const string GenerateVariants = "GENERATE_VARIANTS";

        // Sharing actions
        public const string Share = "SHARE";
        public const string Unshare = "UNSHARE";
        public const string GenerateShareLink = "GENERATE_SHARE_LINK";
    }

    /// <summary>
    /// Media resource types
    /// </summary>
    public static class MediaResources
    {
        public const string Image = "IMAGE";
        public const string Video = "VIDEO";
        public const string Document = "DOCUMENT";
        public const string Audio = "AUDIO";
        public const string Thumbnail = "THUMBNAIL";
        public const string Variant = "VARIANT";
    }

    /// <summary>
    /// Error codes
    /// </summary>
    public static class ErrorCodes
    {
        public const string ValidationError = "VALIDATION_ERROR";
        public const string NotFound = "NOT_FOUND";
        public const string Unauthorized = "UNAUTHORIZED";
        public const string Forbidden = "FORBIDDEN";
        public const string Conflict = "CONFLICT";
        public const string InternalError = "INTERNAL_ERROR";
        public const string ServiceUnavailable = "SERVICE_UNAVAILABLE";
        public const string RateLimitExceeded = "RATE_LIMIT_EXCEEDED";
        public const string FileTooLarge = "FILE_TOO_LARGE";
        public const string UnsupportedFormat = "UNSUPPORTED_FORMAT";
        public const string ProcessingFailed = "PROCESSING_FAILED";
        public const string StorageError = "STORAGE_ERROR";
    }

    /// <summary>
    /// Date and time formats
    /// </summary>
    public static class DateFormats
    {
        public const string Default = "yyyy-MM-ddTHH:mm:ss.fffZ";
        public const string DateOnly = "yyyy-MM-dd";
        public const string HumanReadable = "MMMM dd, yyyy 'at' hh:mm tt";
        public const string FileSafe = "yyyyMMdd_HHmmss";
    }

    /// <summary>
    /// Pagination defaults
    /// </summary>
    public static class Pagination
    {
        public const int DefaultPage = 1;
        public const int DefaultPageSize = 50;
        public const int MaxPageSize = 1000;
    }

    /// <summary>
    /// File size limits
    /// </summary>
    public static class FileSizes
    {
        public const long OneKB = 1024;
        public const long OneMB = 1024 * OneKB;
        public const long TenMB = 10 * OneMB;
        public const long HundredMB = 100 * OneMB;
        public const long OneGB = 1024 * OneMB;
    }

    /// <summary>
    /// Configuration section names
    /// </summary>
    public static class ConfigurationSections
    {
        public const string Database = "DatabaseSettings";
        public const string Cache = "CacheSettings";
        public const string Storage = "StorageSettings";
        public const string ImageProcessing = "ImageProcessingSettings";
        public const string VideoTranscode = "VideoTranscodeSettings";
        public const string HealthChecks = "HealthChecks";
        public const string RabbitMQ = "RabbitMQ";
        public const string MediaService = "MediaService";
        public const string Serilog = "Serilog";
    }
}

---- File: MediaService.Shared\MediaService.Shared.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
    <PackageReference Include="System.Text.Json" Version="8.0.5" />
  </ItemGroup>

</Project>

---- File: MediaService.Shared\ValidationPatterns.cs ----
using System.Text.RegularExpressions;

namespace MediaService.Shared;

/// <summary>
/// Regular expression patterns for validation
/// </summary>
public static class ValidationPatterns
{
    /// <summary>
    /// Pattern for email validation
    /// </summary>
    public const string Email = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";

    /// <summary>
    /// Pattern for GUID validation
    /// </summary>
    public const string Guid = @"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";

    /// <summary>
    /// Pattern for IP address validation (IPv4 and IPv6)
    /// </summary>
    public const string IpAddress = @"^([0-9]{1,3}\.){3}[0-9]{1,3}$|^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$";

    /// <summary>
    /// Pattern for user agent validation (basic pattern)
    /// </summary>
    public const string UserAgent = @"^.{1,500}$";

    /// <summary>
    /// Pattern for media ID validation (alphanumeric and underscores)
    /// </summary>
    public const string MediaId = @"^[a-zA-Z0-9_]{1,50}$";

    /// <summary>
    /// Pattern for file name validation
    /// </summary>
    public const string FileName = @"^[a-zA-Z0-9_\-. ]{1,255}$";

    /// <summary>
    /// Pattern for content type validation
    /// </summary>
    public const string ContentType = @"^[a-zA-Z0-9_\-+/.]{1,100}$";

    /// <summary>
    /// Pattern for context validation (alphanumeric, underscores, and hyphens)
    /// </summary>
    public const string Context = @"^[a-zA-Z0-9_\-]{1,50}$";

    /// <summary>
    /// Pattern for correlation ID validation (alphanumeric and hyphens)
    /// </summary>
    public const string CorrelationId = @"^[a-zA-Z0-9-]{1,100}$";

    /// <summary>
    /// Pattern for service name validation (alphanumeric and hyphens)
    /// </summary>
    public const string ServiceName = @"^[a-zA-Z0-9-]{1,50}$";

    /// <summary>
    /// Pattern for sorting parameter validation (alphanumeric and underscores)
    /// </summary>
    public const string SortBy = @"^[a-zA-Z0-9_]{1,50}$";

    /// <summary>
    /// Pattern for storage key validation
    /// </summary>
    public const string StorageKey = @"^[a-zA-Z0-9_\-/.]{1,1024}$";

    /// <summary>
    /// Validates an email address
    /// </summary>
    public static bool IsValidEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return false;

        return Regex.IsMatch(email, Email, RegexOptions.IgnoreCase);
    }

    /// <summary>
    /// Validates a GUID string
    /// </summary>
    public static bool IsValidGuid(string guid)
    {
        if (string.IsNullOrWhiteSpace(guid))
            return false;

        return Regex.IsMatch(guid, Guid, RegexOptions.IgnoreCase);
    }

    /// <summary>
    /// Validates an IP address
    /// </summary>
    public static bool IsValidIpAddress(string ipAddress)
    {
        if (string.IsNullOrWhiteSpace(ipAddress))
            return false;

        return Regex.IsMatch(ipAddress, IpAddress);
    }

    /// <summary>
    /// Validates a user agent string
    /// </summary>
    public static bool IsValidUserAgent(string userAgent)
    {
        if (string.IsNullOrWhiteSpace(userAgent))
            return false;

        return Regex.IsMatch(userAgent, UserAgent);
    }

    /// <summary>
    /// Validates a media ID
    /// </summary>
    public static bool IsValidMediaId(string mediaId)
    {
        if (string.IsNullOrWhiteSpace(mediaId))
            return false;

        return Regex.IsMatch(mediaId, MediaId);
    }

    /// <summary>
    /// Validates a file name
    /// </summary>
    public static bool IsValidFileName(string fileName)
    {
        if (string.IsNullOrWhiteSpace(fileName))
            return false;

        return Regex.IsMatch(fileName, FileName);
    }

    /// <summary>
    /// Validates a content type
    /// </summary>
    public static bool IsValidContentType(string contentType)
    {
        if (string.IsNullOrWhiteSpace(contentType))
            return false;

        return Regex.IsMatch(contentType, ContentType);
    }

    /// <summary>
    /// Validates a context
    /// </summary>
    public static bool IsValidContext(string context)
    {
        if (string.IsNullOrWhiteSpace(context))
            return false;

        return Regex.IsMatch(context, Context);
    }

    /// <summary>
    /// Validates a correlation ID
    /// </summary>
    public static bool IsValidCorrelationId(string correlationId)
    {
        if (string.IsNullOrWhiteSpace(correlationId))
            return false;

        return Regex.IsMatch(correlationId, CorrelationId);
    }

    /// <summary>
    /// Validates a service name
    /// </summary>
    public static bool IsValidServiceName(string serviceName)
    {
        if (string.IsNullOrWhiteSpace(serviceName))
            return false;

        return Regex.IsMatch(serviceName, ServiceName);
    }

    /// <summary>
    /// Validates a sort by parameter
    /// </summary>
    public static bool IsValidSortBy(string? sortBy)
    {
        if (string.IsNullOrWhiteSpace(sortBy))
            return false;

        return Regex.IsMatch(sortBy, SortBy);
    }

    /// <summary>
    /// Validates a storage key
    /// </summary>
    public static bool IsValidStorageKey(string storageKey)
    {
        if (string.IsNullOrWhiteSpace(storageKey))
            return false;

        return Regex.IsMatch(storageKey, StorageKey);
    }

    /// <summary>
    /// Sanitizes a string for safe logging (removes sensitive data)
    /// </summary>
    public static string SanitizeForLogging(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty;

        // Remove potential sensitive data patterns
        var patterns = new Dictionary<string, string>
        {
            { @"password[^=]*=([^&]*)", "password=***" },
            { @"token[^=]*=([^&]*)", "token=***" },
            { @"authorization[^:]*:\s*([^,\s]*)", "authorization: ***" },
            { @"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b", "***@***.***" },
            { @"\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b", "****-****-****-****" } // Credit card
        };

        var sanitized = input;
        foreach (var pattern in patterns)
        {
            sanitized = Regex.Replace(sanitized, pattern.Key, pattern.Value, RegexOptions.IgnoreCase);
        }

        return sanitized;
    }

    /// <summary>
    /// Validates a page number
    /// </summary>
    public static bool IsValidPage(int page)
    {
        return page >= 1;
    }

    /// <summary>
    /// Validates a page size
    /// </summary>
    public static bool IsValidPageSize(int pageSize)
    {
        return pageSize >= 1 && pageSize <= Constants.Pagination.MaxPageSize;
    }

    /// <summary>
    /// Validates a date range
    /// </summary>
    public static bool IsValidDateRange(DateTime fromDate, DateTime toDate)
    {
        return fromDate <= toDate && toDate <= DateTime.UtcNow;
    }

    /// <summary>
    /// Validates file size against maximum allowed
    /// </summary>
    public static bool IsValidFileSize(long fileSize, long maxSize = Constants.FileSizes.HundredMB)
    {
        return fileSize > 0 && fileSize <= maxSize;
    }

    /// <summary>
    /// Validates if content type is allowed
    /// </summary>
    public static bool IsAllowedContentType(string contentType, string[] allowedTypes)
    {
        if (string.IsNullOrWhiteSpace(contentType))
            return false;

        return allowedTypes.Any(pattern =>
            pattern.EndsWith("/*") ? contentType.StartsWith(pattern[..^1]) : contentType == pattern);
    }
}

---- File: MediaService.Shared\Enums\MediaStatus.cs ----
/// <summary>
/// Status of media processing
/// </summary>
public enum MediaStatus
{
    /// <summary>
    /// Media has been uploaded but not processed
    /// </summary>
    Uploaded = 1,

    /// <summary>
    /// Media is currently being processed
    /// </summary>
    Processing = 2,

    /// <summary>
    /// Media has been successfully processed
    /// </summary>
    Processed = 3,

    /// <summary>
    /// Media processing failed
    /// </summary>
    Failed = 4
}

---- File: MediaService.Shared\Enums\MediaType.cs ----
namespace MediaService.Shared.Enums;

/// <summary>
/// Types of media supported by the service
/// </summary>
public enum MediaType
{
    /// <summary>
    /// Image files (JPEG, PNG, GIF, WebP, etc.)
    /// </summary>
    Image = 1,

    /// <summary>
    /// Video files (MP4, AVI, MOV, etc.)
    /// </summary>
    Video = 2,

    /// <summary>
    /// Document files (PDF, DOC, DOCX, etc.)
    /// </summary>
    Document = 3,

    /// <summary>
    /// Audio files (MP3, WAV, AAC, etc.)
    /// </summary>
    Audio = 4
}

/// <summary>
/// Status of media processing
/// </summary>
public enum MediaStatus
{
    /// <summary>
    /// Media has been uploaded but not processed
    /// </summary>
    Uploaded = 1,

    /// <summary>
    /// Media is currently being processed
    /// </summary>
    Processing = 2,

    /// <summary>
    /// Media has been successfully processed
    /// </summary>
    Processed = 3,

    /// <summary>
    /// Media processing failed
    /// </summary>
    Failed = 4
}

/// <summary>
/// Status of media processing operations
/// </summary>
public enum ProcessingStatus
{
    /// <summary>
    /// Processing has been queued
    /// </summary>
    Queued = 1,

    /// <summary>
    /// Processing is in progress
    /// </summary>
    InProgress = 2,

    /// <summary>
    /// Processing completed successfully
    /// </summary>
    Completed = 3,

    /// <summary>
    /// Processing failed
    /// </summary>
    Failed = 4,

    /// <summary>
    /// Processing was cancelled
    /// </summary>
    Cancelled = 5
}

---- File: MediaService.Shared\Enums\ProcessingStatus.cs ----

/// <summary>
/// Status of media processing operations
/// </summary>
public enum ProcessingStatus
{
    /// <summary>
    /// Processing has been queued
    /// </summary>
    Queued = 1,

    /// <summary>
    /// Processing is in progress
    /// </summary>
    InProgress = 2,

    /// <summary>
    /// Processing completed successfully
    /// </summary>
    Completed = 3,

    /// <summary>
    /// Processing failed
    /// </summary>
    Failed = 4,

    /// <summary>
    /// Processing was cancelled
    /// </summary>
    Cancelled = 5
}

---- File: MediaService.Shared\MediaMessages\IMediaEventProducer.cs ----

---- File: MediaService.Shared\MediaMessages\MediaProcessedMessage.cs ----

---- File: MediaService.Shared\MediaMessages\MediaUploadedMessage.cs ----

---- File: MediaService.Shared\Settings\CacheSettings.cs ----
namespace MediaService.Shared.Settings;

/// <summary>
/// Configuration settings for caching
/// </summary>
public class CacheSettings
{
    /// <summary>
    /// Redis connection string
    /// </summary>
    public string RedisConnectionString { get; set; } = "localhost:6379";

    /// <summary>
    /// Default cache expiration time in minutes
    /// </summary>
    public int DefaultExpirationMinutes { get; set; } = 30;

    /// <summary>
    /// Media metadata cache expiration in minutes
    /// </summary>
    public int MediaCacheExpirationMinutes { get; set; } = 60;

    /// <summary>
    /// Upload URLs cache expiration in minutes
    /// </summary>
    public int UploadUrlCacheExpirationMinutes { get; set; } = 5;

    /// <summary>
    /// Whether to enable distributed caching
    /// </summary>
    public bool EnableDistributedCache { get; set; } = true;

    /// <summary>
    /// Whether to enable in-memory caching as fallback
    /// </summary>
    public bool EnableMemoryCache { get; set; } = true;

    /// <summary>
    /// Maximum memory cache size in megabytes
    /// </summary>
    public int MaxMemoryCacheSizeMB { get; set; } = 100;

    /// <summary>
    /// Cache key prefix for media service
    /// </summary>
    public string CacheKeyPrefix { get; set; } = "mediaservice_";

    /// <summary>
    /// Cache key for media by ID
    /// </summary>
    public string MediaByIdKey { get; set; } = "media_{0}";

    /// <summary>
    /// Cache key for user media list
    /// </summary>
    public string UserMediaListKey { get; set; } = "user_media_{0}";

    /// <summary>
    /// Cache key for upload URLs
    /// </summary>
    public string UploadUrlKey { get; set; } = "upload_url_{0}";
}

---- File: MediaService.Shared\Settings\DatabaseSettings.cs ----
namespace MediaService.Shared.Settings;

/// <summary>
/// Configuration settings for database connectivity
/// </summary>
public class DatabaseSettings
{
    /// <summary>
    /// Database connection string
    /// </summary>
    public string ConnectionString { get; set; } = "Host=localhost;Database=mediaservice;Username=postgres;Password=password";

    /// <summary>
    /// Database provider (PostgreSQL, SQLServer, SQLite, etc.)
    /// </summary>
    public string Provider { get; set; } = "PostgreSQL";

    /// <summary>
    /// Whether to enable sensitive data logging (should be false in production)
    /// </summary>
    public bool EnableSensitiveDataLogging { get; set; } = false;

    /// <summary>
    /// Whether to enable detailed errors
    /// </summary>
    public bool EnableDetailedErrors { get; set; } = false;

    /// <summary>
    /// Command timeout in seconds
    /// </summary>
    public int CommandTimeout { get; set; } = 30;

    /// <summary>
    /// Maximum number of retry attempts for database operations
    /// </summary>
    public int MaxRetryCount { get; set; } = 3;

    /// <summary>
    /// Whether to enable query tracking
    /// </summary>
    public bool EnableQueryTracking { get; set; } = false;

    /// <summary>
    /// Maximum number of records to return in a single query
    /// </summary>
    public int MaxPageSize { get; set; } = 1000;

    /// <summary>
    /// Default page size for paginated queries
    /// </summary>
    public int DefaultPageSize { get; set; } = 50;

    /// <summary>
    /// Database schema to use
    /// </summary>
    public string Schema { get; set; } = "public";

    /// <summary>
    /// Whether to automatically apply migrations on startup
    /// </summary>
    public bool AutoMigrate { get; set; } = true;

    /// <summary>
    /// Whether to enable database health checks
    /// </summary>
    public bool EnableHealthChecks { get; set; } = true;
}

---- File: MediaService.Shared\Settings\ImageProcessingSettings.cs ----
namespace MediaService.Shared.Settings;

/// <summary>
/// Configuration settings for image processing
/// </summary>
public class ImageProcessingSettings
{
    /// <summary>
    /// Whether to enable automatic image processing
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// Maximum width for processed images
    /// </summary>
    public int MaxWidth { get; set; } = 3840;

    /// <summary>
    /// Maximum height for processed images
    /// </summary>
    public int MaxHeight { get; set; } = 2160;

    /// <summary>
    /// Default JPEG quality (1-100)
    /// </summary>
    public int DefaultQuality { get; set; } = 85;

    /// <summary>
    /// Whether to preserve EXIF metadata
    /// </summary>
    public bool PreserveMetadata { get; set; } = false;

    /// <summary>
    /// Whether to generate image variants
    /// </summary>
    public bool GenerateVariants { get; set; } = true;

    /// <summary>
    /// Image variants to generate
    /// </summary>
    public List<ImageVariant> Variants { get; set; } = new()
    {
        new ImageVariant { Name = "thumb", MaxWidth = 200, MaxHeight = 200, Quality = 80 },
        new ImageVariant { Name = "small", MaxWidth = 400, MaxHeight = 400, Quality = 80 },
        new ImageVariant { Name = "medium", MaxWidth = 800, MaxHeight = 800, Quality = 85 },
        new ImageVariant { Name = "large", MaxWidth = 1200, MaxHeight = 1200, Quality = 90 }
    };

    /// <summary>
    /// Supported input formats
    /// </summary>
    public string[] SupportedFormats { get; set; } = new[]
    {
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/bmp"
    };

    /// <summary>
    /// Output format (null preserves original format)
    /// </summary>
    public string? OutputFormat { get; set; } = null;

    /// <summary>
    /// Whether to enable image optimization
    /// </summary>
    public bool EnableOptimization { get; set; } = true;

    /// <summary>
    /// Maximum processing time in seconds
    /// </summary>
    public int MaxProcessingTimeSeconds { get; set; } = 30;
}

/// <summary>
/// Image variant configuration
/// </summary>
public class ImageVariant
{
    /// <summary>
    /// Variant name (thumb, small, medium, large, etc.)
    /// </summary>
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Maximum width for this variant
    /// </summary>
    public int MaxWidth { get; set; }

    /// <summary>
    /// Maximum height for this variant
    /// </summary>
    public int MaxHeight { get; set; }

    /// <summary>
    /// JPEG quality for this variant (1-100)
    /// </summary>
    public int Quality { get; set; } = 85;

    /// <summary>
    /// Whether to maintain aspect ratio
    /// </summary>
    public bool MaintainAspectRatio { get; set; } = true;

    /// <summary>
    /// Resize mode (Crop, Max, Pad, etc.)
    /// </summary>
    public string ResizeMode { get; set; } = "Max";
}

---- File: MediaService.Shared\Settings\StorageSettings.cs ----
namespace MediaService.Shared.Settings;

/// <summary>
/// Configuration settings for storage providers
/// </summary>
public class StorageSettings
{
    /// <summary>
    /// Storage provider (Azure, AWS, Local, etc.)
    /// </summary>
    public string Provider { get; set; } = "Azure";

    /// <summary>
    /// Storage connection string
    /// </summary>
    public string ConnectionString { get; set; } = string.Empty;

    /// <summary>
    /// Container/bucket name for media assets
    /// </summary>
    public string ContainerName { get; set; } = "media-assets";

    /// <summary>
    /// Base URL for CDN distribution
    /// </summary>
    public string CdnBaseUrl { get; set; } = string.Empty;

    /// <summary>
    /// Maximum upload size in bytes
    /// </summary>
    public long MaxUploadSizeBytes { get; set; } = 104857600; // 100MB

    /// <summary>
    /// Allowed content types for upload
    /// </summary>
    public string[] AllowedContentTypes { get; set; } = new[]
    {
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "video/mp4",
        "video/avi",
        "video/mov",
        "application/pdf"
    };

    /// <summary>
    /// SAS token expiration time in minutes
    /// </summary>
    public int SasTokenExpirationMinutes { get; set; } = 60;

    /// <summary>
    /// Whether to enable versioning
    /// </summary>
    public bool EnableVersioning { get; set; } = false;

    /// <summary>
    /// Whether to enable soft delete
    /// </summary>
    public bool EnableSoftDelete { get; set; } = true;

    /// <summary>
    /// Retention period for deleted files in days
    /// </summary>
    public int RetentionDays { get; set; } = 30;
}

---- File: MediaService.Shared\Settings\VideoTranscodeSettings.cs ----
namespace MediaService.Shared.Settings;

/// <summary>
/// Configuration settings for video transcoding
/// </summary>
public class VideoTranscodeSettings
{
    /// <summary>
    /// Whether to enable video transcoding
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// Whether to generate HLS streams
    /// </summary>
    public bool GenerateHls { get; set; } = true;

    /// <summary>
    /// HLS segment duration in seconds
    /// </summary>
    public int HlsSegmentSeconds { get; set; } = 4;

    /// <summary>
    /// Bitrate ladder for multiple quality streams
    /// </summary>
    public List<VideoBitrateProfile> BitrateLadder { get; set; } = new()
    {
        new VideoBitrateProfile { Height = 360, VideoBitrate = "800k", AudioBitrate = "96k" },
        new VideoBitrateProfile { Height = 720, VideoBitrate = "2500k", AudioBitrate = "128k" },
        new VideoBitrateProfile { Height = 1080, VideoBitrate = "5000k", AudioBitrate = "192k" }
    };

    /// <summary>
    /// Supported input formats
    /// </summary>
    public string[] SupportedFormats { get; set; } = new[]
    {
        "video/mp4",
        "video/avi",
        "video/mov",
        "video/mkv",
        "video/webm"
    };

    /// <summary>
    /// Output format
    /// </summary>
    public string OutputFormat { get; set; } = "h264";

    /// <summary>
    /// Maximum processing time in minutes
    /// </summary>
    public int MaxProcessingTimeMinutes { get; set; } = 60;

    /// <summary>
    /// Whether to generate thumbnails
    /// </summary>
    public bool GenerateThumbnails { get; set; } = true;

    /// <summary>
    /// Thumbnail interval in seconds
    /// </summary>
    public int ThumbnailIntervalSeconds { get; set; } = 10;

    /// <summary>
    /// Number of thumbnails to generate
    /// </summary>
    public int ThumbnailCount { get; set; } = 10;

    /// <summary>
    /// Whether to extract audio tracks
    /// </summary>
    public bool ExtractAudio { get; set; } = true;

    /// <summary>
    /// Audio output format
    /// </summary>
    public string AudioFormat { get; set; } = "aac";
}

/// <summary>
/// Video bitrate profile for multiple quality streams
/// </summary>
public class VideoBitrateProfile
{
    /// <summary>
    /// Video height for this profile
    /// </summary>
    public int Height { get; set; }

    /// <summary>
    /// Video bitrate (e.g., "800k", "1.5M")
    /// </summary>
    public string VideoBitrate { get; set; } = string.Empty;

    /// <summary>
    /// Audio bitrate (e.g., "96k", "128k")
    /// </summary>
    public string AudioBitrate { get; set; } = string.Empty;

    /// <summary>
    /// Video codec
    /// </summary>
    public string VideoCodec { get; set; } = "libx264";

    /// <summary>
    /// Audio codec
    /// </summary>
    public string AudioCodec { get; set; } = "aac";

    /// <summary>
    /// Profile name (baseline, main, high)
    /// </summary>
    public string Profile { get; set; } = "main";

    /// <summary>
    /// Level for H.264 encoding
    /// </summary>
    public string Level { get; set; } = "3.1";
}

---- File: MediaService.Workers\appsettings.Development.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}

---- File: MediaService.Workers\appsettings.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
}

---- File: MediaService.Workers\MediaService.Workers.csproj ----
<Project Sdk="Microsoft.NET.Sdk.Worker">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UserSecretsId>dotnet-MediaService.Workers-2d0cf4cd-88ec-44a3-b2be-3730866caac0</UserSecretsId>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="9.0.10" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.10">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="9.0.10" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Json" Version="9.0.10" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="9.0.10" />
    <PackageReference Include="Microsoft.Extensions.Hosting" Version="9.0.10" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="9.0.10" />
    <PackageReference Include="RabbitMQ.Client" Version="7.1.2" />
    <PackageReference Include="Serilog" Version="4.3.0" />
    <PackageReference Include="Serilog.Extensions.Hosting" Version="9.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="6.0.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="7.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MediaService.Application\MediaService.Application.csproj" />
    <ProjectReference Include="..\MediaService.Domain\MediaService.Domain.csproj" />
    <ProjectReference Include="..\MediaService.Infrastructure\MediaService.Infrastructure.csproj" />
  </ItemGroup>
</Project>

---- File: MediaService.Workers\Program.cs ----
using MediaService.Workers;

var builder = Host.CreateApplicationBuilder(args);
builder.Services.AddHostedService<Worker>();

var host = builder.Build();
host.Run();

---- File: MediaService.Workers\Worker.cs ----
namespace MediaService.Workers;

public class Worker : BackgroundService
{
    private readonly ILogger<Worker> _logger;

    public Worker(ILogger<Worker> logger)
    {
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            if (_logger.IsEnabled(LogLevel.Information))
            {
                _logger.LogInformation("Worker running at: {time}", DateTimeOffset.Now);
            }
            await Task.Delay(1000, stoppingToken);
        }
    }
}

---- File: MediaService.Workers\Handlers\ImageProcessingHandler.cs ----

---- File: MediaService.Workers\Handlers\MediaCleanupHandler.cs ----

---- File: MediaService.Workers\Handlers\VideoTranscodingHandler.cs ----

---- File: MediaService.Workers\Services\DocumentProcessingWorker.cs ----

---- File: MediaService.Workers\Services\ImageProcessingWorker.cs ----

---- File: MediaService.Workers\Services\VideoTranscodingWorker.cs ----

