## Code Bundle - Aggregated Files
## Microservicio: backend\AuditService
## Generado: 10/31/2025 09:30:16
## Carpetas excluidas: bin, obj, Properties

---- File: AuditService.sln ----

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuditService.Api", "AuditService.Api\AuditService.Api.csproj", "{DD0A53CC-2D4D-4D5C-A6B4-825C7D7F5C2B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuditService.Application", "AuditService.Application\AuditService.Application.csproj", "{FBE4F7D8-30ED-44E5-81EC-B5BAB605F999}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuditService.Domain", "AuditService.Domain\AuditService.Domain.csproj", "{A1DF5166-964E-42F7-90B9-1A7B70A0C636}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuditService.Infrastructure", "AuditService.Infrastructure\AuditService.Infrastructure.csproj", "{5DBD4587-1532-49B3-9A5E-AEBDEADE96B9}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuditService.Shared", "AuditService.Shared\AuditService.Shared.csproj", "{3B24657F-30C3-411B-BC2B-04C420733E77}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DD0A53CC-2D4D-4D5C-A6B4-825C7D7F5C2B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DD0A53CC-2D4D-4D5C-A6B4-825C7D7F5C2B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DD0A53CC-2D4D-4D5C-A6B4-825C7D7F5C2B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DD0A53CC-2D4D-4D5C-A6B4-825C7D7F5C2B}.Release|Any CPU.Build.0 = Release|Any CPU
		{FBE4F7D8-30ED-44E5-81EC-B5BAB605F999}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FBE4F7D8-30ED-44E5-81EC-B5BAB605F999}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FBE4F7D8-30ED-44E5-81EC-B5BAB605F999}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FBE4F7D8-30ED-44E5-81EC-B5BAB605F999}.Release|Any CPU.Build.0 = Release|Any CPU
		{A1DF5166-964E-42F7-90B9-1A7B70A0C636}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A1DF5166-964E-42F7-90B9-1A7B70A0C636}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A1DF5166-964E-42F7-90B9-1A7B70A0C636}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A1DF5166-964E-42F7-90B9-1A7B70A0C636}.Release|Any CPU.Build.0 = Release|Any CPU
		{5DBD4587-1532-49B3-9A5E-AEBDEADE96B9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5DBD4587-1532-49B3-9A5E-AEBDEADE96B9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5DBD4587-1532-49B3-9A5E-AEBDEADE96B9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5DBD4587-1532-49B3-9A5E-AEBDEADE96B9}.Release|Any CPU.Build.0 = Release|Any CPU
		{3B24657F-30C3-411B-BC2B-04C420733E77}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3B24657F-30C3-411B-BC2B-04C420733E77}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3B24657F-30C3-411B-BC2B-04C420733E77}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3B24657F-30C3-411B-BC2B-04C420733E77}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal

---- File: AuditService.Api\appsettings.Development.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "Serilog": {
    "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning",
        "Microsoft.EntityFrameworkCore": "Information"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "theme": "Serilog.Sinks.SystemConsole.Themes.AnsiConsoleTheme::Code, Serilog.Sinks.Console",
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/auditservice-.txt",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 7,
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=auditservice;Username=postgres;Password=password;Pooling=true;",
    "Redis": "localhost:6379"
  },
  "DatabaseSettings": {
    "Provider": "PostgreSQL",
    "EnableSensitiveDataLogging": true,
    "EnableDetailedErrors": true,
    "AutoMigrate": true,
    "CommandTimeout": 30
  },
  "CacheSettings": {
    "RedisConnectionString": "localhost:6379",
    "DefaultExpirationMinutes": 30,
    "EnableDistributedCache": true,
    "EnableMemoryCache": true
  },
  "RabbitMQ": {
    "Host": "localhost",
    "Port": 5672,
    "Username": "guest",
    "Password": "guest",
    "VirtualHost": "/"
  },
  "AuditService": {
    "EnableRabbitMQ": true,
    "QueueName": "audit-queue",
    "ExchangeName": "audit-exchange",
    "RoutingKey": "audit.routing.key"
  },
  "HealthChecks": {
    "Enabled": true,
    "EndpointPath": "/health",
    "UiEndpointPath": "/health-ui",
    "IncludeDetails": true
  },
  "AllowedHosts": "*",
  "Kestrel": {
    "Endpoints": {
      "Http": {
        "Url": "http://localhost:5084"
      },
      "Https": {
        "Url": "https://localhost:7084"
      }
    }
  }
}

---- File: AuditService.Api\appsettings.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning"
    }
  },
  "Serilog": {
    "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/auditservice-.txt",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 7,
          "fileSizeLimitBytes": 10485760,
          "rollOnFileSizeLimit": true
        }
      }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=auditservice-db;Port=5432;Database=auditservice;Username=postgres;Password=password;Pooling=true;",
    "Redis": "redis:6379"
  },
  "DatabaseSettings": {
    "Provider": "PostgreSQL",
    "EnableSensitiveDataLogging": false,
    "EnableDetailedErrors": false,
    "AutoMigrate": true,
    "CommandTimeout": 30,
    "MaxRetryCount": 3,
    "MaxPageSize": 1000,
    "DefaultPageSize": 50
  },
  "CacheSettings": {
    "RedisConnectionString": "redis:6379",
    "DefaultExpirationMinutes": 30,
    "AuditLogCacheExpirationMinutes": 15,
    "StatisticsCacheExpirationMinutes": 5,
    "EnableDistributedCache": true,
    "EnableMemoryCache": true,
    "MaxMemoryCacheSizeMB": 100,
    "CacheKeyPrefix": "auditservice_"
  },
  "RabbitMQ": {
    "Host": "rabbitmq",
    "Port": 5672,
    "Username": "guest",
    "Password": "guest",
    "VirtualHost": "/"
  },
  "AuditService": {
    "EnableRabbitMQ": true,
    "QueueName": "audit-queue",
    "ExchangeName": "audit-exchange",
    "RoutingKey": "audit.routing.key"
  },
  "HealthChecks": {
    "Enabled": true,
    "EndpointPath": "/health",
    "UiEndpointPath": "/health-ui",
    "DatabaseTimeout": 30,
    "RedisTimeout": 10,
    "ExternalServicesTimeout": 30,
    "IncludeDetails": true,
    "EvaluationTimeInSeconds": 30
  },
  "AllowedHosts": "*",
  "Cors": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "http://localhost:3001",
      "https://localhost:3000",
      "https://localhost:3001"
    ]
  }
}

---- File: AuditService.Api\appsettings.Production.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "Serilog": {
    "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File", "Serilog.Sinks.Seq" ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "/app/logs/auditservice-.txt",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 30,
          "fileSizeLimitBytes": 10485760,
          "rollOnFileSizeLimit": true,
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level:u3}] {Message:lj}{NewLine}{Exception}"
        }
      },
      {
        "Name": "Seq",
        "Args": {
          "serverUrl": "http://seq:5341",
          "apiKey": "",
          "restrictedToMinimumLevel": "Information"
        }
      }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=auditservice-db;Port=5432;Database=auditservice;Username=postgres;Password=password;Pooling=true;Timeout=30;",
    "Redis": "redis:6379,abortConnect=false,connectTimeout=30000,syncTimeout=30000"
  },
  "DatabaseSettings": {
    "Provider": "PostgreSQL",
    "EnableSensitiveDataLogging": false,
    "EnableDetailedErrors": false,
    "AutoMigrate": true,
    "CommandTimeout": 30,
    "MaxRetryCount": 3,
    "EnableQueryTracking": false
  },
  "CacheSettings": {
    "RedisConnectionString": "redis:6379,abortConnect=false",
    "DefaultExpirationMinutes": 30,
    "EnableDistributedCache": true,
    "EnableMemoryCache": false
  },
  "RabbitMQ": {
    "Host": "rabbitmq",
    "Port": 5672,
    "Username": "guest",
    "Password": "guest",
    "VirtualHost": "/"
  },
  "AuditService": {
    "EnableRabbitMQ": true,
    "QueueName": "audit-queue",
    "ExchangeName": "audit-exchange",
    "RoutingKey": "audit.routing.key"
  },
  "HealthChecks": {
    "Enabled": true,
    "EndpointPath": "/health",
    "IncludeDetails": false,
    "EvaluationTimeInSeconds": 30
  },
  "AllowedHosts": "*",
  "Kestrel": {
    "Endpoints": {
      "Http": {
        "Url": "http://*:80"
      }
    }
  }
}

---- File: AuditService.Api\AuditService.Api.csproj ----
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="AspNetCore.HealthChecks.UI" Version="8.0.2" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" Version="8.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.InMemory.Storage" Version="8.0.1" />
    <PackageReference Include="KubernetesClient" Version="17.0.14" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.8" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.4.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="5.0.0" />
    <PackageReference Include="Serilog.Sinks.File" Version="6.0.0" />
    <PackageReference Include="Serilog.Sinks.Seq" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AuditService.Application\AuditService.Application.csproj" />
    <ProjectReference Include="..\AuditService.Infrastructure\AuditService.Infrastructure.csproj" />
  </ItemGroup>

</Project>

---- File: AuditService.Api\AuditService.Api.http ----
@AuditService.Api_HostAddress = http://localhost:5084
@ContentType = application/json

### Health Check - Ping
GET {{AuditService.Api_HostAddress}}/api/health/ping
Accept: application/json

### Health Check - Detailed
GET {{AuditService.Api_HostAddress}}/api/health/detailed
Accept: application/json

### Get All Audit Logs (Paginated)
GET {{AuditService.Api_HostAddress}}/api/audit?page=1&pageSize=10
Accept: application/json

### Get Audit Logs with Filters
GET {{AuditService.Api_HostAddress}}/api/audit?userId=user123&action=LOGIN&fromDate=2024-01-01&toDate=2024-12-31
Accept: application/json

### Get Audit Log by ID
GET {{AuditService.Api_HostAddress}}/api/audit/{{auditLogId}}
Accept: application/json

### Create Audit Log
POST {{AuditService.Api_HostAddress}}/api/audit
Content-Type: {{ContentType}}

{
  "userId": "user123",
  "action": "LOGIN",
  "resource": "AUTH",
  "userIp": "192.168.1.100",
  "userAgent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
  "additionalData": {
    "browser": "Chrome",
    "platform": "Windows"
  },
  "success": true,
  "serviceName": "AuthService",
  "severity": 2
}

### Create Failed Audit Log
POST {{AuditService.Api_HostAddress}}/api/audit
Content-Type: {{ContentType}}

{
  "userId": "user456",
  "action": "LOGIN",
  "resource": "AUTH",
  "userIp": "192.168.1.101",
  "userAgent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
  "additionalData": {
    "reason": "Invalid credentials",
    "attemptCount": 3
  },
  "success": false,
  "errorMessage": "Invalid username or password",
  "serviceName": "AuthService",
  "severity": 4
}

### Get Audit Statistics
GET {{AuditService.Api_HostAddress}}/api/audit/stats?fromDate=2024-01-01&toDate=2024-12-31
Accept: application/json

### Get User Audit Logs
GET {{AuditService.Api_HostAddress}}/api/audit/user/user123?page=1&pageSize=20
Accept: application/json

### Get Audit Logs by Action
GET {{AuditService.Api_HostAddress}}/api/audit?action=LOGIN&page=1&pageSize=15
Accept: application/json

### Get Audit Logs by Date Range
GET {{AuditService.Api_HostAddress}}/api/audit?fromDate=2024-10-01&toDate=2024-10-31&sortBy=createdAt&sortDescending=false
Accept: application/json

---- File: AuditService.Api\Dockerfile.dev ----
############################################
# Etapa �nica de desarrollo: SDK + hot-reload + debugger
############################################
FROM mcr.microsoft.com/dotnet/sdk:8.0

# 1) Instala dotnet-watch y vsdbg para hot-reload y depuraci�n remota
RUN dotnet tool install --global dotnet-watch \
    && export PATH="$PATH:/root/.dotnet/tools" \
 && apt-get update \
 && apt-get install -y unzip curl \
 && curl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l /vsdbg

WORKDIR /app

# 2) Copia y restaura s�lo el csproj de la API
COPY AuditService/AuditService.Api/AuditService.Api.csproj ./AuditService/AuditService.Api/
RUN dotnet restore "AuditService/AuditService.Api/AuditService.Api.csproj"

# 3) Copia el resto del c�digo fuente
COPY . .

# 4) Variables de entorno para desarrollo
ENV ASPNETCORE_ENVIRONMENT=Development \
    ASPNETCORE_URLS="http://+:80" \
    DOTNET_MSBUILD_CONFIGURATION=Debug  \
    DOTNET_BUILD_CONFIGURATION=Debug  \
    DOTNET_USE_POLLING_FILE_WATCHER=true \
    NUGET_XMLDOC_MODE=none

# 5) Exponer puertos HTTP y debug (mapped to 4025:4024)
EXPOSE 80
EXPOSE 4024

# 6) Arranca vsdbg en modo servidor y luego hot-reload de la app
ENTRYPOINT ["bash", "-lc", "\
  /vsdbg/vsdbg --interpreter=vscode --server --port 4024 & \
  dotnet watch run --project AuditService/AuditService.Api/AuditService.Api.csproj --urls http://0.0.0.0:80\n"]

---- File: AuditService.Api\Dockerfile.prod ----
# Stage 1: Build & Publish
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# Copiar sln y csproj para cache de dependencias
COPY AuditService/AuditService.sln .
COPY AuditService/AuditService.Api/AuditService.Api.csproj AuditService.Api/
COPY AuditService/AuditService.Application/AuditService.Application.csproj AuditService.Application/
COPY AuditService/AuditService.Domain/AuditService.Domain.csproj AuditService.Domain/
COPY AuditService/AuditService.Infrastructure/AuditService.Infrastructure.csproj AuditService.Infrastructure/
COPY AuditService/AuditService.Shared/AuditService.Shared.csproj AuditService.Shared/

RUN dotnet restore AuditService.sln

# Copiar todo y publicar
COPY . .
RUN dotnet publish AuditService/AuditService.Api -c Release -o /app

# Stage 2: Runtime
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app

# Variables seg�n docker-compose (expose 80)
ENV ASPNETCORE_ENVIRONMENT=Production
ENV ASPNETCORE_URLS="http://+:80"
ENV DOTNET_RUNNING_IN_CONTAINER=true

# Usuario no-root
RUN adduser --disabled-password --gecos '' appuser \
    && chown -R appuser:appuser /app
USER appuser

# Copiar publicaci�n
COPY --from=build --chown=appuser:appuser /app ./

# Expone puerto 80 (compose expone 80)
EXPOSE 80

# Healthcheck a /api/health/ping
HEALTHCHECK --interval=30s --timeout=3s \
    CMD curl -f http://localhost:80/api/health/ping || exit 1

ENTRYPOINT ["dotnet", "AuditService.Api.dll"]

---- File: AuditService.Api\Program.cs ----
using AuditService.Infrastructure.Extensions;
using AuditService.Infrastructure.Persistence;
using AuditService.Shared;
using AuditService.Shared.Settings;
using Microsoft.EntityFrameworkCore;
using Serilog;
// REMOVER esta l�nea problem�tica
// using AspNetCore.HealthChecks.UI.Client; 
// EN SU LUGAR usar:
using Microsoft.Extensions.Diagnostics.HealthChecks;
using HealthChecks.UI.Client; // Este es el namespace correcto

var builder = WebApplication.CreateBuilder(args);

// Configure Serilog
builder.Host.UseSerilog((context, configuration) =>
    configuration.ReadFrom.Configuration(context.Configuration));

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();

// Configure Swagger
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new Microsoft.OpenApi.Models.OpenApiInfo
    {
        Title = "Audit Service API",
        Version = "v1",
        Description = "Microservice for handling audit logs and security events",
        Contact = new Microsoft.OpenApi.Models.OpenApiContact
        {
            Name = "Audit Service Team",
            Email = "audit-service@cargurus.com"
        }
    });

    // Enable XML comments
    var xmlFile = $"{System.Reflection.Assembly.GetExecutingAssembly().GetName().Name}.xml";
    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
    if (File.Exists(xmlPath))
    {
        c.IncludeXmlComments(xmlPath);
    }
});

// Add CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("CorsPolicy", policy =>
    {
        var allowedOrigins = builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>()
            ?? new[] { "http://localhost:3000", "https://localhost:3000" };

        policy.WithOrigins(allowedOrigins)
              .AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

// Add Infrastructure services (Database, Repositories, etc.)
builder.Services.AddInfrastructure(builder.Configuration);

// Add Health Checks
builder.Services.AddHealthChecks()
    .AddDbContextCheck<AuditDbContext>(
        name: "database",
        tags: new[] { "ready", "liveness" });

// Add Health Checks UI
builder.Services.AddHealthChecksUI(setup =>
{
    setup.SetHeaderText("Audit Service - Health Status");
    setup.AddHealthCheckEndpoint("Audit Service", "/health");
    setup.SetEvaluationTimeInSeconds(60);
    setup.SetApiMaxActiveRequests(3);
    setup.MaximumHistoryEntriesPerEndpoint(50);
})
.AddInMemoryStorage();

var app = builder.Build();

// Configure the HTTP request pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI(c =>
    {
        c.SwaggerEndpoint("/swagger/v1/swagger.json", "Audit Service API v1");
        c.RoutePrefix = "swagger";
    });

    // Apply migrations in development
    using var scope = app.Services.CreateScope();
    var dbContext = scope.ServiceProvider.GetRequiredService<AuditDbContext>();
    await dbContext.Database.MigrateAsync();
}

if (app.Environment.IsProduction())
{
    app.UseHttpsRedirection();

    // Apply migrations in production if enabled
    var databaseSettings = app.Services.GetRequiredService<Microsoft.Extensions.Options.IOptions<DatabaseSettings>>().Value;
    if (databaseSettings.AutoMigrate)
    {
        using var scope = app.Services.CreateScope();
        var dbContext = scope.ServiceProvider.GetRequiredService<AuditDbContext>();
        await dbContext.Database.MigrateAsync();
    }
}

app.UseCors("CorsPolicy");

app.UseRouting();
app.UseAuthorization();

app.MapControllers();

// Health check endpoints
app.MapHealthChecks("/health", new Microsoft.AspNetCore.Diagnostics.HealthChecks.HealthCheckOptions
{
    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse,
    Predicate = check => check.Tags.Contains("liveness")
});

app.MapHealthChecks("/health/ready", new Microsoft.AspNetCore.Diagnostics.HealthChecks.HealthCheckOptions
{
    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse,
    Predicate = check => check.Tags.Contains("ready")
});

app.MapHealthChecksUI(setup =>
{
    setup.UIPath = "/health-ui";
    // setup.AddCustomStylesheet("healthchecks-ui.css"); // Comentar si no existe el archivo
});

// Global exception handling middleware
app.Use(async (context, next) =>
{
    try
    {
        await next();
    }
    catch (Exception ex)
    {
        Log.Error(ex, "An unhandled exception occurred");
        context.Response.StatusCode = 500;
        await context.Response.WriteAsJsonAsync(new
        {
            error = "An internal server error occurred",
            requestId = context.TraceIdentifier
        });
    }
});

Log.Information("Audit Service starting up...");
Log.Information("Environment: {Environment}", app.Environment.EnvironmentName);

app.Run();

---- File: AuditService.Api\Controllers\AuditController.cs ----
using AuditService.Application.DTOs;
using AuditService.Application.Features.Audit.Commands.CreateAudit;
using AuditService.Application.Features.Audit.Queries.GetAuditLogById;
using AuditService.Application.Features.Audit.Queries.GetAuditLogs;
using AuditService.Application.Features.Audit.Queries.GetAuditStats;
using AuditService.Shared;
using MediatR;
using Microsoft.AspNetCore.Mvc;

namespace AuditService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class AuditController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<AuditController> _logger;

    public AuditController(IMediator mediator, ILogger<AuditController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    /// <summary>
    /// Get paginated audit logs with filtering options
    /// </summary>
    [HttpGet]
    [ProducesResponseType(typeof(ApiResponse<PaginatedResult<AuditLogDto>>), 200)]
    [ProducesResponseType(typeof(ApiResponse<PaginatedResult<AuditLogDto>>), 400)]
    public async Task<IActionResult> GetAuditLogs(
        [FromQuery] string? userId = null,
        [FromQuery] string? action = null,
        [FromQuery] string? resource = null,
        [FromQuery] string? serviceName = null,
        [FromQuery] string? severity = null,
        [FromQuery] bool? success = null,
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null,
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 50,
        [FromQuery] string? sortBy = null,
        [FromQuery] bool sortDescending = true,
        [FromQuery] string? searchText = null)
    {
        try
        {
            var query = new GetAuditLogsQuery
            {
                UserId = userId,
                Action = action,
                Resource = resource,
                ServiceName = serviceName,
                Severity = severity,
                Success = success,
                FromDate = fromDate,
                ToDate = toDate,
                Page = page,
                PageSize = pageSize,
                SortBy = sortBy,
                SortDescending = sortDescending,
                SearchText = searchText
            };

            var result = await _mediator.Send(query);

            if (!result.Success)
            {
                return BadRequest(result);
            }

            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit logs");
            return StatusCode(500, ApiResponse<PaginatedResult<AuditLogDto>>.Fail("Internal server error"));
        }
    }

    /// <summary>
    /// Get a specific audit log by ID
    /// </summary>
    [HttpGet("{id}")]
    [ProducesResponseType(typeof(ApiResponse<AuditLogDto>), 200)]
    [ProducesResponseType(typeof(ApiResponse<AuditLogDto>), 404)]
    public async Task<IActionResult> GetAuditLogById(string id)
    {
        try
        {
            var query = new GetAuditLogByIdQuery(id);
            var result = await _mediator.Send(query);

            if (!result.Success)
            {
                return NotFound(result);
            }

            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit log with ID: {AuditLogId}", id);
            return StatusCode(500, ApiResponse<AuditLogDto>.Fail("Internal server error"));
        }
    }

    /// <summary>
    /// Create a new audit log entry
    /// </summary>
    [HttpPost]
    [ProducesResponseType(typeof(ApiResponse<string>), 201)]
    [ProducesResponseType(typeof(ApiResponse<string>), 400)]
    public async Task<IActionResult> CreateAuditLog([FromBody] CreateAuditCommand command)
    {
        try
        {
            var result = await _mediator.Send(command);

            if (!result.Success)
            {
                return BadRequest(result);
            }

            return CreatedAtAction(
                nameof(GetAuditLogById),
                new { id = result.Data },
                result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating audit log");
            return StatusCode(500, ApiResponse<string>.Fail("Internal server error"));
        }
    }

    /// <summary>
    /// Get audit statistics and analytics
    /// </summary>
    [HttpGet("stats")]
    [ProducesResponseType(typeof(ApiResponse<AuditStatsDto>), 200)]
    public async Task<IActionResult> GetAuditStats(
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null,
        [FromQuery] string? serviceName = null,
        [FromQuery] string? userId = null,
        [FromQuery] string? action = null)
    {
        try
        {
            var query = new GetAuditStatsQuery
            {
                FromDate = fromDate,
                ToDate = toDate,
                ServiceName = serviceName,
                UserId = userId,
                Action = action
            };

            var result = await _mediator.Send(query);
            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit statistics");
            return StatusCode(500, ApiResponse<AuditStatsDto>.Fail("Internal server error"));
        }
    }

    /// <summary>
    /// Get audit logs for a specific user
    /// </summary>
    [HttpGet("user/{userId}")]
    [ProducesResponseType(typeof(ApiResponse<PaginatedResult<AuditLogDto>>), 200)]
    public async Task<IActionResult> GetUserAuditLogs(
        string userId,
        [FromQuery] DateTime? fromDate = null,
        [FromQuery] DateTime? toDate = null,
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 50)
    {
        try
        {
            var query = new GetAuditLogsQuery
            {
                UserId = userId,
                FromDate = fromDate,
                ToDate = toDate,
                Page = page,
                PageSize = pageSize
            };

            var result = await _mediator.Send(query);
            return Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit logs for user: {UserId}", userId);
            return StatusCode(500, ApiResponse<PaginatedResult<AuditLogDto>>.Fail("Internal server error"));
        }
    }
}

---- File: AuditService.Api\Controllers\HealthController.cs ----
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Diagnostics.HealthChecks;

namespace AuditService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class HealthController : ControllerBase
{
    private readonly HealthCheckService _healthCheckService;
    private readonly ILogger<HealthController> _logger;

    public HealthController(
        HealthCheckService healthCheckService,
        ILogger<HealthController> logger)
    {
        _healthCheckService = healthCheckService;
        _logger = logger;
    }

    /// <summary>
    /// Get health status of the Audit Service
    /// </summary>
    [HttpGet]
    public async Task<IActionResult> GetHealth()
    {
        try
        {
            var healthReport = await _healthCheckService.CheckHealthAsync();

            var status = healthReport.Status == HealthStatus.Healthy ? "Healthy" :
                        healthReport.Status == HealthStatus.Degraded ? "Degraded" : "Unhealthy";

            var response = new
            {
                status = status,
                timestamp = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"),
                checks = healthReport.Entries.Select(entry => new
                {
                    name = entry.Key,
                    status = entry.Value.Status.ToString(),
                    description = entry.Value.Description,
                    duration = entry.Value.Duration.TotalMilliseconds,
                    exception = entry.Value.Exception?.Message
                })
            };

            return healthReport.Status == HealthStatus.Healthy ? Ok(response) : StatusCode(503, response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during health check");
            return StatusCode(503, new
            {
                status = "Unhealthy",
                timestamp = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"),
                error = ex.Message
            });
        }
    }

    /// <summary>
    /// Simple ping endpoint for load balancers and basic connectivity checks
    /// </summary>
    [HttpGet("ping")]
    public IActionResult Ping()
    {
        return Ok(new
        {
            message = "Audit Service is running",
            timestamp = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"),
            version = GetType().Assembly.GetName().Version?.ToString() ?? "1.0.0"
        });
    }

    /// <summary>
    /// Detailed health check with component status
    /// </summary>
    [HttpGet("detailed")]
    public async Task<IActionResult> GetDetailedHealth()
    {
        try
        {
            var healthReport = await _healthCheckService.CheckHealthAsync();

            var response = new
            {
                status = healthReport.Status.ToString(),
                totalDuration = healthReport.TotalDuration.TotalMilliseconds,
                timestamp = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"),
                services = healthReport.Entries.ToDictionary(
                    entry => entry.Key,
                    entry => new
                    {
                        status = entry.Value.Status.ToString(),
                        description = entry.Value.Description,
                        duration = entry.Value.Duration.TotalMilliseconds,
                        data = entry.Value.Data,
                        tags = entry.Value.Tags,
                        exception = entry.Value.Exception?.Message
                    })
            };

            return healthReport.Status == HealthStatus.Healthy ? Ok(response) : StatusCode(503, response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during detailed health check");
            return StatusCode(503, new
            {
                status = "Unhealthy",
                timestamp = DateTime.UtcNow.ToString("yyyy-MM-ddTHH:mm:ss.fffZ"),
                error = ex.Message,
                details = ex.StackTrace
            });
        }
    }
}

---- File: AuditService.Application\AuditService.Application.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <ProjectReference Include="..\AuditService.Domain\AuditService.Domain.csproj" />
    <ProjectReference Include="..\AuditService.Shared\AuditService.Shared.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="AutoMapper" Version="15.1.0" />
    <PackageReference Include="FluentValidation" Version="12.0.0" />
    <PackageReference Include="MediatR" Version="13.1.0" />
  </ItemGroup>

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

---- File: AuditService.Application\Common\Behaviours\LoggingBehaviour.cs ----
using MediatR;
using Microsoft.Extensions.Logging;
using AuditService.Application.Features.Audit.Commands.CreateAudit;
using AuditService.Shared;
using AuditService.Shared.Enums;

namespace AuditService.Application.Common.Behaviours;

public class LoggingBehaviour<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
    where TRequest : IRequest<TResponse>
{
    private readonly ILogger<LoggingBehaviour<TRequest, TResponse>> _logger;
    private readonly IMediator _mediator;

    public LoggingBehaviour(ILogger<LoggingBehaviour<TRequest, TResponse>> logger, IMediator mediator)
    {
        _logger = logger;
        _mediator = mediator;
    }

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
    {
        var requestName = typeof(TRequest).Name;
        var requestType = request.GetType().Name;

        _logger.LogInformation("Handling {RequestName} ({RequestType})", requestName, requestType);

        try
        {
            var startTime = DateTime.UtcNow;
            var response = await next();
            var duration = DateTime.UtcNow - startTime;

            // Log successful operation
            await LogAuditEvent(request, response, duration.TotalMilliseconds, true, null);

            _logger.LogInformation("Handled {RequestName} successfully in {Duration}ms",
                requestName, duration.TotalMilliseconds);

            return response;
        }
        catch (Exception ex)
        {
            // Log failed operation
            await LogAuditEvent(request, default, 0, false, ex.Message);

            _logger.LogError(ex, "Error handling {RequestName}", requestName);
            throw;
        }
    }

    private async Task LogAuditEvent(TRequest request, TResponse? response, double durationMs, bool success, string? errorMessage)
    {
        try
        {
            var userId = "system"; // In a real scenario, get from HttpContext or claims
            var userIp = "127.0.0.1"; // In a real scenario, get from HttpContext
            var userAgent = "AuditService"; // In a real scenario, get from HttpContext

            var additionalData = new Dictionary<string, object>
            {
                ["requestType"] = typeof(TRequest).Name,
                ["responseType"] = typeof(TResponse).Name,
                ["durationMs"] = durationMs,
                ["success"] = success,
                ["timestamp"] = DateTime.UtcNow
            };

            if (response is ApiResponse apiResponse)
            {
                additionalData["apiResponseSuccess"] = apiResponse.Success;
                if (!string.IsNullOrEmpty(apiResponse.Error))
                {
                    additionalData["apiResponseError"] = apiResponse.Error;
                }
            }

            if (!string.IsNullOrEmpty(errorMessage))
            {
                additionalData["error"] = errorMessage;
            }

            // Create audit command
            var auditCommand = new CreateAuditCommand(
                userId: userId,
                action: $"COMMAND_{typeof(TRequest).Name.ToUpper()}",
                resource: typeof(TRequest).FullName ?? "Unknown",
                userIp: userIp,
                userAgent: userAgent,
                additionalData: additionalData,
                success: success,
                errorMessage: errorMessage,
                durationMs: (long)durationMs,
                serviceName: "AuditService",
                severity: success ? AuditSeverity.Information : AuditSeverity.Error
            );

            await _mediator.Send(auditCommand);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to log audit event for {RequestType}", typeof(TRequest).Name);
            // Don't throw - we don't want to break the main flow if auditing fails
        }
    }
}

---- File: AuditService.Application\DTOs\AuditLogDto.cs ----
using AuditService.Shared.Enums;

namespace AuditService.Application.DTOs;

public class AuditLogDto
{
    public string Id { get; set; } = string.Empty;
    public string UserId { get; set; } = string.Empty;
    public string Action { get; set; } = string.Empty;
    public string Resource { get; set; } = string.Empty;
    public string UserIp { get; set; } = string.Empty;
    public string UserAgent { get; set; } = string.Empty;
    public Dictionary<string, object> AdditionalData { get; set; } = new();
    public bool Success { get; set; }
    public string? ErrorMessage { get; set; }
    public long? DurationMs { get; set; }
    public string? CorrelationId { get; set; }
    public string ServiceName { get; set; } = "Unknown";
    public AuditSeverity Severity { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }

    // Display properties
    public string UserDisplayName => GetUserDisplayName();
    public string SeverityDisplayName => Severity.GetDisplayName();
    public string SeverityCssClass => Severity.GetCssClass();
    public string ActionCategory => AuditEnumExtensions.GetActionCategory(Action);
    public string ActionIcon => AuditEnumExtensions.GetActionIcon(Action);
    public string Summary => GetSummary();

    public static AuditLogDto FromEntity(Domain.Entities.AuditLog entity)
    {
        return new AuditLogDto
        {
            Id = entity.Id,
            UserId = entity.UserId,
            Action = entity.Action,
            Resource = entity.Resource,
            UserIp = entity.UserIp,
            UserAgent = entity.UserAgent,
            AdditionalData = entity.AdditionalData,
            Success = entity.Success,
            ErrorMessage = entity.ErrorMessage,
            DurationMs = entity.DurationMs,
            CorrelationId = entity.CorrelationId,
            ServiceName = entity.ServiceName,
            Severity = entity.Severity,
            CreatedAt = entity.CreatedAt,
            UpdatedAt = entity.UpdatedAt
        };
    }

    private string GetUserDisplayName()
    {
        return UserId switch
        {
            "system" => "System",
            "anonymous" => "Anonymous",
            _ => UserId
        };
    }

    private string GetSummary()
    {
        var status = Success ? "SUCCESS" : "FAILED";
        var user = GetUserDisplayName();
        return $"{Action} on {Resource} by {user} - {status}";
    }
}

---- File: AuditService.Application\DTOs\AuditStatsDto.cs ----
namespace AuditService.Application.DTOs;

public class AuditStatsDto
{
    public int TotalLogs { get; set; }
    public int SuccessfulLogs { get; set; }
    public int FailedLogs { get; set; }
    public int SystemLogs { get; set; }
    public int UserLogs { get; set; }
    public int AnonymousLogs { get; set; }
    public double SuccessRate { get; set; }
    public DateTime? FirstLogDate { get; set; }
    public DateTime? LastLogDate { get; set; }

    // Statistics by categories
    public Dictionary<string, int> LogsBySeverity { get; set; } = new();
    public Dictionary<string, int> LogsByService { get; set; } = new();
    public Dictionary<string, int> LogsByAction { get; set; } = new();
    public Dictionary<string, int> LogsByResource { get; set; } = new();

    // Time-based statistics
    public Dictionary<DateTime, int> DailyCounts { get; set; } = new();
    public Dictionary<string, int> HourlyAverages { get; set; } = new();

    // Performance metrics
    public double AverageDurationMs { get; set; }
    public long MaxDurationMs { get; set; }
    public long MinDurationMs { get; set; }

    // Top lists
    public List<ActionFrequencyDto> TopActions { get; set; } = new();
    public List<UserActivityDto> TopUsers { get; set; } = new();
    public List<ServiceActivityDto> TopServices { get; set; } = new();

    // Error analysis
    public Dictionary<string, int> CommonErrors { get; set; } = new();
    public int TotalErrorsLast24h { get; set; }
    public double ErrorRateTrend { get; set; }
}

public class ActionFrequencyDto
{
    public string Action { get; set; } = string.Empty;
    public int Count { get; set; }
    public int SuccessCount { get; set; }
    public int FailureCount { get; set; }
    public double SuccessRate => Count > 0 ? (SuccessCount * 100.0) / Count : 0;
    public double AverageDurationMs { get; set; }
}

public class UserActivityDto
{
    public string UserId { get; set; } = string.Empty;
    public string UserDisplayName { get; set; } = string.Empty;
    public int TotalActions { get; set; }
    public int SuccessfulActions { get; set; }
    public int FailedActions { get; set; }
    public double SuccessRate => TotalActions > 0 ? (SuccessfulActions * 100.0) / TotalActions : 0;
    public DateTime FirstActivity { get; set; }
    public DateTime LastActivity { get; set; }
    public List<string> MostFrequentActions { get; set; } = new();
    public double AverageActionsPerDay { get; set; }
}

public class ServiceActivityDto
{
    public string ServiceName { get; set; } = string.Empty;
    public int TotalLogs { get; set; }
    public int ErrorCount { get; set; }
    public double ErrorRate => TotalLogs > 0 ? (ErrorCount * 100.0) / TotalLogs : 0;
    public double AverageDurationMs { get; set; }
    public DateTime LastActivity { get; set; }
}

---- File: AuditService.Application\Features\Audit\Commands\CreateAudit\CreateAuditCommand.cs ----
using AuditService.Shared;
using AuditService.Shared.Enums; // Agregar este using
using MediatR;

namespace AuditService.Application.Features.Audit.Commands.CreateAudit;

public class CreateAuditCommand : IRequest<ApiResponse<string>>
{
    public string UserId { get; set; } = string.Empty;
    public string Action { get; set; } = string.Empty;
    public string Resource { get; set; } = string.Empty;
    public string UserIp { get; set; } = string.Empty;
    public string UserAgent { get; set; } = string.Empty;
    public Dictionary<string, object> AdditionalData { get; set; } = new();
    public bool Success { get; set; } = true;
    public string? ErrorMessage { get; set; }
    public long? DurationMs { get; set; }
    public string? CorrelationId { get; set; }
    public string ServiceName { get; set; } = "Unknown";
    public AuditSeverity Severity { get; set; } = AuditSeverity.Information; // Ahora usa Shared.Enums.AuditSeverity

    public CreateAuditCommand() { }

    public CreateAuditCommand(
        string userId,
        string action,
        string resource,
        string userIp,
        string userAgent,
        Dictionary<string, object> additionalData,
        bool success = true,
        string? errorMessage = null,
        long? durationMs = null,
        string? correlationId = null,
        string serviceName = "Unknown",
        AuditSeverity severity = AuditSeverity.Information) // Cambiar aqu� tambi�n
    {
        UserId = userId;
        Action = action;
        Resource = resource;
        UserIp = userIp;
        UserAgent = userAgent;
        AdditionalData = additionalData;
        Success = success;
        ErrorMessage = errorMessage;
        DurationMs = durationMs;
        CorrelationId = correlationId;
        ServiceName = serviceName;
        Severity = severity;
    }
}

---- File: AuditService.Application\Features\Audit\Commands\CreateAudit\CreateAuditCommandHandler.cs ----
using AuditService.Domain.Entities;
using AuditService.Domain.Interfaces.Repositories;
using AuditService.Shared;
using AuditService.Shared.Enums;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuditService.Application.Features.Audit.Commands.CreateAudit;

public class CreateAuditCommandHandler : IRequestHandler<CreateAuditCommand, ApiResponse<string>>
{
    private readonly IAuditLogRepository _auditLogRepository;
    private readonly ILogger<CreateAuditCommandHandler> _logger;

    public CreateAuditCommandHandler(
        IAuditLogRepository auditLogRepository,
        ILogger<CreateAuditCommandHandler> logger)
    {
        _auditLogRepository = auditLogRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<string>> Handle(CreateAuditCommand request, CancellationToken cancellationToken)
    {
        try
        {
            // Validate the request
            if (string.IsNullOrWhiteSpace(request.UserId) ||
                string.IsNullOrWhiteSpace(request.Action) ||
                string.IsNullOrWhiteSpace(request.Resource))
            {
                return ApiResponse<string>.Fail("UserId, Action, and Resource are required");
            }

            // Create audit log entity
            AuditLog auditLog;

            if (request.Success)
            {
                auditLog = AuditLog.CreateSuccess(
                    request.UserId,
                    request.Action,
                    request.Resource,
                    request.UserIp,
                    request.UserAgent,
                    request.AdditionalData,
                    request.DurationMs,
                    request.CorrelationId,
                    request.ServiceName
                );
            }
            else
            {
                auditLog = AuditLog.CreateFailure(
                    request.UserId,
                    request.Action,
                    request.Resource,
                    request.UserIp,
                    request.UserAgent,
                    request.ErrorMessage ?? "Unknown error",
                    request.AdditionalData,
                    request.DurationMs,
                    request.CorrelationId,
                    request.ServiceName,
                    request.Severity
                );
            }

            // Set severity if provided
            if (request.Severity != AuditSeverity.Information)
            {
                auditLog.SetSeverity(request.Severity);
            }

            // Add to repository
            await _auditLogRepository.AddAsync(auditLog, cancellationToken);

            _logger.LogDebug("Audit log created with ID: {AuditLogId} for user {UserId}", auditLog.Id, request.UserId);

            return ApiResponse<string>.Ok(auditLog.Id, new Dictionary<string, object>
            {
                ["auditLogId"] = auditLog.Id,
                ["timestamp"] = auditLog.CreatedAt,
                ["userDisplayName"] = auditLog.GetUserDisplayName()
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error creating audit log for user {UserId}", request.UserId);
            return ApiResponse<string>.Fail("Error creating audit log");
        }
    }
}

---- File: AuditService.Application\Features\Audit\Commands\CreateAudit\CreateAuditCommandValidator.cs ----
using FluentValidation;
using AuditService.Shared;

namespace AuditService.Application.Features.Audit.Commands.CreateAudit;

public class CreateAuditCommandValidator : AbstractValidator<CreateAuditCommand>
{
    public CreateAuditCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("UserId is required")
            .MaximumLength(255).WithMessage("UserId must not exceed 255 characters");

        RuleFor(x => x.Action)
            .NotEmpty().WithMessage("Action is required")
            .MaximumLength(100).WithMessage("Action must not exceed 100 characters")
            .Must(ValidationPatterns.IsValidActionName).WithMessage("Action contains invalid characters");

        RuleFor(x => x.Resource)
            .NotEmpty().WithMessage("Resource is required")
            .MaximumLength(255).WithMessage("Resource must not exceed 255 characters")
            .Must(ValidationPatterns.IsValidResourceName).WithMessage("Resource contains invalid characters");

        RuleFor(x => x.UserIp)
            .NotEmpty().WithMessage("UserIp is required")
            .MaximumLength(45).WithMessage("UserIp must not exceed 45 characters")
            .Must(ValidationPatterns.IsValidIpAddress).WithMessage("UserIp must be a valid IP address");

        RuleFor(x => x.UserAgent)
            .NotEmpty().WithMessage("UserAgent is required")
            .MaximumLength(500).WithMessage("UserAgent must not exceed 500 characters")
            .Must(ValidationPatterns.IsValidUserAgent).WithMessage("UserAgent contains invalid characters");

        RuleFor(x => x.ServiceName)
            .NotEmpty().WithMessage("ServiceName is required")
            .MaximumLength(50).WithMessage("ServiceName must not exceed 50 characters")
            .Must(ValidationPatterns.IsValidServiceName).WithMessage("ServiceName contains invalid characters");

        RuleFor(x => x.CorrelationId)
            .MaximumLength(100).WithMessage("CorrelationId must not exceed 100 characters")
            .Must(correlationId => string.IsNullOrEmpty(correlationId) || ValidationPatterns.IsValidCorrelationId(correlationId))
            .WithMessage("CorrelationId contains invalid characters");

        When(x => !x.Success, () => {
            RuleFor(x => x.ErrorMessage)
                .NotEmpty().WithMessage("ErrorMessage is required when Success is false")
                .MaximumLength(1000).WithMessage("ErrorMessage must not exceed 1000 characters");
        });

        RuleFor(x => x.DurationMs)
            .GreaterThanOrEqualTo(0).WithMessage("DurationMs must be positive")
            .When(x => x.DurationMs.HasValue);

        RuleFor(x => x.AdditionalData)
            .Must(data => data == null || data.Count <= 50)
            .WithMessage("AdditionalData cannot contain more than 50 items")
            .Must(data => data == null || data.All(kv => kv.Key.Length <= 100 && kv.Value != null))
            .WithMessage("AdditionalData keys must not exceed 100 characters and values cannot be null");
    }
}

---- File: AuditService.Application\Features\Audit\Queries\GetAuditLogById\GetAuditLogByIdQuery.cs ----
using AuditService.Application.DTOs;
using AuditService.Shared;
using MediatR;

namespace AuditService.Application.Features.Audit.Queries.GetAuditLogById;

public class GetAuditLogByIdQuery : IRequest<ApiResponse<AuditLogDto>>
{
    public string Id { get; set; } = string.Empty;

    public GetAuditLogByIdQuery(string id)
    {
        Id = id;
    }

    public GetAuditLogByIdQuery() { }
}

---- File: AuditService.Application\Features\Audit\Queries\GetAuditLogById\GetAuditLogByIdQueryHandler.cs ----
using AuditService.Application.DTOs;
using AuditService.Domain.Interfaces.Repositories;
using AuditService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuditService.Application.Features.Audit.Queries.GetAuditLogById;

public class GetAuditLogByIdQueryHandler : IRequestHandler<GetAuditLogByIdQuery, ApiResponse<AuditLogDto>>
{
    private readonly IAuditLogRepository _auditLogRepository;
    private readonly ILogger<GetAuditLogByIdQueryHandler> _logger;

    public GetAuditLogByIdQueryHandler(
        IAuditLogRepository auditLogRepository,
        ILogger<GetAuditLogByIdQueryHandler> logger)
    {
        _auditLogRepository = auditLogRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<AuditLogDto>> Handle(GetAuditLogByIdQuery request, CancellationToken cancellationToken)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(request.Id))
            {
                return ApiResponse<AuditLogDto>.Fail("Audit log ID is required");
            }

            if (!ValidationPatterns.IsValidGuid(request.Id))
            {
                return ApiResponse<AuditLogDto>.Fail("Invalid audit log ID format");
            }

            var auditLog = await _auditLogRepository.GetByIdAsync(request.Id, cancellationToken);

            if (auditLog == null)
            {
                return ApiResponse<AuditLogDto>.Fail("Audit log not found");
            }

            var auditLogDto = AuditLogDto.FromEntity(auditLog);

            return ApiResponse<AuditLogDto>.Ok(auditLogDto);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit log with ID: {AuditLogId}", request.Id);
            return ApiResponse<AuditLogDto>.Fail("Error retrieving audit log");
        }
    }
}

---- File: AuditService.Application\Features\Audit\Queries\GetAuditLogs\GetAuditLogsQuery.cs ----
using AuditService.Application.DTOs;
using AuditService.Shared;
using MediatR;

namespace AuditService.Application.Features.Audit.Queries.GetAuditLogs;

public class GetAuditLogsQuery : IRequest<ApiResponse<PaginatedResult<AuditLogDto>>>
{
    public string? UserId { get; set; }
    public string? Action { get; set; }
    public string? Resource { get; set; }
    public string? ServiceName { get; set; }
    public string? Severity { get; set; }
    public bool? Success { get; set; }
    public DateTime? FromDate { get; set; }
    public DateTime? ToDate { get; set; }
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;
    public string? SortBy { get; set; }
    public bool SortDescending { get; set; } = true;
    public string? SearchText { get; set; }

    public GetAuditLogsQuery() { }

    public GetAuditLogsQuery(
        string? userId = null,
        string? action = null,
        string? resource = null,
        DateTime? fromDate = null,
        DateTime? toDate = null,
        int page = 1,
        int pageSize = 50)
    {
        UserId = userId;
        Action = action;
        Resource = resource;
        FromDate = fromDate;
        ToDate = toDate;
        Page = page;
        PageSize = pageSize;
    }
}

---- File: AuditService.Application\Features\Audit\Queries\GetAuditLogs\GetAuditLogsQueryHandler.cs ----
using AuditService.Application.DTOs;
using AuditService.Domain.Interfaces.Repositories;
using AuditService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuditService.Application.Features.Audit.Queries.GetAuditLogs;

public class GetAuditLogsQueryHandler : IRequestHandler<GetAuditLogsQuery, ApiResponse<PaginatedResult<AuditLogDto>>>
{
    private readonly IAuditLogRepository _auditLogRepository;
    private readonly ILogger<GetAuditLogsQueryHandler> _logger;

    public GetAuditLogsQueryHandler(
        IAuditLogRepository auditLogRepository,
        ILogger<GetAuditLogsQueryHandler> logger)
    {
        _auditLogRepository = auditLogRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<PaginatedResult<AuditLogDto>>> Handle(GetAuditLogsQuery request, CancellationToken cancellationToken)
    {
        try
        {
            // Validate pagination parameters
            if (request.Page < 1) request.Page = 1;
            if (request.PageSize < 1 || request.PageSize > Constants.Pagination.MaxPageSize)
                request.PageSize = Constants.Pagination.DefaultPageSize;

            // Get paginated results from repository
            var (items, totalCount) = await _auditLogRepository.GetPaginatedAsync(
                userId: request.UserId,
                action: request.Action,
                resource: request.Resource,
                fromDate: request.FromDate,
                toDate: request.ToDate,
                page: request.Page,
                pageSize: request.PageSize,
                sortBy: request.SortBy,
                sortDescending: request.SortDescending);

            // Convert entities to DTOs
            var auditLogDtos = items.Select(AuditLogDto.FromEntity).ToList();

            // Create paginated result using constructor instead of Create method
            var result = new PaginatedResult<AuditLogDto>
            {
                Items = auditLogDtos,
                TotalCount = totalCount,
                Page = request.Page,
                PageSize = request.PageSize,
                SortBy = request.SortBy,
                SortDescending = request.SortDescending
            };

            // Prepare metadata
            var metadata = new Dictionary<string, object>
            {
                ["totalCount"] = totalCount,
                ["filteredCount"] = auditLogDtos.Count,
                ["currentPage"] = request.Page,
                ["totalPages"] = result.TotalPages,
                ["hasPreviousPage"] = result.HasPreviousPage,
                ["hasNextPage"] = result.HasNextPage
            };

            if (!string.IsNullOrEmpty(request.UserId))
                metadata["filteredByUserId"] = request.UserId;
            if (!string.IsNullOrEmpty(request.Action))
                metadata["filteredByAction"] = request.Action;
            if (!string.IsNullOrEmpty(request.Resource))
                metadata["filteredByResource"] = request.Resource;
            if (request.FromDate.HasValue)
                metadata["filteredFromDate"] = request.FromDate.Value;
            if (request.ToDate.HasValue)
                metadata["filteredToDate"] = request.ToDate.Value;

            return ApiResponse<PaginatedResult<AuditLogDto>>.Ok(result, metadata);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit logs with filters: {@Filters}", request);
            return ApiResponse<PaginatedResult<AuditLogDto>>.Fail("Error retrieving audit logs");
        }
    }
}

---- File: AuditService.Application\Features\Audit\Queries\GetAuditLogs\GetAuditLogsQueryValidator.cs ----
using FluentValidation;
using AuditService.Shared;

namespace AuditService.Application.Features.Audit.Queries.GetAuditLogs;

public class GetAuditLogsQueryValidator : AbstractValidator<GetAuditLogsQuery>
{
    public GetAuditLogsQueryValidator()
    {
        RuleFor(x => x.Page)
            .GreaterThan(0).WithMessage("Page must be greater than 0");

        RuleFor(x => x.PageSize)
            .InclusiveBetween(1, Constants.Pagination.MaxPageSize)
            .WithMessage($"PageSize must be between 1 and {Constants.Pagination.MaxPageSize}");

        RuleFor(x => x.FromDate)
            .LessThanOrEqualTo(DateTime.UtcNow).WithMessage("FromDate cannot be in the future")
            .When(x => x.FromDate.HasValue);

        RuleFor(x => x.ToDate)
            .LessThanOrEqualTo(DateTime.UtcNow).WithMessage("ToDate cannot be in the future")
            .When(x => x.ToDate.HasValue);

        RuleFor(x => x)
            .Must(x => !x.FromDate.HasValue || !x.ToDate.HasValue || x.FromDate <= x.ToDate)
            .WithMessage("FromDate must be less than or equal to ToDate");

        RuleFor(x => x.UserId)
            .MaximumLength(255).WithMessage("UserId must not exceed 255 characters")
            .When(x => !string.IsNullOrEmpty(x.UserId));

        RuleFor(x => x.Action)
            .MaximumLength(100).WithMessage("Action must not exceed 100 characters")
            .Must(ValidationPatterns.IsValidActionName).WithMessage("Action contains invalid characters")
            .When(x => !string.IsNullOrEmpty(x.Action));

        RuleFor(x => x.Resource)
            .MaximumLength(255).WithMessage("Resource must not exceed 255 characters")
            .Must(ValidationPatterns.IsValidResourceName).WithMessage("Resource contains invalid characters")
            .When(x => !string.IsNullOrEmpty(x.Resource));

        RuleFor(x => x.ServiceName)
            .MaximumLength(50).WithMessage("ServiceName must not exceed 50 characters")
            .Must(ValidationPatterns.IsValidServiceName).WithMessage("ServiceName contains invalid characters")
            .When(x => !string.IsNullOrEmpty(x.ServiceName));

        RuleFor(x => x.SortBy)
            .Must(ValidationPatterns.IsValidSortBy).WithMessage("SortBy contains invalid characters")
            .When(x => !string.IsNullOrEmpty(x.SortBy));

        RuleFor(x => x.SearchText)
            .MaximumLength(100).WithMessage("SearchText must not exceed 100 characters")
            .When(x => !string.IsNullOrEmpty(x.SearchText));
    }
}

---- File: AuditService.Application\Features\Audit\Queries\GetAuditStats\GetAuditStatsQuery.cs ----
using AuditService.Application.DTOs;
using AuditService.Shared;
using MediatR;

namespace AuditService.Application.Features.Audit.Queries.GetAuditStats;

public class GetAuditStatsQuery : IRequest<ApiResponse<AuditStatsDto>>
{
    public DateTime? FromDate { get; set; }
    public DateTime? ToDate { get; set; }
    public string? ServiceName { get; set; }
    public string? UserId { get; set; }
    public string? Action { get; set; }

    public GetAuditStatsQuery() { }

    public GetAuditStatsQuery(DateTime? fromDate = null, DateTime? toDate = null)
    {
        FromDate = fromDate;
        ToDate = toDate;
    }
}

---- File: AuditService.Application\Features\Audit\Queries\GetAuditStats\GetAuditStatsQueryHandler.cs ----
using AuditService.Application.DTOs;
using AuditService.Domain.Interfaces.Repositories;
using AuditService.Shared;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuditService.Application.Features.Audit.Queries.GetAuditStats;

public class GetAuditStatsQueryHandler : IRequestHandler<GetAuditStatsQuery, ApiResponse<AuditStatsDto>>
{
    private readonly IAuditLogRepository _auditLogRepository;
    private readonly ILogger<GetAuditStatsQueryHandler> _logger;

    public GetAuditStatsQueryHandler(
        IAuditLogRepository auditLogRepository,
        ILogger<GetAuditStatsQueryHandler> logger)
    {
        _auditLogRepository = auditLogRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<AuditStatsDto>> Handle(GetAuditStatsQuery request, CancellationToken cancellationToken)
    {
        try
        {
            // Validate date range
            if (request.FromDate.HasValue && request.ToDate.HasValue && request.FromDate > request.ToDate)
            {
                return ApiResponse<AuditStatsDto>.Fail("FromDate cannot be greater than ToDate");
            }

            // Get statistics from repository
            var statistics = await _auditLogRepository.GetStatisticsAsync(request.FromDate, request.ToDate, cancellationToken);
            var topActions = await _auditLogRepository.GetTopActionsAsync(10, request.FromDate, request.ToDate, cancellationToken);
            var topUsers = await _auditLogRepository.GetTopUsersAsync(10, request.FromDate, request.ToDate, cancellationToken);

            // Convert to DTO
            var statsDto = new AuditStatsDto
            {
                TotalLogs = statistics.TotalLogs,
                SuccessfulLogs = statistics.SuccessfulLogs,
                FailedLogs = statistics.FailedLogs,
                SystemLogs = statistics.SystemLogs,
                UserLogs = statistics.UserLogs,
                AnonymousLogs = statistics.AnonymousLogs,
                SuccessRate = statistics.SuccessRate,
                FirstLogDate = statistics.FirstLogDate,
                LastLogDate = statistics.LastLogDate,
                LogsBySeverity = statistics.LogsBySeverity,
                LogsByService = statistics.LogsByService,
                LogsByAction = statistics.LogsByAction,
                TopActions = topActions.Select(a => new ActionFrequencyDto
                {
                    Action = a.Action,
                    Count = a.Count,
                    SuccessCount = a.SuccessCount,
                    FailureCount = a.FailureCount
                }).ToList(),
                TopUsers = topUsers.Select(u => new UserActivityDto
                {
                    UserId = u.UserId,
                    UserDisplayName = GetUserDisplayName(u.UserId),
                    TotalActions = u.TotalActions,
                    SuccessfulActions = u.SuccessfulActions,
                    FailedActions = u.FailedActions,
                    FirstActivity = u.FirstActivity,
                    LastActivity = u.LastActivity,
                    MostFrequentActions = u.MostFrequentActions
                }).ToList()
            };

            // Calculate additional metrics
            CalculateAdditionalMetrics(statsDto);

            // Prepare metadata
            var metadata = new Dictionary<string, object>
            {
                ["periodFrom"] = request.FromDate?.ToString("yyyy-MM-dd") ?? "Beginning",
                ["periodTo"] = request.ToDate?.ToString("yyyy-MM-dd") ?? "Now",
                ["generatedAt"] = DateTime.UtcNow
            };

            if (!string.IsNullOrEmpty(request.ServiceName))
                metadata["filteredByService"] = request.ServiceName;
            if (!string.IsNullOrEmpty(request.UserId))
                metadata["filteredByUserId"] = request.UserId;
            if (!string.IsNullOrEmpty(request.Action))
                metadata["filteredByAction"] = request.Action;

            return ApiResponse<AuditStatsDto>.Ok(statsDto, metadata);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error retrieving audit statistics for period {FromDate} to {ToDate}",
                request.FromDate, request.ToDate);
            return ApiResponse<AuditStatsDto>.Fail("Error retrieving audit statistics");
        }
    }

    private static string GetUserDisplayName(string userId)
    {
        return userId switch
        {
            "system" => "System",
            "anonymous" => "Anonymous",
            _ => userId
        };
    }

    private static void CalculateAdditionalMetrics(AuditStatsDto statsDto)
    {
        // Calculate hourly averages (simplified)
        if (statsDto.FirstLogDate.HasValue && statsDto.LastLogDate.HasValue)
        {
            var totalHours = (statsDto.LastLogDate.Value - statsDto.FirstLogDate.Value).TotalHours;
            if (totalHours > 0)
            {
                statsDto.HourlyAverages["logs_per_hour"] = (int)(statsDto.TotalLogs / totalHours);
            }
        }

        // Calculate error rate trend (simplified)
        statsDto.ErrorRateTrend = statsDto.TotalLogs > 0 ?
            (statsDto.FailedLogs * 100.0) / statsDto.TotalLogs : 0;
    }
}

---- File: AuditService.Domain\AuditService.Domain.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <ProjectReference Include="..\AuditService.Shared\AuditService.Shared.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="MediatR.Contracts" Version="1.0.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AuditService.Shared\AuditService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: AuditService.Domain\Common\EntityBase.cs ----
using MediatR;

namespace AuditService.Domain.Common;

/// <summary>
/// Base class for all entities in the domain
/// </summary>
public abstract class EntityBase : IEquatable<EntityBase>
{
    private readonly List<INotification> _domainEvents = new();

    /// <summary>
    /// Unique identifier for the entity
    /// </summary>
    public string Id { get; protected set; } = Guid.NewGuid().ToString();

    /// <summary>
    /// When the entity was created
    /// </summary>
    public DateTime CreatedAt { get; protected set; } = DateTime.UtcNow;

    /// <summary>
    /// When the entity was last updated
    /// </summary>
    public DateTime? UpdatedAt { get; protected set; }

    /// <summary>
    /// Domain events raised by this entity
    /// </summary>
    public IReadOnlyCollection<INotification> DomainEvents => _domainEvents.AsReadOnly();

    /// <summary>
    /// Adds a domain event to the entity
    /// </summary>
    public void AddDomainEvent(INotification eventItem)
    {
        _domainEvents.Add(eventItem);
    }

    /// <summary>
    /// Removes a domain event from the entity
    /// </summary>
    public void RemoveDomainEvent(INotification eventItem)
    {
        _domainEvents.Remove(eventItem);
    }

    /// <summary>
    /// Clears all domain events from the entity
    /// </summary>
    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }

    /// <summary>
    /// Marks the entity as updated and sets the UpdatedAt timestamp
    /// </summary>
    public void MarkAsUpdated()
    {
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Sets the creation timestamp (used for importing existing data)
    /// </summary>
    protected void SetCreatedAt(DateTime createdAt)
    {
        CreatedAt = createdAt;
    }

    /// <summary>
    /// Determines whether the specified object is equal to the current object
    /// </summary>
    public override bool Equals(object? obj)
    {
        if (obj is null) return false;
        if (ReferenceEquals(this, obj)) return true;
        if (obj.GetType() != GetType()) return false;
        return Equals((EntityBase)obj);
    }

    /// <summary>
    /// Determines whether the specified entity is equal to the current entity
    /// </summary>
    public bool Equals(EntityBase? other)
    {
        if (other is null) return false;
        if (ReferenceEquals(this, other)) return true;
        return Id == other.Id;
    }

    /// <summary>
    /// Serves as the default hash function
    /// </summary>
    public override int GetHashCode()
    {
        return Id.GetHashCode();
    }

    /// <summary>
    /// Equality operator
    /// </summary>
    public static bool operator ==(EntityBase? left, EntityBase? right)
    {
        if (left is null && right is null) return true;
        if (left is null || right is null) return false;
        return left.Equals(right);
    }

    /// <summary>
    /// Inequality operator
    /// </summary>
    public static bool operator !=(EntityBase? left, EntityBase? right)
    {
        return !(left == right);
    }

    /// <summary>
    /// Gets the components that are used for equality comparison
    /// </summary>
    protected virtual IEnumerable<object> GetEqualityComponents()
    {
        yield return Id;
    }

    /// <summary>
    /// Returns a string that represents the current entity
    /// </summary>
    public override string ToString()
    {
        return $"{GetType().Name} [Id={Id}]";
    }

    /// <summary>
    /// Validates the entity state
    /// </summary>
    public virtual bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(Id) && CreatedAt <= DateTime.UtcNow;
    }

    /// <summary>
    /// Creates a shallow copy of the entity
    /// </summary>
    public virtual EntityBase ShallowCopy()
    {
        return (EntityBase)MemberwiseClone();
    }
}

/// <summary>
/// Marker interface for aggregate roots
/// </summary>
public interface IAggregateRoot { }

/// <summary>
/// Base class for value objects
/// </summary>
public abstract class ValueObject : IEquatable<ValueObject>
{
    /// <summary>
    /// Gets the components that define the value object's equality
    /// </summary>
    protected abstract IEnumerable<object> GetEqualityComponents();

    /// <summary>
    /// Determines whether the specified object is equal to the current object
    /// </summary>
    public override bool Equals(object? obj)
    {
        if (obj is null || obj.GetType() != GetType())
            return false;

        var valueObject = (ValueObject)obj;
        return GetEqualityComponents().SequenceEqual(valueObject.GetEqualityComponents());
    }

    /// <summary>
    /// Determines whether the specified value object is equal to the current value object
    /// </summary>
    public bool Equals(ValueObject? other)
    {
        return Equals((object?)other);
    }

    /// <summary>
    /// Serves as the default hash function
    /// </summary>
    public override int GetHashCode()
    {
        return GetEqualityComponents()
            .Aggregate(1, (current, obj) =>
            {
                unchecked
                {
                    return current * 23 + (obj?.GetHashCode() ?? 0);
                }
            });
    }

    /// <summary>
    /// Equality operator
    /// </summary>
    public static bool operator ==(ValueObject left, ValueObject right)
    {
        if (ReferenceEquals(left, null) && ReferenceEquals(right, null))
            return true;

        if (ReferenceEquals(left, null) || ReferenceEquals(right, null))
            return false;

        return left.Equals(right);
    }

    /// <summary>
    /// Inequality operator
    /// </summary>
    public static bool operator !=(ValueObject left, ValueObject right)
    {
        return !(left == right);
    }
}

/// <summary>
/// Base class for domain events
/// </summary>
public abstract class DomainEvent : INotification
{
    /// <summary>
    /// When the event occurred
    /// </summary>
    public DateTime OccurredOn { get; protected set; } = DateTime.UtcNow;

    /// <summary>
    /// Unique identifier for the event
    /// </summary>
    public string EventId { get; protected set; } = Guid.NewGuid().ToString();

    /// <summary>
    /// Correlation ID for tracing
    /// </summary>
    public string? CorrelationId { get; set; }

    /// <summary>
    /// User ID who triggered the event
    /// </summary>
    public string? UserId { get; set; }

    /// <summary>
    /// Additional event data
    /// </summary>
    public Dictionary<string, object> Metadata { get; set; } = new();
}

---- File: AuditService.Domain\Entities\AuditLog.cs ----
using AuditService.Domain.Common;
using AuditService.Shared.Enums;
using System.Text.Json;

namespace AuditService.Domain.Entities;

/// <summary>
/// Represents an audit log entry that records user actions and system events
/// </summary>
public class AuditLog : EntityBase, IAggregateRoot
{
    /// <summary>
    /// ID of the user who performed the action
    /// </summary>
    public string UserId { get; private set; } = string.Empty;

    /// <summary>
    /// The action performed
    /// </summary>
    public string Action { get; private set; } = string.Empty;

    /// <summary>
    /// The resource that was affected by the action
    /// </summary>
    public string Resource { get; private set; } = string.Empty;

    /// <summary>
    /// IP address of the user who performed the action
    /// </summary>
    public string UserIp { get; private set; } = string.Empty;

    /// <summary>
    /// User agent string from the request
    /// </summary>
    public string UserAgent { get; private set; } = string.Empty;

    /// <summary>
    /// Additional context data stored as JSON
    /// </summary>
    public string AdditionalDataJson { get; private set; } = "{}";

    /// <summary>
    /// Whether the action was successful
    /// </summary>
    public bool Success { get; private set; } = true;

    /// <summary>
    /// Error message if the action failed
    /// </summary>
    public string? ErrorMessage { get; private set; }

    /// <summary>
    /// Duration of the operation in milliseconds
    /// </summary>
    public long? DurationMs { get; private set; }

    /// <summary>
    /// Correlation ID for tracing requests across services
    /// </summary>
    public string? CorrelationId { get; private set; }

    /// <summary>
    /// Name of the service that generated the audit event
    /// </summary>
    public string ServiceName { get; private set; } = "Unknown";

    /// <summary>
    /// Severity level of the audit event
    /// </summary>
    public AuditSeverity Severity { get; private set; } = AuditSeverity.Information;

    // Private constructor for Entity Framework
    private AuditLog() { }

    /// <summary>
    /// Creates a new audit log entry
    /// </summary>
    public AuditLog(
        string userId,
        string action,
        string resource,
        string userIp,
        string userAgent,
        Dictionary<string, object> additionalData,
        bool success = true,
        string? errorMessage = null,
        long? durationMs = null,
        string? correlationId = null,
        string serviceName = "Unknown",
        AuditSeverity severity = AuditSeverity.Information)
    {
        if (string.IsNullOrWhiteSpace(userId))
            throw new ArgumentException("UserId cannot be null or empty", nameof(userId));
        if (string.IsNullOrWhiteSpace(action))
            throw new ArgumentException("Action cannot be null or empty", nameof(action));
        if (string.IsNullOrWhiteSpace(resource))
            throw new ArgumentException("Resource cannot be null or empty", nameof(resource));
        if (string.IsNullOrWhiteSpace(userIp))
            throw new ArgumentException("UserIp cannot be null or empty", nameof(userIp));
        if (string.IsNullOrWhiteSpace(userAgent))
            throw new ArgumentException("UserAgent cannot be null or empty", nameof(userAgent));

        UserId = userId;
        Action = action;
        Resource = resource;
        UserIp = userIp;
        UserAgent = userAgent;
        Success = success;
        ErrorMessage = errorMessage;
        DurationMs = durationMs;
        CorrelationId = correlationId;
        ServiceName = serviceName;
        Severity = severity;

        // Serialize additional data
        AdditionalDataJson = JsonSerializer.Serialize(additionalData ?? new Dictionary<string, object>());

        CreatedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
    }

    /// <summary>
    /// Creates a successful audit log entry
    /// </summary>
    public static AuditLog CreateSuccess(
        string userId,
        string action,
        string resource,
        string userIp,
        string userAgent,
        Dictionary<string, object>? additionalData = null,
        long? durationMs = null,
        string? correlationId = null,
        string serviceName = "Unknown")
    {
        return new AuditLog(
            userId,
            action,
            resource,
            userIp,
            userAgent,
            additionalData ?? new Dictionary<string, object>(),
            true,
            null,
            durationMs,
            correlationId,
            serviceName,
            AuditSeverity.Information);
    }

    /// <summary>
    /// Creates a failed audit log entry
    /// </summary>
    public static AuditLog CreateFailure(
        string userId,
        string action,
        string resource,
        string userIp,
        string userAgent,
        string errorMessage,
        Dictionary<string, object>? additionalData = null,
        long? durationMs = null,
        string? correlationId = null,
        string serviceName = "Unknown",
        AuditSeverity severity = AuditSeverity.Error)
    {
        if (string.IsNullOrWhiteSpace(errorMessage))
            throw new ArgumentException("ErrorMessage cannot be null or empty for failed audit log", nameof(errorMessage));

        return new AuditLog(
            userId,
            action,
            resource,
            userIp,
            userAgent,
            additionalData ?? new Dictionary<string, object>(),
            false,
            errorMessage,
            durationMs,
            correlationId,
            serviceName,
            severity);
    }

    /// <summary>
    /// Creates a system audit log entry
    /// </summary>
    public static AuditLog CreateSystem(
        string action,
        string resource,
        Dictionary<string, object>? additionalData = null,
        bool success = true,
        string? errorMessage = null,
        AuditSeverity severity = AuditSeverity.Information)
    {
        return new AuditLog(
            "system",
            action,
            resource,
            "127.0.0.1",
            "System",
            additionalData ?? new Dictionary<string, object>(),
            success,
            errorMessage,
            null,
            null,
            "AuditService",
            severity);
    }

    /// <summary>
    /// Creates an anonymous audit log entry
    /// </summary>
    public static AuditLog CreateAnonymous(
        string action,
        string resource,
        string userIp,
        string userAgent,
        Dictionary<string, object>? additionalData = null,
        bool success = true,
        string? errorMessage = null,
        AuditSeverity severity = AuditSeverity.Information)
    {
        return new AuditLog(
            "anonymous",
            action,
            resource,
            userIp,
            userAgent,
            additionalData ?? new Dictionary<string, object>(),
            success,
            errorMessage,
            null,
            null,
            "AuditService",
            severity);
    }

    /// <summary>
    /// Marks the audit log as failed with an error message
    /// </summary>
    public void MarkAsFailed(string errorMessage, AuditSeverity severity = AuditSeverity.Error)
    {
        if (string.IsNullOrWhiteSpace(errorMessage))
            throw new ArgumentException("ErrorMessage cannot be null or empty", nameof(errorMessage));

        Success = false;
        ErrorMessage = errorMessage;
        Severity = severity;
        MarkAsUpdated();
    }

    /// <summary>
    /// Marks the audit log as successful
    /// </summary>
    public void MarkAsSuccess()
    {
        Success = true;
        ErrorMessage = null;
        Severity = AuditSeverity.Information;
        MarkAsUpdated();
    }

    /// <summary>
    /// Sets the duration of the operation
    /// </summary>
    public void SetDuration(long durationMs)
    {
        if (durationMs < 0)
            throw new ArgumentException("Duration cannot be negative", nameof(durationMs));

        DurationMs = durationMs;
        MarkAsUpdated();
    }

    /// <summary>
    /// Sets the correlation ID for distributed tracing
    /// </summary>
    public void SetCorrelationId(string correlationId)
    {
        CorrelationId = correlationId;
        MarkAsUpdated();
    }

    /// <summary>
    /// Sets the service name that generated the event
    /// </summary>
    public void SetServiceName(string serviceName)
    {
        if (string.IsNullOrWhiteSpace(serviceName))
            throw new ArgumentException("ServiceName cannot be null or empty", nameof(serviceName));

        ServiceName = serviceName;
        MarkAsUpdated();
    }

    /// <summary>
    /// Sets the severity level of the audit event
    /// </summary>
    public void SetSeverity(AuditSeverity severity)
    {
        Severity = severity;
        MarkAsUpdated();
    }

    /// <summary>
    /// Additional data as a dictionary (deserialized from JSON)
    /// </summary>
    public Dictionary<string, object> AdditionalData
    {
        get
        {
            try
            {
                return JsonSerializer.Deserialize<Dictionary<string, object>>(AdditionalDataJson)
                    ?? new Dictionary<string, object>();
            }
            catch (JsonException)
            {
                // Log the error but don't throw - return empty dictionary
                return new Dictionary<string, object>();
            }
        }
    }

    /// <summary>
    /// Adds additional data to the audit log
    /// </summary>
    public void AddAdditionalData(string key, object value)
    {
        if (string.IsNullOrWhiteSpace(key))
            throw new ArgumentException("Key cannot be null or empty", nameof(key));

        if (value == null)
            throw new ArgumentNullException(nameof(value), "Value cannot be null");

        var currentData = AdditionalData;
        currentData[key] = value;
        AdditionalDataJson = JsonSerializer.Serialize(currentData);
        MarkAsUpdated();
    }

    /// <summary>
    /// Removes additional data from the audit log
    /// </summary>
    public void RemoveAdditionalData(string key)
    {
        if (string.IsNullOrWhiteSpace(key))
            throw new ArgumentException("Key cannot be null or empty", nameof(key));

        var currentData = AdditionalData;
        if (currentData.Remove(key))
        {
            AdditionalDataJson = JsonSerializer.Serialize(currentData);
            MarkAsUpdated();
        }
    }

    /// <summary>
    /// Checks if the audit log is for a system event
    /// </summary>
    public bool IsSystemEvent() => UserId == "system";

    /// <summary>
    /// Checks if the audit log is for an anonymous user
    /// </summary>
    public bool IsAnonymous() => UserId == "anonymous";

    /// <summary>
    /// Gets the display name for the user (system, anonymous, or actual user ID)
    /// </summary>
    public string GetUserDisplayName()
    {
        return UserId switch
        {
            "system" => "System",
            "anonymous" => "Anonymous",
            _ => UserId
        };
    }

    /// <summary>
    /// Validates the audit log entry
    /// </summary>
    public override bool IsValid()
    {
        return !string.IsNullOrWhiteSpace(Id) &&
               !string.IsNullOrWhiteSpace(UserId) &&
               !string.IsNullOrWhiteSpace(Action) &&
               !string.IsNullOrWhiteSpace(Resource) &&
               !string.IsNullOrWhiteSpace(UserIp) &&
               !string.IsNullOrWhiteSpace(UserAgent) &&
               !string.IsNullOrWhiteSpace(ServiceName) &&
               CreatedAt <= DateTime.UtcNow &&
               Enum.IsDefined(typeof(AuditSeverity), Severity);
    }

    /// <summary>
    /// Gets a summary of the audit log for display purposes
    /// </summary>
    public string GetSummary()
    {
        var status = Success ? "SUCCESS" : "FAILED";
        var user = GetUserDisplayName();
        var duration = DurationMs.HasValue ? $" in {DurationMs}ms" : "";
        return $"{Action} on {Resource} by {user} - {status}{duration}";
    }

    /// <summary>
    /// Gets a detailed description of the audit log
    /// </summary>
    public string GetDetailedDescription()
    {
        var summary = GetSummary();
        var severity = Severity.ToString().ToUpper();
        
        if (!string.IsNullOrEmpty(ErrorMessage))
        {
            return $"{summary} | Severity: {severity} | Error: {ErrorMessage}";
        }
        
        return $"{summary} | Severity: {severity}";
    }

    /// <summary>
    /// Checks if this audit log represents a security-related event
    /// </summary>
    public bool IsSecurityEvent()
    {
        return Severity == AuditSeverity.Error || 
               Severity == AuditSeverity.Critical ||
               !Success;
    }

    /// <summary>
    /// Checks if this audit log requires immediate attention
    /// </summary>
    public bool RequiresAttention()
    {
        return Severity == AuditSeverity.Critical ||
               (Severity == AuditSeverity.Error && !Success);
    }

    /// <summary>
    /// Gets the age of the audit log in days
    /// </summary>
    public double GetAgeInDays()
    {
        return (DateTime.UtcNow - CreatedAt).TotalDays;
    }

    /// <summary>
    /// Creates a shallow copy of the audit log for reporting purposes
    /// </summary>

    public new AuditLog ShallowCopy()
    {
        return (AuditLog)MemberwiseClone();
    }

    /// <summary>
    /// Updates the audit log timestamp (used for batch operations)
    /// </summary>
    public void UpdateTimestamp()
    {
        MarkAsUpdated();
    }

    protected override IEnumerable<object> GetEqualityComponents()
    {
        yield return Id;
        yield return UserId;
        yield return Action;
        yield return Resource;
        yield return CreatedAt;
    }

    public override string ToString()
    {
        return $"{GetType().Name} [Id={Id}, Action={Action}, User={GetUserDisplayName()}, Success={Success}]";
    }


}

---- File: AuditService.Domain\Enums\AuditAction.cs ----
using System.ComponentModel;

namespace AuditService.Domain.Enums;

// QUITAMOS el enum AuditSeverity de aquí - se movió a Shared

/// <summary>
/// Common audit action types
/// </summary>
public static class AuditActions
{
    // Authentication actions
    public const string Login = "LOGIN";
    public const string Register = "REGISTER";
    public const string Logout = "LOGOUT";
    public const string RefreshToken = "REFRESH_TOKEN";
    public const string ForgotPassword = "FORGOT_PASSWORD";
    public const string ResetPassword = "RESET_PASSWORD";
    public const string VerifyEmail = "VERIFY_EMAIL";
    public const string ChangePassword = "CHANGE_PASSWORD";

    // User management actions
    public const string CreateUser = "CREATE_USER";
    public const string UpdateUser = "UPDATE_USER";
    public const string DeleteUser = "DELETE_USER";
    public const string EnableUser = "ENABLE_USER";
    public const string DisableUser = "DISABLE_USER";
    public const string LockUser = "LOCK_USER";
    public const string UnlockUser = "UNLOCK_USER";

    // Profile actions
    public const string UpdateProfile = "UPDATE_PROFILE";
    public const string UploadAvatar = "UPLOAD_AVATAR";
    public const string DeleteAvatar = "DELETE_AVATAR";

    // Two-factor authentication actions
    public const string Enable2FA = "ENABLE_2FA";
    public const string Disable2FA = "DISABLE_2FA";
    public const string Verify2FA = "VERIFY_2FA";
    public const string GenerateRecoveryCodes = "GENERATE_RECOVERY_CODES";
    public const string UseRecoveryCode = "USE_RECOVERY_CODE";

    // External authentication actions
    public const string ExternalLogin = "EXTERNAL_LOGIN";
    public const string LinkExternalAccount = "LINK_EXTERNAL_ACCOUNT";
    public const string UnlinkExternalAccount = "UNLINK_EXTERNAL_ACCOUNT";

    // Role and permission actions
    public const string CreateRole = "CREATE_ROLE";
    public const string UpdateRole = "UPDATE_ROLE";
    public const string DeleteRole = "DELETE_ROLE";
    public const string AssignRole = "ASSIGN_ROLE";
    public const string RemoveRole = "REMOVE_ROLE";

    // System actions
    public const string SystemStartup = "SYSTEM_STARTUP";
    public const string SystemShutdown = "SYSTEM_SHUTDOWN";
    public const string Cleanup = "CLEANUP";
    public const string Backup = "BACKUP";
    public const string Restore = "RESTORE";

    // Audit-specific actions
    public const string ViewAuditLogs = "VIEW_AUDIT_LOGS";
    public const string ExportAuditLogs = "EXPORT_AUDIT_LOGS";
    public const string PurgeAuditLogs = "PURGE_AUDIT_LOGS";

    // Security actions
    public const string FailedLoginAttempt = "FAILED_LOGIN_ATTEMPT";
    public const string AccountLocked = "ACCOUNT_LOCKED";
    public const string SuspiciousActivity = "SUSPICIOUS_ACTIVITY";
    public const string PasswordSprayAttempt = "PASSWORD_SPRAY_ATTEMPT";
    public const string BruteForceAttempt = "BRUTE_FORCE_ATTEMPT";

    // API actions
    public const string ApiCall = "API_CALL";
    public const string RateLimitExceeded = "RATE_LIMIT_EXCEEDED";
    public const string InvalidToken = "INVALID_TOKEN";
    public const string TokenExpired = "TOKEN_EXPIRED";

    // Notification actions
    public const string SendEmail = "SEND_EMAIL";
    public const string SendSMS = "SEND_SMS";
    public const string SendPush = "SEND_PUSH";

    // Business-specific actions
    public const string CreateDeal = "CREATE_DEAL";
    public const string UpdateDeal = "UPDATE_DEAL";
    public const string DeleteDeal = "DELETE_DEAL";
    public const string ViewDeal = "VIEW_DEAL";
    public const string SearchDeals = "SEARCH_DEALS";
    public const string ExportDeals = "EXPORT_DEALS";

    // Vehicle management actions
    public const string CreateVehicle = "CREATE_VEHICLE";
    public const string UpdateVehicle = "UPDATE_VEHICLE";
    public const string DeleteVehicle = "DELETE_VEHICLE";
    public const string ImportVehicles = "IMPORT_VEHICLES";
    public const string ExportVehicles = "EXPORT_VEHICLES";

    // Customer management actions
    public const string CreateCustomer = "CREATE_CUSTOMER";
    public const string UpdateCustomer = "UPDATE_CUSTOMER";
    public const string DeleteCustomer = "DELETE_CUSTOMER";
    public const string ImportCustomers = "IMPORT_CUSTOMERS";
    public const string ExportCustomers = "EXPORT_CUSTOMERS";

    // File operations
    public const string UploadFile = "UPLOAD_FILE";
    public const string DownloadFile = "DOWNLOAD_FILE";
    public const string DeleteFile = "DELETE_FILE";
    public const string ViewFile = "VIEW_FILE";

    // Report actions
    public const string GenerateReport = "GENERATE_REPORT";
    public const string ViewReport = "VIEW_REPORT";
    public const string ExportReport = "EXPORT_REPORT";
    public const string ScheduleReport = "SCHEDULE_REPORT";

    // Settings actions
    public const string UpdateSettings = "UPDATE_SETTINGS";
    public const string ViewSettings = "VIEW_SETTINGS";
    public const string ResetSettings = "RESET_SETTINGS";

    // Integration actions
    public const string ApiIntegration = "API_INTEGRATION";
    public const string WebhookCall = "WEBHOOK_CALL";
    public const string SyncData = "SYNC_DATA";
    public const string ImportData = "IMPORT_DATA";
    public const string ExportData = "EXPORT_DATA";
}

/// <summary>
/// Common audit resource types
/// </summary>
public static class AuditResources
{
    public const string User = "USER";
    public const string Auth = "AUTH";
    public const string Token = "TOKEN";
    public const string TwoFactor = "TWO_FACTOR";
    public const string ExternalAuth = "EXTERNAL_AUTH";
    public const string Role = "ROLE";
    public const string Permission = "PERMISSION";
    public const string System = "SYSTEM";
    public const string Audit = "AUDIT";
    public const string Security = "SECURITY";
    public const string API = "API";
    public const string Notification = "NOTIFICATION";
    public const string Profile = "PROFILE";

    // Business-specific resources
    public const string Deal = "DEAL";
    public const string Vehicle = "VEHICLE";
    public const string Customer = "CUSTOMER";
    public const string Inventory = "INVENTORY";
    public const string Sales = "SALES";
    public const string Finance = "FINANCE";

    // File resources
    public const string File = "FILE";
    public const string Document = "DOCUMENT";
    public const string Image = "IMAGE";
    public const string Report = "REPORT";

    // Settings resources
    public const string Settings = "SETTINGS";
    public const string Configuration = "CONFIGURATION";

    // Integration resources
    public const string Integration = "INTEGRATION";
    public const string Webhook = "WEBHOOK";
    public const string Data = "DATA";
}

---- File: AuditService.Domain\Interfaces\IUnitOfWork.cs ----
namespace AuditService.Domain.Interfaces;

public interface IUnitOfWork
{
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
    Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default);
}

---- File: AuditService.Domain\Interfaces\Repositories\IAuditLogRepository.cs ----
using AuditService.Domain.Entities;

namespace AuditService.Domain.Interfaces.Repositories;

/// <summary>
/// Repository interface for audit log operations
/// </summary>
public interface IAuditLogRepository
{
    /// <summary>
    /// Gets an audit log by its unique identifier
    /// </summary>
    Task<AuditLog?> GetByIdAsync(string id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all audit logs for a specific user
    /// </summary>
    Task<IEnumerable<AuditLog>> GetByUserIdAsync(string userId, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets audit logs by action type
    /// </summary>
    Task<IEnumerable<AuditLog>> GetByActionAsync(string action, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets audit logs by resource type
    /// </summary>
    Task<IEnumerable<AuditLog>> GetByResourceAsync(string resource, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets audit logs within a specific date range
    /// </summary>
    Task<IEnumerable<AuditLog>> GetByDateRangeAsync(DateTime fromDate, DateTime toDate, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets audit logs by severity level
    /// </summary>
    Task<IEnumerable<AuditLog>> GetBySeverityAsync(string severity, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets paginated audit logs with filtering and sorting
    /// </summary>
    Task<(IEnumerable<AuditLog> items, int totalCount)> GetPaginatedAsync(
        string? userId = null,
        string? action = null,
        string? resource = null,
        DateTime? fromDate = null,
        DateTime? toDate = null,
        int page = 1,
        int pageSize = 50,
        string? sortBy = null,
        bool sortDescending = true);

    /// <summary>
    /// Adds a new audit log entry
    /// </summary>
    Task AddAsync(AuditLog auditLog, CancellationToken cancellationToken = default);

    /// <summary>
    /// Adds multiple audit log entries in a batch
    /// </summary>
    Task AddRangeAsync(IEnumerable<AuditLog> auditLogs, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing audit log entry
    /// </summary>
    Task UpdateAsync(AuditLog auditLog, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the total count of audit logs
    /// </summary>
    Task<int> GetTotalCountAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets statistics about audit logs
    /// </summary>
    Task<AuditStatistics> GetStatisticsAsync(DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the most frequent actions
    /// </summary>
    Task<IEnumerable<ActionFrequency>> GetTopActionsAsync(int top = 10, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the most active users
    /// </summary>
    Task<IEnumerable<UserActivity>> GetTopUsersAsync(int top = 10, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes audit logs older than the specified date
    /// </summary>
    Task<int> DeleteOldLogsAsync(DateTime olderThan, CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if an audit log exists with the given ID
    /// </summary>
    Task<bool> ExistsAsync(string id, CancellationToken cancellationToken = default);
}

/// <summary>
/// Statistics about audit logs
/// </summary>
public class AuditStatistics
{
    public int TotalLogs { get; set; }
    public int SuccessfulLogs { get; set; }
    public int FailedLogs { get; set; }
    public int SystemLogs { get; set; }
    public int UserLogs { get; set; }
    public int AnonymousLogs { get; set; }
    public double SuccessRate => TotalLogs > 0 ? (SuccessfulLogs * 100.0) / TotalLogs : 0;
    public DateTime? FirstLogDate { get; set; }
    public DateTime? LastLogDate { get; set; }
    public Dictionary<string, int> LogsBySeverity { get; set; } = new();
    public Dictionary<string, int> LogsByService { get; set; } = new();
    public Dictionary<string, int> LogsByAction { get; set; } = new();
}

/// <summary>
/// Action frequency statistics
/// </summary>
public class ActionFrequency
{
    public string Action { get; set; } = string.Empty;
    public int Count { get; set; }
    public int SuccessCount { get; set; }
    public int FailureCount { get; set; }
    public double SuccessRate => Count > 0 ? (SuccessCount * 100.0) / Count : 0;
}

/// <summary>
/// User activity statistics
/// </summary>
public class UserActivity
{
    public string UserId { get; set; } = string.Empty;
    public int TotalActions { get; set; }
    public int SuccessfulActions { get; set; }
    public int FailedActions { get; set; }
    public DateTime FirstActivity { get; set; }
    public DateTime LastActivity { get; set; }
    public double SuccessRate => TotalActions > 0 ? (SuccessfulActions * 100.0) / TotalActions : 0;
    public List<string> MostFrequentActions { get; set; } = new();
}

---- File: AuditService.Infrastructure\AuditService.Infrastructure.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <!-- Entity Framework -->
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.11" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.2" />

    <!-- RabbitMQ -->
    <PackageReference Include="RabbitMQ.Client" Version="6.8.1" />

    <!-- Health Checks -->
    <PackageReference Include="AspNetCore.HealthChecks.UI" Version="8.0.2" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.Client" Version="8.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.UI.InMemory.Storage" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="8.0.11" />

    <!-- Caching -->
    <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" Version="8.0.11" />

    <!-- Configuration -->
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />

    <!-- Serilog -->
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="5.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AuditService.Application\AuditService.Application.csproj" />
    <ProjectReference Include="..\AuditService.Domain\AuditService.Domain.csproj" />
    <ProjectReference Include="..\AuditService.Shared\AuditService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: AuditService.Infrastructure\Extensions\ServiceCollectionExtensions.cs ----
using AuditService.Domain.Interfaces;
using AuditService.Domain.Interfaces.Repositories;
using AuditService.Infrastructure.Persistence;
using AuditService.Infrastructure.Persistence.Repositories;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;


namespace AuditService.Infrastructure.Extensions;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
    {
        // Database Context
        services.AddDbContext<AuditDbContext>(options =>
            options.UseNpgsql(
                configuration.GetConnectionString("DefaultConnection"),
                sqlOptions => sqlOptions.MigrationsAssembly(typeof(AuditDbContext).Assembly.FullName)));

        // Repositories
        services.AddScoped<IAuditLogRepository, AuditLogRepository>();
        services.AddScoped<IUnitOfWork, UnitOfWork>();

        return services;
    }
}

---- File: AuditService.Infrastructure\HealthChecks\ApplicationHealthCheck.cs ----
using Microsoft.Extensions.Diagnostics.HealthChecks;

namespace AuditService.Infrastructure.HealthChecks;

public class ApplicationHealthCheck : IHealthCheck
{
    private readonly IHttpClientFactory _httpClientFactory;

    public ApplicationHealthCheck(IHttpClientFactory httpClientFactory)
    {
        _httpClientFactory = httpClientFactory;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            // Verificar que la aplicaci�n puede hacer requests HTTP b�sicos
            var client = _httpClientFactory.CreateClient();
            var response = await client.GetAsync("http://google.com", cancellationToken);

            if (response.IsSuccessStatusCode)
            {
                return HealthCheckResult.Healthy("Application is healthy and can make external requests");
            }

            return HealthCheckResult.Degraded($"External request failed with status: {response.StatusCode}");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Application cannot make external requests", ex);
        }
    }
}

---- File: AuditService.Infrastructure\HealthChecks\DatabaseHealthCheck.cs ----
using AuditService.Infrastructure.Persistence;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Microsoft.EntityFrameworkCore;

namespace AuditService.Infrastructure.HealthChecks;

public class DatabaseHealthCheck : IHealthCheck
{
    private readonly AuditDbContext _dbContext;

    public DatabaseHealthCheck(AuditDbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            // Verificar que podemos conectar a la base de datos
            var canConnect = await _dbContext.Database.CanConnectAsync(cancellationToken);

            if (canConnect)
            {
                // Verificar que podemos ejecutar una consulta simple
                var auditLogsCount = await _dbContext.AuditLogs.CountAsync(cancellationToken);
                return HealthCheckResult.Healthy($"Database is healthy. Total audit logs: {auditLogsCount}");
            }

            return HealthCheckResult.Unhealthy("Cannot connect to database");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Database health check failed", ex);
        }
    }
}

---- File: AuditService.Infrastructure\HealthChecks\RedisHealthCheck.cs ----
using Microsoft.Extensions.Caching.Distributed;
using Microsoft.Extensions.Diagnostics.HealthChecks;

namespace AuditService.Infrastructure.HealthChecks;

public class RedisHealthCheck : IHealthCheck
{
    private readonly IDistributedCache _cache;

    public RedisHealthCheck(IDistributedCache cache)
    {
        _cache = cache;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            // Verificar que Redis est� respondiendo
            var testKey = "health_check_test";
            var testValue = DateTime.UtcNow.ToString("O");

            await _cache.SetStringAsync(testKey, testValue, new DistributedCacheEntryOptions
            {
                AbsoluteExpirationRelativeToNow = TimeSpan.FromSeconds(30)
            }, cancellationToken);

            var retrievedValue = await _cache.GetStringAsync(testKey, cancellationToken);

            if (retrievedValue == testValue)
            {
                await _cache.RemoveAsync(testKey, cancellationToken);
                return HealthCheckResult.Healthy("Redis is healthy and responding correctly");
            }

            return HealthCheckResult.Unhealthy("Redis returned incorrect value");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Redis health check failed", ex);
        }
    }
}

---- File: AuditService.Infrastructure\Middleware\ErrorHandlingMiddleware.cs ----
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using System.Net;
using System.Text.Json;

namespace AuditService.Infrastructure.Middleware;

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public ErrorHandlingMiddleware(RequestDelegate next, ILogger<ErrorHandlingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var response = context.Response;
        response.ContentType = "application/json";

        var errorResponse = new
        {
            Success = false,
            Message = "An unexpected error occurred",
            CorrelationId = context.TraceIdentifier
        };

        response.StatusCode = exception switch
        {
            UnauthorizedAccessException => (int)HttpStatusCode.Unauthorized,
            ArgumentException or InvalidOperationException => (int)HttpStatusCode.BadRequest,
            KeyNotFoundException => (int)HttpStatusCode.NotFound,
            _ => (int)HttpStatusCode.InternalServerError
        };

        var json = JsonSerializer.Serialize(errorResponse);
        await response.WriteAsync(json);
    }
}

---- File: AuditService.Infrastructure\Persistence\AuditDbContext.cs ----
using AuditService.Domain.Entities;
using AuditService.Infrastructure.Persistence.EntityConfigurations;
using Microsoft.EntityFrameworkCore;

namespace AuditService.Infrastructure.Persistence;

public class AuditDbContext : DbContext
{
    public AuditDbContext(DbContextOptions<AuditDbContext> options) : base(options)
    {
    }

    public DbSet<AuditLog> AuditLogs => Set<AuditLog>();

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.ApplyConfiguration(new AuditLogConfiguration());

        // Configuraciones adicionales
        modelBuilder.HasDefaultSchema("audit");
    }

}

---- File: AuditService.Infrastructure\Persistence\EntityConfigurations\AuditLogConfiguration.cs ----
using AuditService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace AuditService.Infrastructure.Persistence.EntityConfigurations;

public class AuditLogConfiguration : IEntityTypeConfiguration<AuditLog>
{
    public void Configure(EntityTypeBuilder<AuditLog> builder)
    {
        builder.ToTable("audit_logs");

        builder.HasKey(x => x.Id);
        builder.Property(x => x.Id)
            .ValueGeneratedOnAdd();

        builder.Property(x => x.UserId)
            .IsRequired()
            .HasMaxLength(255);

        builder.Property(x => x.Action)
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(x => x.Resource)
            .IsRequired()
            .HasMaxLength(255);

        builder.Property(x => x.UserIp)
            .IsRequired()
            .HasMaxLength(45); // Soporta IPv6

        builder.Property(x => x.UserAgent)
            .HasMaxLength(500);

        builder.Property(x => x.CorrelationId)
            .HasMaxLength(100);

        builder.Property(x => x.ServiceName)
            .IsRequired()
            .HasMaxLength(100);

        // Configuraci�n para AdditionalDataJson (JSON)
        builder.Property(x => x.AdditionalDataJson)
            .HasColumnType("jsonb");

        builder.Property(x => x.CreatedAt)
            .IsRequired();

        builder.Property(x => x.UpdatedAt);

        // �ndices para mejor performance
        builder.HasIndex(x => x.UserId);
        builder.HasIndex(x => x.Action);
        builder.HasIndex(x => x.Resource);
        builder.HasIndex(x => x.ServiceName);
        builder.HasIndex(x => x.CreatedAt);
        builder.HasIndex(x => new { x.UserId, x.CreatedAt });
        builder.HasIndex(x => new { x.Action, x.CreatedAt });
        builder.HasIndex(x => new { x.ServiceName, x.CreatedAt });
        builder.HasIndex(x => x.Success);
        builder.HasIndex(x => x.Severity);
    }
}

---- File: AuditService.Infrastructure\Persistence\Repositories\AuditLogRepository.cs ----
using AuditService.Domain.Entities;
using AuditService.Domain.Interfaces.Repositories;
using AuditService.Infrastructure.Persistence;
using AuditService.Shared.Enums;
using Microsoft.EntityFrameworkCore;
using System.Linq.Expressions;

namespace AuditService.Infrastructure.Persistence.Repositories;

public class AuditLogRepository : IAuditLogRepository
{
    private readonly AuditDbContext _context;

    public AuditLogRepository(AuditDbContext context)
    {
        _context = context;
    }

    public async Task<AuditLog?> GetByIdAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _context.AuditLogs
            .FirstOrDefaultAsync(x => x.Id == id, cancellationToken);
    }

    public async Task<IEnumerable<AuditLog>> GetByUserIdAsync(string userId, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default)
    {
        var query = _context.AuditLogs.Where(x => x.UserId == userId);

        if (fromDate.HasValue)
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        if (toDate.HasValue)
            query = query.Where(x => x.CreatedAt <= toDate.Value);

        return await query.OrderByDescending(x => x.CreatedAt).ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<AuditLog>> GetByActionAsync(string action, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default)
    {
        var query = _context.AuditLogs.Where(x => x.Action == action);

        if (fromDate.HasValue)
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        if (toDate.HasValue)
            query = query.Where(x => x.CreatedAt <= toDate.Value);

        return await query.OrderByDescending(x => x.CreatedAt).ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<AuditLog>> GetByResourceAsync(string resource, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default)
    {
        var query = _context.AuditLogs.Where(x => x.Resource == resource);

        if (fromDate.HasValue)
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        if (toDate.HasValue)
            query = query.Where(x => x.CreatedAt <= toDate.Value);

        return await query.OrderByDescending(x => x.CreatedAt).ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<AuditLog>> GetByDateRangeAsync(DateTime fromDate, DateTime toDate, CancellationToken cancellationToken = default)
    {
        return await _context.AuditLogs
            .Where(x => x.CreatedAt >= fromDate && x.CreatedAt <= toDate)
            .OrderByDescending(x => x.CreatedAt)
            .ToListAsync(cancellationToken);
    }

    public async Task<IEnumerable<AuditLog>> GetBySeverityAsync(string severity, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default)
    {
        var query = _context.AuditLogs.AsQueryable();

        // Convert string severity to enum
        if (Enum.TryParse<AuditSeverity>(severity, true, out var severityEnum))
        {
            query = query.Where(x => x.Severity == severityEnum);
        }

        if (fromDate.HasValue)
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        if (toDate.HasValue)
            query = query.Where(x => x.CreatedAt <= toDate.Value);

        return await query.OrderByDescending(x => x.CreatedAt).ToListAsync(cancellationToken);
    }

    public async Task<(IEnumerable<AuditLog> items, int totalCount)> GetPaginatedAsync(
        string? userId = null,
        string? action = null,
        string? resource = null,
        DateTime? fromDate = null,
        DateTime? toDate = null,
        int page = 1,
        int pageSize = 50,
        string? sortBy = null,
        bool sortDescending = true)
    {
        var query = _context.AuditLogs.AsQueryable();

        // Apply filters
        if (!string.IsNullOrEmpty(userId))
            query = query.Where(x => x.UserId == userId);
        if (!string.IsNullOrEmpty(action))
            query = query.Where(x => x.Action == action);
        if (!string.IsNullOrEmpty(resource))
            query = query.Where(x => x.Resource == resource);
        if (fromDate.HasValue)
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        if (toDate.HasValue)
            query = query.Where(x => x.CreatedAt <= toDate.Value);

        // Get total count
        var totalCount = await query.CountAsync();

        // Apply sorting
        if (!string.IsNullOrEmpty(sortBy))
        {
            query = sortDescending
                ? query.OrderByDescending(GetSortProperty(sortBy))
                : query.OrderBy(GetSortProperty(sortBy));
        }
        else
        {
            query = query.OrderByDescending(x => x.CreatedAt);
        }

        // Apply pagination
        var items = await query
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();

        return (items, totalCount);
    }

    public async Task AddAsync(AuditLog auditLog, CancellationToken cancellationToken = default)
    {
        _context.AuditLogs.Add(auditLog);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task AddRangeAsync(IEnumerable<AuditLog> auditLogs, CancellationToken cancellationToken = default)
    {
        _context.AuditLogs.AddRange(auditLogs);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task UpdateAsync(AuditLog auditLog, CancellationToken cancellationToken = default)
    {
        _context.AuditLogs.Update(auditLog);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task<int> GetTotalCountAsync(CancellationToken cancellationToken = default)
    {
        return await _context.AuditLogs.CountAsync(cancellationToken);
    }

    public async Task<AuditStatistics> GetStatisticsAsync(DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default)
    {
        var query = _context.AuditLogs.AsQueryable();

        if (fromDate.HasValue)
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        if (toDate.HasValue)
            query = query.Where(x => x.CreatedAt <= toDate.Value);

        var totalLogs = await query.CountAsync();
        var successfulLogs = await query.CountAsync(x => x.Success);
        var failedLogs = totalLogs - successfulLogs;

        return new AuditStatistics
        {
            TotalLogs = totalLogs,
            SuccessfulLogs = successfulLogs,
            FailedLogs = failedLogs,
            FirstLogDate = await query.MinAsync(x => (DateTime?)x.CreatedAt),
            LastLogDate = await query.MaxAsync(x => (DateTime?)x.CreatedAt)
        };
    }

    public async Task<IEnumerable<ActionFrequency>> GetTopActionsAsync(int top = 10, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default)
    {
        var query = _context.AuditLogs.AsQueryable();

        if (fromDate.HasValue)
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        if (toDate.HasValue)
            query = query.Where(x => x.CreatedAt <= toDate.Value);

        var topActions = await query
            .GroupBy(x => x.Action)
            .Select(g => new ActionFrequency
            {
                Action = g.Key,
                Count = g.Count(),
                SuccessCount = g.Count(x => x.Success),
                FailureCount = g.Count(x => !x.Success)
            })
            .OrderByDescending(x => x.Count)
            .Take(top)
            .ToListAsync(cancellationToken);

        return topActions;
    }

    public async Task<IEnumerable<UserActivity>> GetTopUsersAsync(int top = 10, DateTime? fromDate = null, DateTime? toDate = null, CancellationToken cancellationToken = default)
    {
        var query = _context.AuditLogs.AsQueryable();

        if (fromDate.HasValue)
            query = query.Where(x => x.CreatedAt >= fromDate.Value);
        if (toDate.HasValue)
            query = query.Where(x => x.CreatedAt <= toDate.Value);

        var topUsers = await query
            .Where(x => x.UserId != "system")
            .GroupBy(x => x.UserId)
            .Select(g => new UserActivity
            {
                UserId = g.Key,
                TotalActions = g.Count(),
                SuccessfulActions = g.Count(x => x.Success),
                FailedActions = g.Count(x => !x.Success),
                FirstActivity = g.Min(x => x.CreatedAt),
                LastActivity = g.Max(x => x.CreatedAt)
            })
            .OrderByDescending(x => x.TotalActions)
            .Take(top)
            .ToListAsync(cancellationToken);

        return topUsers;
    }

    public async Task<int> DeleteOldLogsAsync(DateTime olderThan, CancellationToken cancellationToken = default)
    {
        var logsToDelete = _context.AuditLogs.Where(x => x.CreatedAt < olderThan);
        var count = await logsToDelete.CountAsync(cancellationToken);
        _context.AuditLogs.RemoveRange(logsToDelete);
        await _context.SaveChangesAsync(cancellationToken);
        return count;
    }

    public async Task<bool> ExistsAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _context.AuditLogs
            .AnyAsync(x => x.Id == id, cancellationToken);
    }

    private static Expression<Func<AuditLog, object>> GetSortProperty(string sortBy)
    {
        return sortBy?.ToLower() switch
        {
            "userid" => x => x.UserId,
            "action" => x => x.Action,
            "resource" => x => x.Resource,
            "serviceName" => x => x.ServiceName,
            "severity" => x => x.Severity,
            _ => x => x.CreatedAt
        };
    }
}

---- File: AuditService.Infrastructure\Persistence\Repositories\UnitOfWork.cs ----
using AuditService.Domain.Interfaces;
using AuditService.Infrastructure.Persistence;

namespace AuditService.Infrastructure.Persistence.Repositories;

public class UnitOfWork : IUnitOfWork
{
    private readonly AuditDbContext _context;

    public UnitOfWork(AuditDbContext context)
    {
        _context = context;
    }

    public async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        return await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default)
    {
        await _context.SaveChangesAsync(cancellationToken);
        return true;
    }
}

---- File: AuditService.Infrastructure\Services\Messaging\AuditServiceRabbitMQSettings.cs ----
namespace AuditService.Infrastructure.Services.Messaging;

public class AuditServiceRabbitMQSettings
{
    public string ExchangeName { get; set; } = "audit.events";
    public string QueueName { get; set; } = "audit.service.queue";
    public string RoutingKey { get; set; } = "audit.event.*";
    public string RetryQueueName { get; set; } = "audit.service.queue.retry";
    public int RetryDelayMs { get; set; } = 30000; // 30 segundos
    public int MaxRetryAttempts { get; set; } = 3;
}

---- File: AuditService.Infrastructure\Services\Messaging\RabbitMQAuditConsumer.cs ----
using AuditService.Domain.Interfaces.Repositories;
using AuditService.Domain.Entities;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;
using System.Text.Json;
using AuditService.Shared.AuditMessages;

namespace AuditService.Infrastructure.Services.Messaging;

public class RabbitMQAuditConsumer : BackgroundService
{
    private readonly IConnection _connection;
    private readonly IModel _channel;
    private readonly AuditServiceRabbitMQSettings _settings;
    private readonly ILogger<RabbitMQAuditConsumer> _logger;
    private readonly IServiceProvider _serviceProvider;
    private readonly JsonSerializerOptions _jsonOptions;

    public RabbitMQAuditConsumer(
        IOptions<RabbitMQSettings> rabbitMqSettings,
        IOptions<AuditServiceRabbitMQSettings> auditSettings,
        ILogger<RabbitMQAuditConsumer> logger,
        IServiceProvider serviceProvider)
    {
        _settings = auditSettings.Value;
        _logger = logger;
        _serviceProvider = serviceProvider;
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            PropertyNameCaseInsensitive = true
        };

        var factory = new ConnectionFactory
        {
            HostName = rabbitMqSettings.Value.Host,
            Port = rabbitMqSettings.Value.Port,
            UserName = rabbitMqSettings.Value.Username,
            Password = rabbitMqSettings.Value.Password,
            VirtualHost = rabbitMqSettings.Value.VirtualHost,
            DispatchConsumersAsync = true
        };

        _connection = factory.CreateConnection();
        _channel = _connection.CreateModel();

        ConfigureMessagingTopology();
    }

    private void ConfigureMessagingTopology()
    {
        _channel.ExchangeDeclare(
            exchange: _settings.ExchangeName,
            type: ExchangeType.Topic,
            durable: true,
            autoDelete: false);

        _channel.QueueDeclare(
            queue: _settings.QueueName,
            durable: true,
            exclusive: false,
            autoDelete: false,
            arguments: null);

        _channel.QueueBind(
            queue: _settings.QueueName,
            exchange: _settings.ExchangeName,
            routingKey: _settings.RoutingKey);

        _channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);
    }

    protected override Task ExecuteAsync(CancellationToken stoppingToken)
    {
        stoppingToken.ThrowIfCancellationRequested();

        var consumer = new AsyncEventingBasicConsumer(_channel);

        consumer.Received += async (model, ea) =>
        {
            var body = ea.Body.ToArray();
            var message = Encoding.UTF8.GetString(body);

            try
            {
                await ProcessMessageAsync(message, ea, stoppingToken);
                _channel.BasicAck(ea.DeliveryTag, multiple: false);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing audit event message");
                _channel.BasicNack(ea.DeliveryTag, multiple: false, requeue: false);
            }
        };

        _channel.BasicConsume(
            queue: _settings.QueueName,
            autoAck: false,
            consumer: consumer);

        _logger.LogInformation("RabbitMQ Audit Consumer started listening on queue: {QueueName}", _settings.QueueName);

        return Task.CompletedTask;
    }

    private async Task ProcessMessageAsync(string message, BasicDeliverEventArgs ea, CancellationToken cancellationToken)
    {
        using var scope = _serviceProvider.CreateScope();
        var auditLogRepository = scope.ServiceProvider.GetRequiredService<IAuditLogRepository>();

        try
        {
            var auditEvent = JsonSerializer.Deserialize<AuditEvent>(message, _jsonOptions);

            if (auditEvent == null)
            {
                _logger.LogWarning("Received null or invalid audit event message");
                return;
            }

            // Crear AuditLog usando los m�todos de creaci�n
            AuditLog auditLog;

            if (auditEvent.Success)
            {
                auditLog = AuditLog.CreateSuccess(
                    auditEvent.UserId,
                    auditEvent.Action,
                    auditEvent.Resource,
                    auditEvent.UserIp,
                    auditEvent.UserAgent,
                    auditEvent.AdditionalData,
                    auditEvent.DurationMs,
                    auditEvent.CorrelationId,
                    auditEvent.ServiceName
                );
            }
            else
            {
                auditLog = AuditLog.CreateFailure(
                    auditEvent.UserId,
                    auditEvent.Action,
                    auditEvent.Resource,
                    auditEvent.UserIp,
                    auditEvent.UserAgent,
                    auditEvent.ErrorMessage ?? "Unknown error",
                    auditEvent.AdditionalData,
                    auditEvent.DurationMs,
                    auditEvent.CorrelationId,
                    auditEvent.ServiceName,
                    auditEvent.Severity
                );
            }

            await auditLogRepository.AddAsync(auditLog, cancellationToken);

            _logger.LogInformation(
                "Successfully processed audit event: {Action} for user {UserId}",
                auditEvent.Action, auditEvent.UserId);
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "Failed to deserialize audit event message");
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to process audit event message");
            throw;
        }
    }

    public override void Dispose()
    {
        _channel?.Close();
        _channel?.Dispose();
        _connection?.Close();
        _connection?.Dispose();
        base.Dispose();
    }
}

---- File: AuditService.Infrastructure\Services\Messaging\RabbitMQAuditProducer.cs ----
using AuditService.Shared.AuditMessages;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using System.Text;
using System.Text.Json;

namespace AuditService.Infrastructure.Services.Messaging;

public class RabbitMQAuditProducer : IAuditEventProducer, IDisposable
{
    private readonly IConnection _connection;
    private readonly IModel _channel;
    private readonly AuditServiceRabbitMQSettings _settings;
    private readonly ILogger<RabbitMQAuditProducer> _logger;
    private readonly JsonSerializerOptions _jsonOptions;

    public RabbitMQAuditProducer(
        IOptions<RabbitMQSettings> rabbitMqSettings,
        IOptions<AuditServiceRabbitMQSettings> auditSettings,
        ILogger<RabbitMQAuditProducer> logger)
    {
        _settings = auditSettings.Value;
        _logger = logger;
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };

        var factory = new ConnectionFactory
        {
            HostName = rabbitMqSettings.Value.Host,
            Port = rabbitMqSettings.Value.Port,
            UserName = rabbitMqSettings.Value.Username,
            Password = rabbitMqSettings.Value.Password,
            VirtualHost = rabbitMqSettings.Value.VirtualHost
        };

        try
        {
            _connection = factory.CreateConnection();
            _channel = _connection.CreateModel();

            ConfigureMessagingTopology();
            _logger.LogInformation("RabbitMQ Audit Producer initialized successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize RabbitMQ Audit Producer");
            throw;
        }
    }

    private void ConfigureMessagingTopology()
    {
        _channel.ExchangeDeclare(
            exchange: _settings.ExchangeName,
            type: ExchangeType.Topic,
            durable: true,
            autoDelete: false);

        _channel.QueueDeclare(
            queue: _settings.QueueName,
            durable: true,
            exclusive: false,
            autoDelete: false,
            arguments: null);

        _channel.QueueBind(
            queue: _settings.QueueName,
            exchange: _settings.ExchangeName,
            routingKey: _settings.RoutingKey);
    }

    public Task PublishAuditEventAsync(AuditEvent auditEvent)
    {
        try
        {
            var message = JsonSerializer.Serialize(auditEvent, _jsonOptions);
            var body = Encoding.UTF8.GetBytes(message);

            var properties = _channel.CreateBasicProperties();
            properties.Persistent = true;
            properties.ContentType = "application/json";
            properties.MessageId = auditEvent.Id.ToString();
            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());

            _channel.BasicPublish(
                exchange: _settings.ExchangeName,
                routingKey: GetRoutingKey(auditEvent),
                basicProperties: properties,
                body: body);

            _logger.LogInformation(
                "Audit event published: {Action} for user {UserId}",
                auditEvent.Action, auditEvent.UserId);

            return Task.CompletedTask;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to publish audit event: {Action}", auditEvent.Action);
            throw;
        }
    }

    private string GetRoutingKey(AuditEvent auditEvent)
    {
        return $"audit.event.{auditEvent.Action.ToLower()}";
    }

    public void Dispose()
    {
        _channel?.Close();
        _channel?.Dispose();
        _connection?.Close();
        _connection?.Dispose();
        GC.SuppressFinalize(this);
    }
}

---- File: AuditService.Infrastructure\Services\Messaging\RabbitMQSettings.cs ----
namespace AuditService.Infrastructure.Services.Messaging;

public class RabbitMQSettings
{
    public string Host { get; set; } = "localhost";
    public int Port { get; set; } = 5672;
    public string Username { get; set; } = "guest";
    public string Password { get; set; } = "guest";
    public string VirtualHost { get; set; } = "/";
}

---- File: AuditService.Shared\ApiResponse.cs ----
using System.Text.Json;

namespace AuditService.Shared;

/// <summary>
/// Generic wrapper for API responses
/// </summary>
/// <typeparam name="T">Type of the data payload</typeparam>
public class ApiResponse<T>
{
    /// <summary>Indicates if the operation was successful</summary>
    public bool Success { get; set; }

    /// <summary>Data returned when Success is true</summary>
    public T? Data { get; set; }

    /// <summary>Error message when Success is false</summary>
    public string? Error { get; set; }

    /// <summary>Additional metadata about the response</summary>
    public Dictionary<string, object>? Metadata { get; set; }

    /// <summary>Timestamp when the response was generated</summary>
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    /// <summary>Creates a successful response with the provided data</summary>
    public static ApiResponse<T> Ok(T data, Dictionary<string, object>? metadata = null)
    {
        return new ApiResponse<T>
        {
            Success = true,
            Data = data,
            Metadata = metadata,
            Timestamp = DateTime.UtcNow
        };
    }

    /// <summary>Creates a failed response with the provided error message</summary>
    public static ApiResponse<T> Fail(string errorMessage, Dictionary<string, object>? metadata = null)
    {
        return new ApiResponse<T>
        {
            Success = false,
            Error = errorMessage,
            Metadata = metadata,
            Timestamp = DateTime.UtcNow
        };
    }

    /// <summary>Creates a failed response with validation errors</summary>
    public static ApiResponse<T> ValidationFail(Dictionary<string, string[]> errors)
    {
        return new ApiResponse<T>
        {
            Success = false,
            Error = "Validation failed",
            Metadata = new Dictionary<string, object> { ["validationErrors"] = errors },
            Timestamp = DateTime.UtcNow
        };
    }
}

/// <summary>
/// Non-generic API response for void operations
/// </summary>
public class ApiResponse
{
    /// <summary>Indicates if the operation was successful</summary>
    public bool Success { get; set; }

    /// <summary>Error message when Success is false</summary>
    public string? Error { get; set; }

    /// <summary>Additional metadata about the response</summary>
    public Dictionary<string, object>? Metadata { get; set; }

    /// <summary>Timestamp when the response was generated</summary>
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    /// <summary>Creates a successful response</summary>
    public static ApiResponse Ok(Dictionary<string, object>? metadata = null)
    {
        return new ApiResponse
        {
            Success = true,
            Metadata = metadata,
            Timestamp = DateTime.UtcNow
        };
    }

    /// <summary>Creates a failed response with the provided error message</summary>
    public static ApiResponse Fail(string errorMessage, Dictionary<string, object>? metadata = null)
    {
        return new ApiResponse
        {
            Success = false,
            Error = errorMessage,
            Metadata = metadata,
            Timestamp = DateTime.UtcNow
        };
    }
}

/// <summary>
/// Paginated result wrapper
/// </summary>
/// <typeparam name="T">Type of the items</typeparam>
public class PaginatedResult<T>
{
    public List<T> Items { get; set; } = new();
    public int TotalCount { get; set; }
    public int Page { get; set; } = 1;
    public int PageSize { get; set; } = 50;
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    public bool HasPreviousPage => Page > 1;
    public bool HasNextPage => Page < TotalPages;
    public string? SortBy { get; set; }
    public bool SortDescending { get; set; } = true;

    public PaginatedResult() { }

    public PaginatedResult(List<T> items, int totalCount, int page, int pageSize)
    {
        Items = items;
        TotalCount = totalCount;
        Page = page;
        PageSize = pageSize;
    }

    public static PaginatedResult<T> Create(List<T> items, int totalCount, int page, int pageSize)
    {
        return new PaginatedResult<T>(items, totalCount, page, pageSize);
    }

    public static PaginatedResult<T> Empty(int page = 1, int pageSize = 50)
    {
        return new PaginatedResult<T>(new List<T>(), 0, page, pageSize);
    }
}

/// <summary>
/// Extension methods for ApiResponse to handle paginated results
/// </summary>
public static class ApiResponseExtensions
{
    /// <summary>
    /// Creates a successful response with paginated data
    /// </summary>
    public static ApiResponse<PaginatedResult<T>> OkPaginated<T>(
        PaginatedResult<T> result,
        Dictionary<string, object>? metadata = null,
        string? correlationId = null)
    {
        var response = new ApiResponse<PaginatedResult<T>>
        {
            Success = true,
            Data = result,
            Metadata = metadata ?? new Dictionary<string, object>(),
            Timestamp = DateTime.UtcNow
        };

        if (!string.IsNullOrEmpty(correlationId))
        {
            response.Metadata["correlationId"] = correlationId;
        }

        // Add pagination metadata
        response.Metadata["pagination"] = new Dictionary<string, object>
        {
            ["currentPage"] = result.Page,
            ["pageSize"] = result.PageSize,
            ["totalCount"] = result.TotalCount,
            ["totalPages"] = result.TotalPages,
            ["hasPreviousPage"] = result.HasPreviousPage,
            ["hasNextPage"] = result.HasNextPage
        };

        return response;
    }

    /// <summary>
    /// Creates a successful response with paginated data (alternative method)
    /// </summary>
    public static ApiResponse<PaginatedResult<T>> Ok<T>(
        PaginatedResult<T> result,
        Dictionary<string, object>? metadata = null)
    {
        return OkPaginated(result, metadata);
    }
}

---- File: AuditService.Shared\AuditService.Shared.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
    <PackageReference Include="System.Text.Json" Version="8.0.5" />
  </ItemGroup>

</Project>

---- File: AuditService.Shared\Constants.cs ----
namespace AuditService.Shared;

/// <summary>
/// Application constants
/// </summary>
public static class Constants
{
    /// <summary>
    /// Cache key patterns
    /// </summary>
    public static class CacheKeys
    {
        public const string AuditLogById = "audit_log_{0}";
        public const string UserAuditHistory = "user_audit_history_{0}";
        public const string RecentAudits = "recent_audits";
        public const string AuditStatistics = "audit_statistics";
        public const string TopActions = "top_actions";
        public const string ActiveUsers = "active_users";
        public const string DailyStats = "daily_stats_{0}";
    }

    /// <summary>
    /// Policy names for authorization
    /// </summary>
    public static class Policies
    {
        public const string RequireAdminRole = "RequireAdminRole";
        public const string RequireAuditorRole = "RequireAuditorRole";
        public const string RequireViewAuditLogs = "RequireViewAuditLogs";
        public const string AllowAnonymous = "AllowAnonymous";
    }

    /// <summary>
    /// Role names
    /// </summary>
    public static class Roles
    {
        public const string Administrator = "Administrator";
        public const string Auditor = "Auditor";
        public const string User = "User";
        public const string System = "System";
    }

    /// <summary>
    /// Claim types
    /// </summary>
    public static class ClaimTypes
    {
        public const string UserId = "sub";
        public const string Email = "email";
        public const string Name = "name";
        public const string Role = "role";
        public const string Permissions = "permissions";
    }

    /// <summary>
    /// HTTP header names
    /// </summary>
    public static class Headers
    {
        public const string ApiKey = "X-API-Key";
        public const string CorrelationId = "X-Correlation-ID";
        public const string UserAgent = "User-Agent";
        public const string ForwardedFor = "X-Forwarded-For";
        public const string RequestId = "X-Request-ID";
    }

    /// <summary>
    /// Audit action types
    /// </summary>
    public static class AuditActions
    {
        // Authentication actions
        public const string Login = "LOGIN";
        public const string Register = "REGISTER";
        public const string Logout = "LOGOUT";
        public const string RefreshToken = "REFRESH_TOKEN";
        public const string ForgotPassword = "FORGOT_PASSWORD";
        public const string ResetPassword = "RESET_PASSWORD";
        public const string VerifyEmail = "VERIFY_EMAIL";

        // User management actions
        public const string CreateUser = "CREATE_USER";
        public const string UpdateUser = "UPDATE_USER";
        public const string DeleteUser = "DELETE_USER";
        public const string EnableUser = "ENABLE_USER";
        public const string DisableUser = "DISABLE_USER";

        // Two-factor authentication actions
        public const string Enable2FA = "ENABLE_2FA";
        public const string Disable2FA = "DISABLE_2FA";
        public const string Verify2FA = "VERIFY_2FA";

        // External authentication actions
        public const string ExternalLogin = "EXTERNAL_LOGIN";
        public const string LinkExternalAccount = "LINK_EXTERNAL_ACCOUNT";
        public const string UnlinkExternalAccount = "UNLINK_EXTERNAL_ACCOUNT";

        // System actions
        public const string SystemStartup = "SYSTEM_STARTUP";
        public const string SystemShutdown = "SYSTEM_SHUTDOWN";
        public const string Cleanup = "CLEANUP";
    }

    /// <summary>
    /// Audit resource types
    /// </summary>
    public static class AuditResources
    {
        public const string User = "USER";
        public const string Auth = "AUTH";
        public const string Token = "TOKEN";
        public const string TwoFactor = "TWO_FACTOR";
        public const string ExternalAuth = "EXTERNAL_AUTH";
        public const string System = "SYSTEM";
    }

    /// <summary>
    /// Error codes
    /// </summary>
    public static class ErrorCodes
    {
        public const string ValidationError = "VALIDATION_ERROR";
        public const string NotFound = "NOT_FOUND";
        public const string Unauthorized = "UNAUTHORIZED";
        public const string Forbidden = "FORBIDDEN";
        public const string Conflict = "CONFLICT";
        public const string InternalError = "INTERNAL_ERROR";
        public const string ServiceUnavailable = "SERVICE_UNAVAILABLE";
        public const string RateLimitExceeded = "RATE_LIMIT_EXCEEDED";
    }

    /// <summary>
    /// Date and time formats
    /// </summary>
    public static class DateFormats
    {
        public const string Default = "yyyy-MM-ddTHH:mm:ss.fffZ";
        public const string DateOnly = "yyyy-MM-dd";
        public const string HumanReadable = "MMMM dd, yyyy 'at' hh:mm tt";
    }

    /// <summary>
    /// Pagination defaults
    /// </summary>
    public static class Pagination
    {
        public const int DefaultPage = 1;
        public const int DefaultPageSize = 50;
        public const int MaxPageSize = 1000;
    }

    /// <summary>
    /// Configuration section names
    /// </summary>
    public static class ConfigurationSections
    {
        public const string Database = "Database";
        public const string Cache = "Cache";
        public const string HealthChecks = "HealthChecks";
        public const string RabbitMQ = "RabbitMQ";
        public const string AuditService = "AuditService";
        public const string Serilog = "Serilog";
    }
}

---- File: AuditService.Shared\ValidationPatterns.cs ----
using System.Text.RegularExpressions;

namespace AuditService.Shared;

/// <summary>
/// Regular expression patterns for validation
/// </summary>
public static class ValidationPatterns
{
    /// <summary>
    /// Pattern for email validation
    /// </summary>
    public const string Email = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";

    /// <summary>
    /// Pattern for GUID validation
    /// </summary>
    public const string Guid = @"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$";

    /// <summary>
    /// Pattern for IP address validation (IPv4 and IPv6)
    /// </summary>
    public const string IpAddress = @"^([0-9]{1,3}\.){3}[0-9]{1,3}$|^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$";

    /// <summary>
    /// Pattern for user agent validation (basic pattern)
    /// </summary>
    public const string UserAgent = @"^.{1,500}$";

    /// <summary>
    /// Pattern for action name validation (alphanumeric and underscores)
    /// </summary>
    public const string ActionName = @"^[a-zA-Z0-9_]{1,100}$";

    /// <summary>
    /// Pattern for resource name validation (alphanumeric, underscores, and dots)
    /// </summary>
    public const string ResourceName = @"^[a-zA-Z0-9_.]{1,255}$";

    /// <summary>
    /// Pattern for correlation ID validation (alphanumeric and hyphens)
    /// </summary>
    public const string CorrelationId = @"^[a-zA-Z0-9-]{1,100}$";

    /// <summary>
    /// Pattern for service name validation (alphanumeric and hyphens)
    /// </summary>
    public const string ServiceName = @"^[a-zA-Z0-9-]{1,50}$";

    /// <summary>
    /// Pattern for sorting parameter validation (alphanumeric and underscores)
    /// </summary>
    public const string SortBy = @"^[a-zA-Z0-9_]{1,50}$";

    /// <summary>
    /// Validates an email address
    /// </summary>
    public static bool IsValidEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return false;

        return Regex.IsMatch(email, Email, RegexOptions.IgnoreCase);
    }

    /// <summary>
    /// Validates a GUID string
    /// </summary>
    public static bool IsValidGuid(string guid)
    {
        if (string.IsNullOrWhiteSpace(guid))
            return false;

        return Regex.IsMatch(guid, Guid, RegexOptions.IgnoreCase);
    }

    /// <summary>
    /// Validates an IP address
    /// </summary>
    public static bool IsValidIpAddress(string ipAddress)
    {
        if (string.IsNullOrWhiteSpace(ipAddress))
            return false;

        return Regex.IsMatch(ipAddress, IpAddress);
    }

    /// <summary>
    /// Validates a user agent string
    /// </summary>
    public static bool IsValidUserAgent(string userAgent)
    {
        if (string.IsNullOrWhiteSpace(userAgent))
            return false;

        return Regex.IsMatch(userAgent, UserAgent);
    }

    /// <summary>
    /// Validates an action name
    /// </summary>
    public static bool IsValidActionName(string actionName)
    {
        if (string.IsNullOrWhiteSpace(actionName))
            return false;

        return Regex.IsMatch(actionName, ActionName);
    }

    /// <summary>
    /// Validates a resource name
    /// </summary>
    public static bool IsValidResourceName(string resourceName)
    {
        if (string.IsNullOrWhiteSpace(resourceName))
            return false;

        return Regex.IsMatch(resourceName, ResourceName);
    }

    /// <summary>
    /// Validates a correlation ID
    /// </summary>
    public static bool IsValidCorrelationId(string correlationId)
    {
        if (string.IsNullOrWhiteSpace(correlationId))
            return false;

        return Regex.IsMatch(correlationId, CorrelationId);
    }

    /// <summary>
    /// Validates a service name
    /// </summary>
    public static bool IsValidServiceName(string serviceName)
    {
        if (string.IsNullOrWhiteSpace(serviceName))
            return false;

        return Regex.IsMatch(serviceName, ServiceName);
    }

    /// <summary>
    /// Validates a sort by parameter
    /// </summary>
    // Actualizar el m�todo IsValidSortBy para aceptar null
    public static bool IsValidSortBy(string? sortBy)
    {
        if (string.IsNullOrWhiteSpace(sortBy))
            return false;

        return Regex.IsMatch(sortBy, SortBy);
    }

    /// <summary>
    /// Sanitizes a string for safe logging (removes sensitive data)
    /// </summary>
    public static string SanitizeForLogging(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty;

        // Remove potential sensitive data patterns
        var patterns = new Dictionary<string, string>
        {
            { @"password[^=]*=([^&]*)", "password=***" },
            { @"token[^=]*=([^&]*)", "token=***" },
            { @"authorization[^:]*:\s*([^,\s]*)", "authorization: ***" },
            { @"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b", "***@***.***" },
            { @"\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b", "****-****-****-****" } // Credit card
        };

        var sanitized = input;
        foreach (var pattern in patterns)
        {
            sanitized = Regex.Replace(sanitized, pattern.Key, pattern.Value, RegexOptions.IgnoreCase);
        }

        return sanitized;
    }

    /// <summary>
    /// Validates a page number
    /// </summary>
    public static bool IsValidPage(int page)
    {
        return page >= 1;
    }

    /// <summary>
    /// Validates a page size
    /// </summary>
    public static bool IsValidPageSize(int pageSize)
    {
        return pageSize >= 1 && pageSize <= Constants.Pagination.MaxPageSize;
    }

    /// <summary>
    /// Validates a date range
    /// </summary>
    public static bool IsValidDateRange(DateTime fromDate, DateTime toDate)
    {
        return fromDate <= toDate && toDate <= DateTime.UtcNow;
    }
}

---- File: AuditService.Shared\AuditMessages\AuditEvent.cs ----
using AuditService.Shared.Enums;
using System.Text.Json.Serialization;

namespace AuditService.Shared.AuditMessages;

/// <summary>
/// Represents an audit event that can be published to the audit service
/// </summary>
public class AuditEvent
{
    /// <summary>
    /// Unique identifier for the audit event
    /// </summary>
    [JsonPropertyName("id")]
    public string Id { get; set; } = Guid.NewGuid().ToString();

    /// <summary>
    /// ID of the user who performed the action
    /// </summary>
    [JsonPropertyName("userId")]
    public string UserId { get; set; } = string.Empty;

    /// <summary>
    /// The action performed (e.g., "Login", "Register", "UpdateUser")
    /// </summary>
    [JsonPropertyName("action")]
    public string Action { get; set; } = string.Empty;

    /// <summary>
    /// The resource that was affected by the action
    /// </summary>
    [JsonPropertyName("resource")]
    public string Resource { get; set; } = string.Empty;

    /// <summary>
    /// IP address of the user who performed the action
    /// </summary>
    [JsonPropertyName("userIp")]
    public string UserIp { get; set; } = string.Empty;

    /// <summary>
    /// User agent string from the request
    /// </summary>
    [JsonPropertyName("userAgent")]
    public string UserAgent { get; set; } = string.Empty;

    /// <summary>
    /// Timestamp when the event occurred
    /// </summary>
    [JsonPropertyName("timestamp")]
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// Additional context data for the audit event
    /// </summary>
    [JsonPropertyName("additionalData")]
    public Dictionary<string, object> AdditionalData { get; set; } = new();

    /// <summary>
    /// Name of the service that generated the audit event
    /// </summary>
    [JsonPropertyName("serviceName")]
    public string ServiceName { get; set; } = "Unknown";

    /// <summary>
    /// Whether the action was successful
    /// </summary>
    [JsonPropertyName("success")]
    public bool Success { get; set; } = true;

    /// <summary>
    /// Error message if the action failed
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Duration of the operation in milliseconds
    /// </summary>
    [JsonPropertyName("durationMs")]
    public long? DurationMs { get; set; }

    /// <summary>
    /// Correlation ID for tracing requests across services
    /// </summary>
    [JsonPropertyName("correlationId")]
    public string? CorrelationId { get; set; }


    /// <summary>
    /// Severity level of the audit event
    /// </summary>
    [JsonPropertyName("severity")]
    public AuditSeverity Severity { get; set; } = AuditSeverity.Information;


    /// <summary>
    /// Creates a new instance of AuditEvent
    /// </summary>
    public AuditEvent() { }

    /// <summary>
    /// Creates a new instance of AuditEvent with basic information
    /// </summary>
    public AuditEvent(string userId, string action, string resource, string userIp, string userAgent)
    {
        UserId = userId;
        Action = action;
        Resource = resource;
        UserIp = userIp;
        UserAgent = userAgent;
        ServiceName = "AuthService"; // Default, can be overridden
    }

    /// <summary>
    /// Adds additional data to the audit event
    /// </summary>
    public AuditEvent AddData(string key, object value)
    {
        AdditionalData[key] = value;
        return this;
    }

    /// <summary>
    /// Marks the audit event as failed with an error message
    /// </summary>
    public AuditEvent MarkAsFailed(string errorMessage, Enums.AuditSeverity severity = Enums.AuditSeverity.Error)
    {
        Success = false;
        ErrorMessage = errorMessage;
        Severity = severity;
        return this;
    }

    /// <summary>
    /// Sets the duration of the operation
    /// </summary>
    public AuditEvent SetDuration(long durationMs)
    {
        DurationMs = durationMs;
        return this;
    }

    /// <summary>
    /// Sets the correlation ID for distributed tracing
    /// </summary>
    public AuditEvent SetCorrelationId(string correlationId)
    {
        CorrelationId = correlationId;
        return this;
    }

    /// <summary>
    /// Sets the service name that generated the event
    /// </summary>
    public AuditEvent SetServiceName(string serviceName)
    {
        ServiceName = serviceName;
        return this;
    }

    /// <summary>
    /// Sets the severity level of the audit event
    /// </summary>
    public AuditEvent SetSeverity(Enums.AuditSeverity severity)
    {
        Severity = severity;
        return this;
    }
}

---- File: AuditService.Shared\AuditMessages\IAuditEventProducer.cs ----
namespace AuditService.Shared.AuditMessages;

public interface IAuditEventProducer
{
    Task PublishAuditEventAsync(AuditEvent auditEvent);
}

---- File: AuditService.Shared\Enums\AuditAction.cs ----
using System.ComponentModel;

namespace AuditService.Domain.Enums;

// QUITAMOS el enum AuditSeverity de aquí - se movió a Shared

/// <summary>
/// Common audit action types
/// </summary>
public static class AuditActions
{
    // Authentication actions
    public const string Login = "LOGIN";
    public const string Register = "REGISTER";
    public const string Logout = "LOGOUT";
    public const string RefreshToken = "REFRESH_TOKEN";
    public const string ForgotPassword = "FORGOT_PASSWORD";
    public const string ResetPassword = "RESET_PASSWORD";
    public const string VerifyEmail = "VERIFY_EMAIL";
    public const string ChangePassword = "CHANGE_PASSWORD";

    // User management actions
    public const string CreateUser = "CREATE_USER";
    public const string UpdateUser = "UPDATE_USER";
    public const string DeleteUser = "DELETE_USER";
    public const string EnableUser = "ENABLE_USER";
    public const string DisableUser = "DISABLE_USER";
    public const string LockUser = "LOCK_USER";
    public const string UnlockUser = "UNLOCK_USER";

    // Profile actions
    public const string UpdateProfile = "UPDATE_PROFILE";
    public const string UploadAvatar = "UPLOAD_AVATAR";
    public const string DeleteAvatar = "DELETE_AVATAR";

    // Two-factor authentication actions
    public const string Enable2FA = "ENABLE_2FA";
    public const string Disable2FA = "DISABLE_2FA";
    public const string Verify2FA = "VERIFY_2FA";
    public const string GenerateRecoveryCodes = "GENERATE_RECOVERY_CODES";
    public const string UseRecoveryCode = "USE_RECOVERY_CODE";

    // External authentication actions
    public const string ExternalLogin = "EXTERNAL_LOGIN";
    public const string LinkExternalAccount = "LINK_EXTERNAL_ACCOUNT";
    public const string UnlinkExternalAccount = "UNLINK_EXTERNAL_ACCOUNT";

    // Role and permission actions
    public const string CreateRole = "CREATE_ROLE";
    public const string UpdateRole = "UPDATE_ROLE";
    public const string DeleteRole = "DELETE_ROLE";
    public const string AssignRole = "ASSIGN_ROLE";
    public const string RemoveRole = "REMOVE_ROLE";

    // System actions
    public const string SystemStartup = "SYSTEM_STARTUP";
    public const string SystemShutdown = "SYSTEM_SHUTDOWN";
    public const string Cleanup = "CLEANUP";
    public const string Backup = "BACKUP";
    public const string Restore = "RESTORE";

    // Audit-specific actions
    public const string ViewAuditLogs = "VIEW_AUDIT_LOGS";
    public const string ExportAuditLogs = "EXPORT_AUDIT_LOGS";
    public const string PurgeAuditLogs = "PURGE_AUDIT_LOGS";

    // Security actions
    public const string FailedLoginAttempt = "FAILED_LOGIN_ATTEMPT";
    public const string AccountLocked = "ACCOUNT_LOCKED";
    public const string SuspiciousActivity = "SUSPICIOUS_ACTIVITY";
    public const string PasswordSprayAttempt = "PASSWORD_SPRAY_ATTEMPT";
    public const string BruteForceAttempt = "BRUTE_FORCE_ATTEMPT";

    // API actions
    public const string ApiCall = "API_CALL";
    public const string RateLimitExceeded = "RATE_LIMIT_EXCEEDED";
    public const string InvalidToken = "INVALID_TOKEN";
    public const string TokenExpired = "TOKEN_EXPIRED";

    // Notification actions
    public const string SendEmail = "SEND_EMAIL";
    public const string SendSMS = "SEND_SMS";
    public const string SendPush = "SEND_PUSH";

    // Business-specific actions
    public const string CreateDeal = "CREATE_DEAL";
    public const string UpdateDeal = "UPDATE_DEAL";
    public const string DeleteDeal = "DELETE_DEAL";
    public const string ViewDeal = "VIEW_DEAL";
    public const string SearchDeals = "SEARCH_DEALS";
    public const string ExportDeals = "EXPORT_DEALS";

    // Vehicle management actions
    public const string CreateVehicle = "CREATE_VEHICLE";
    public const string UpdateVehicle = "UPDATE_VEHICLE";
    public const string DeleteVehicle = "DELETE_VEHICLE";
    public const string ImportVehicles = "IMPORT_VEHICLES";
    public const string ExportVehicles = "EXPORT_VEHICLES";

    // Customer management actions
    public const string CreateCustomer = "CREATE_CUSTOMER";
    public const string UpdateCustomer = "UPDATE_CUSTOMER";
    public const string DeleteCustomer = "DELETE_CUSTOMER";
    public const string ImportCustomers = "IMPORT_CUSTOMERS";
    public const string ExportCustomers = "EXPORT_CUSTOMERS";

    // File operations
    public const string UploadFile = "UPLOAD_FILE";
    public const string DownloadFile = "DOWNLOAD_FILE";
    public const string DeleteFile = "DELETE_FILE";
    public const string ViewFile = "VIEW_FILE";

    // Report actions
    public const string GenerateReport = "GENERATE_REPORT";
    public const string ViewReport = "VIEW_REPORT";
    public const string ExportReport = "EXPORT_REPORT";
    public const string ScheduleReport = "SCHEDULE_REPORT";

    // Settings actions
    public const string UpdateSettings = "UPDATE_SETTINGS";
    public const string ViewSettings = "VIEW_SETTINGS";
    public const string ResetSettings = "RESET_SETTINGS";

    // Integration actions
    public const string ApiIntegration = "API_INTEGRATION";
    public const string WebhookCall = "WEBHOOK_CALL";
    public const string SyncData = "SYNC_DATA";
    public const string ImportData = "IMPORT_DATA";
    public const string ExportData = "EXPORT_DATA";
}

/// <summary>
/// Common audit resource types
/// </summary>
public static class AuditResources
{
    public const string User = "USER";
    public const string Auth = "AUTH";
    public const string Token = "TOKEN";
    public const string TwoFactor = "TWO_FACTOR";
    public const string ExternalAuth = "EXTERNAL_AUTH";
    public const string Role = "ROLE";
    public const string Permission = "PERMISSION";
    public const string System = "SYSTEM";
    public const string Audit = "AUDIT";
    public const string Security = "SECURITY";
    public const string API = "API";
    public const string Notification = "NOTIFICATION";
    public const string Profile = "PROFILE";

    // Business-specific resources
    public const string Deal = "DEAL";
    public const string Vehicle = "VEHICLE";
    public const string Customer = "CUSTOMER";
    public const string Inventory = "INVENTORY";
    public const string Sales = "SALES";
    public const string Finance = "FINANCE";

    // File resources
    public const string File = "FILE";
    public const string Document = "DOCUMENT";
    public const string Image = "IMAGE";
    public const string Report = "REPORT";

    // Settings resources
    public const string Settings = "SETTINGS";
    public const string Configuration = "CONFIGURATION";

    // Integration resources
    public const string Integration = "INTEGRATION";
    public const string Webhook = "WEBHOOK";
    public const string Data = "DATA";
}

/// <summary>
/// Extension methods for audit enums
/// </summary>
public static class AuditEnumExtensions
{
    /// <summary>
    /// Gets the display name for an audit severity
    /// </summary>
    public static string GetDisplayName(this Shared.Enums.AuditSeverity severity)
    {
        return severity switch
        {
            Shared.Enums.AuditSeverity.Debug => "Debug",
            Shared.Enums.AuditSeverity.Information => "Information",
            Shared.Enums.AuditSeverity.Warning => "Warning",
            Shared.Enums.AuditSeverity.Error => "Error",
            Shared.Enums.AuditSeverity.Critical => "Critical",
            _ => "Unknown"
        };
    }

    /// <summary>
    /// Gets the CSS class for an audit severity (for UI display)
    /// </summary>
    public static string GetCssClass(this Shared.Enums.AuditSeverity severity)
    {
        return severity switch
        {
            Shared.Enums.AuditSeverity.Debug => "text-muted",
            Shared.Enums.AuditSeverity.Information => "text-info",
            Shared.Enums.AuditSeverity.Warning => "text-warning",
            Shared.Enums.AuditSeverity.Error => "text-danger",
            Shared.Enums.AuditSeverity.Critical => "text-danger font-weight-bold",
            _ => "text-muted"
        };
    }

    /// <summary>
    /// Gets the Bootstrap badge class for an audit severity
    /// </summary>
    public static string GetBadgeClass(this Shared.Enums.AuditSeverity severity)
    {
        return severity switch
        {
            Shared.Enums.AuditSeverity.Debug => "bg-secondary",
            Shared.Enums.AuditSeverity.Information => "bg-info",
            Shared.Enums.AuditSeverity.Warning => "bg-warning",
            Shared.Enums.AuditSeverity.Error => "bg-danger",
            Shared.Enums.AuditSeverity.Critical => "bg-dark",
            _ => "bg-secondary"
        };
    }

    /// <summary>
    /// Gets the color code for an audit severity
    /// </summary>
    public static string GetColorCode(this Shared.Enums.AuditSeverity severity)
    {
        return severity switch
        {
            Shared.Enums.AuditSeverity.Debug => "#6c757d",      // Gray
            Shared.Enums.AuditSeverity.Information => "#17a2b8", // Teal
            Shared.Enums.AuditSeverity.Warning => "#ffc107",     // Yellow
            Shared.Enums.AuditSeverity.Error => "#dc3545",       // Red
            Shared.Enums.AuditSeverity.Critical => "#721c24",    // Dark Red
            _ => "#6c757d"
        };
    }

    /// <summary>
    /// Checks if the severity represents an error condition
    /// </summary>
    public static bool IsError(this Shared.Enums.AuditSeverity severity)
    {
        return severity == Shared.Enums.AuditSeverity.Error || severity == Shared.Enums.AuditSeverity.Critical;
    }

    /// <summary>
    /// Checks if the severity represents a warning or higher
    /// </summary>
    public static bool IsWarningOrHigher(this Shared.Enums.AuditSeverity severity)
    {
        return severity >= Shared.Enums.AuditSeverity.Warning;
    }

    /// <summary>
    /// Gets the action category for grouping purposes
    /// </summary>
    public static string GetActionCategory(string action)
    {
        return action switch
        {
            var a when a.StartsWith("LOGIN") || a.StartsWith("LOGOUT") || a.StartsWith("REFRESH") || a.Contains("AUTH") => "Authentication",
            var a when a.Contains("PASSWORD") || a.Contains("2FA") || a.Contains("RECOVERY") => "Security",
            var a when a.StartsWith("CREATE_") || a.StartsWith("UPDATE_") || a.StartsWith("DELETE_") => "CRUD Operations",
            var a when a.StartsWith("ENABLE_") || a.StartsWith("DISABLE_") || a.StartsWith("LOCK") || a.StartsWith("UNLOCK") => "User Management",
            var a when a.Contains("ROLE") || a.Contains("PERMISSION") => "Authorization",
            var a when a.StartsWith("SYSTEM_") || a.Contains("BACKUP") || a.Contains("RESTORE") => "System",
            var a when a.Contains("AUDIT") => "Audit",
            var a when a.Contains("API") => "API",
            var a when a.Contains("NOTIFICATION") || a.Contains("SEND_") => "Notifications",
            var a when a.Contains("DEAL") || a.Contains("VEHICLE") || a.Contains("CUSTOMER") => "Business Operations",
            var a when a.Contains("FILE") || a.Contains("DOCUMENT") || a.Contains("IMAGE") => "File Operations",
            var a when a.Contains("REPORT") => "Reporting",
            var a when a.Contains("SETTING") || a.Contains("CONFIG") => "Settings",
            var a when a.Contains("INTEGRATION") || a.Contains("WEBHOOK") || a.Contains("SYNC") => "Integration",
            _ => "Other"
        };
    }

    /// <summary>
    /// Gets the icon for an audit action (for UI display)
    /// </summary>
    public static string GetActionIcon(string action)
    {
        return action switch
        {
            var a when a.Contains("LOGIN") => "fas fa-sign-in-alt",
            var a when a.Contains("LOGOUT") => "fas fa-sign-out-alt",
            var a when a.Contains("CREATE") => "fas fa-plus-circle",
            var a when a.Contains("UPDATE") => "fas fa-edit",
            var a when a.Contains("DELETE") => "fas fa-trash-alt",
            var a when a.Contains("PASSWORD") => "fas fa-key",
            var a when a.Contains("EMAIL") => "fas fa-envelope",
            var a when a.Contains("LOCK") => "fas fa-lock",
            var a when a.Contains("UNLOCK") => "fas fa-unlock",
            var a when a.Contains("2FA") => "fas fa-mobile-alt",
            var a when a.Contains("ROLE") => "fas fa-user-tag",
            var a when a.Contains("SYSTEM") => "fas fa-cog",
            var a when a.Contains("AUDIT") => "fas fa-clipboard-list",
            var a when a.Contains("NOTIFICATION") => "fas fa-bell",
            var a when a.Contains("DEAL") => "fas fa-handshake",
            var a when a.Contains("VEHICLE") => "fas fa-car",
            var a when a.Contains("CUSTOMER") => "fas fa-users",
            var a when a.Contains("FILE") || a.Contains("DOCUMENT") => "fas fa-file",
            var a when a.Contains("REPORT") => "fas fa-chart-bar",
            var a when a.Contains("SETTING") => "fas fa-cogs",
            var a when a.Contains("INTEGRATION") => "fas fa-plug",
            _ => "fas fa-history"
        };
    }

    /// <summary>
    /// Gets the resource icon for an audit resource (for UI display)
    /// </summary>
    public static string GetResourceIcon(string resource)
    {
        return resource switch
        {
            var r when r.Contains("USER") => "fas fa-user",
            var r when r.Contains("AUTH") => "fas fa-shield-alt",
            var r when r.Contains("TOKEN") => "fas fa-key",
            var r when r.Contains("ROLE") => "fas fa-user-tag",
            var r when r.Contains("SYSTEM") => "fas fa-cog",
            var r when r.Contains("AUDIT") => "fas fa-clipboard-list",
            var r when r.Contains("SECURITY") => "fas fa-shield-alt",
            var r when r.Contains("API") => "fas fa-code",
            var r when r.Contains("NOTIFICATION") => "fas fa-bell",
            var r when r.Contains("PROFILE") => "fas fa-id-card",
            var r when r.Contains("DEAL") => "fas fa-handshake",
            var r when r.Contains("VEHICLE") => "fas fa-car",
            var r when r.Contains("CUSTOMER") => "fas fa-users",
            var r when r.Contains("FILE") => "fas fa-file",
            var r when r.Contains("REPORT") => "fas fa-chart-bar",
            var r when r.Contains("SETTING") => "fas fa-cogs",
            var r when r.Contains("INTEGRATION") => "fas fa-plug",
            _ => "fas fa-cube"
        };
    }

    /// <summary>
    /// Converts string to AuditSeverity enum
    /// </summary>
    public static Shared.Enums.AuditSeverity ToAuditSeverity(this string severity)
    {
        if (Enum.TryParse<Shared.Enums.AuditSeverity>(severity, true, out var result))
        {
            return result;
        }

        // Try to parse by number
        if (int.TryParse(severity, out var severityNumber) &&
            Enum.IsDefined(typeof(Shared.Enums.AuditSeverity), severityNumber))
        {
            return (Shared.Enums.AuditSeverity)severityNumber;
        }

        return Shared.Enums.AuditSeverity.Information; // Default fallback
    }

    /// <summary>
    /// Gets all available audit actions
    /// </summary>
    public static List<string> GetAllActions()
    {
        return typeof(AuditActions)
            .GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
            .Where(f => f.IsLiteral && !f.IsInitOnly)
            .Select(f => f.GetValue(null)?.ToString() ?? string.Empty)
            .Where(value => !string.IsNullOrEmpty(value))
            .ToList();
    }

    /// <summary>
    /// Gets all available audit resources
    /// </summary>
    public static List<string> GetAllResources()
    {
        return typeof(AuditResources)
            .GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
            .Where(f => f.IsLiteral && !f.IsInitOnly)
            .Select(f => f.GetValue(null)?.ToString() ?? string.Empty)
            .Where(value => !string.IsNullOrEmpty(value))
            .ToList();
    }

    /// <summary>
    /// Validates if an action is a known audit action
    /// </summary>
    public static bool IsKnownAction(string action)
    {
        return GetAllActions().Contains(action);
    }

    /// <summary>
    /// Validates if a resource is a known audit resource
    /// </summary>
    public static bool IsKnownResource(string resource)
    {
        return GetAllResources().Contains(resource);
    }
}

---- File: AuditService.Shared\Enums\AuditEnumExtensions.cs ----
using AuditService.Shared.Enums;

namespace AuditService.Shared.Enums;

public static class AuditEnumExtensions
{
    /// <summary>
    /// Gets the display name for an audit severity
    /// </summary>
    public static string GetDisplayName(this AuditSeverity severity)
    {
        return severity switch
        {
            AuditSeverity.Debug => "Debug",
            AuditSeverity.Information => "Information",
            AuditSeverity.Warning => "Warning",
            AuditSeverity.Error => "Error",
            AuditSeverity.Critical => "Critical",
            _ => "Unknown"
        };
    }

    /// <summary>
    /// Gets the CSS class for an audit severity (for UI display)
    /// </summary>
    public static string GetCssClass(this AuditSeverity severity)
    {
        return severity switch
        {
            AuditSeverity.Debug => "text-muted",
            AuditSeverity.Information => "text-info",
            AuditSeverity.Warning => "text-warning",
            AuditSeverity.Error => "text-danger",
            AuditSeverity.Critical => "text-danger font-weight-bold",
            _ => "text-muted"
        };
    }

    /// <summary>
    /// Gets the Bootstrap badge class for an audit severity
    /// </summary>
    public static string GetBadgeClass(this AuditSeverity severity)
    {
        return severity switch
        {
            AuditSeverity.Debug => "bg-secondary",
            AuditSeverity.Information => "bg-info",
            AuditSeverity.Warning => "bg-warning",
            AuditSeverity.Error => "bg-danger",
            AuditSeverity.Critical => "bg-dark",
            _ => "bg-secondary"
        };
    }

    /// <summary>
    /// Gets the color code for an audit severity
    /// </summary>
    public static string GetColorCode(this AuditSeverity severity)
    {
        return severity switch
        {
            AuditSeverity.Debug => "#6c757d",      // Gray
            AuditSeverity.Information => "#17a2b8", // Teal
            AuditSeverity.Warning => "#ffc107",     // Yellow
            AuditSeverity.Error => "#dc3545",       // Red
            AuditSeverity.Critical => "#721c24",    // Dark Red
            _ => "#6c757d"
        };
    }

    /// <summary>
    /// Checks if the severity represents an error condition
    /// </summary>
    public static bool IsError(this AuditSeverity severity)
    {
        return severity == AuditSeverity.Error || severity == AuditSeverity.Critical;
    }

    /// <summary>
    /// Checks if the severity represents a warning or higher
    /// </summary>
    public static bool IsWarningOrHigher(this AuditSeverity severity)
    {
        return severity >= AuditSeverity.Warning;
    }

    /// <summary>
    /// Gets the action category for grouping purposes
    /// </summary>
    public static string GetActionCategory(string action)
    {
        return action switch
        {
            var a when a.StartsWith("LOGIN") || a.StartsWith("LOGOUT") || a.StartsWith("REFRESH") || a.Contains("AUTH") => "Authentication",
            var a when a.Contains("PASSWORD") || a.Contains("2FA") || a.Contains("RECOVERY") => "Security",
            var a when a.StartsWith("CREATE_") || a.StartsWith("UPDATE_") || a.StartsWith("DELETE_") => "CRUD Operations",
            var a when a.StartsWith("ENABLE_") || a.StartsWith("DISABLE_") || a.StartsWith("LOCK") || a.StartsWith("UNLOCK") => "User Management",
            var a when a.Contains("ROLE") || a.Contains("PERMISSION") => "Authorization",
            var a when a.StartsWith("SYSTEM_") || a.Contains("BACKUP") || a.Contains("RESTORE") => "System",
            var a when a.Contains("AUDIT") => "Audit",
            var a when a.Contains("API") => "API",
            var a when a.Contains("NOTIFICATION") || a.Contains("SEND_") => "Notifications",
            var a when a.Contains("DEAL") || a.Contains("VEHICLE") || a.Contains("CUSTOMER") => "Business Operations",
            var a when a.Contains("FILE") || a.Contains("DOCUMENT") || a.Contains("IMAGE") => "File Operations",
            var a when a.Contains("REPORT") => "Reporting",
            var a when a.Contains("SETTING") || a.Contains("CONFIG") => "Settings",
            var a when a.Contains("INTEGRATION") || a.Contains("WEBHOOK") || a.Contains("SYNC") => "Integration",
            _ => "Other"
        };
    }

    /// <summary>
    /// Gets the icon for an audit action (for UI display)
    /// </summary>
    public static string GetActionIcon(string action)
    {
        return action switch
        {
            var a when a.Contains("LOGIN") => "fas fa-sign-in-alt",
            var a when a.Contains("LOGOUT") => "fas fa-sign-out-alt",
            var a when a.Contains("CREATE") => "fas fa-plus-circle",
            var a when a.Contains("UPDATE") => "fas fa-edit",
            var a when a.Contains("DELETE") => "fas fa-trash-alt",
            var a when a.Contains("PASSWORD") => "fas fa-key",
            var a when a.Contains("EMAIL") => "fas fa-envelope",
            var a when a.Contains("LOCK") => "fas fa-lock",
            var a when a.Contains("UNLOCK") => "fas fa-unlock",
            var a when a.Contains("2FA") => "fas fa-mobile-alt",
            var a when a.Contains("ROLE") => "fas fa-user-tag",
            var a when a.Contains("SYSTEM") => "fas fa-cog",
            var a when a.Contains("AUDIT") => "fas fa-clipboard-list",
            var a when a.Contains("NOTIFICATION") => "fas fa-bell",
            var a when a.Contains("DEAL") => "fas fa-handshake",
            var a when a.Contains("VEHICLE") => "fas fa-car",
            var a when a.Contains("CUSTOMER") => "fas fa-users",
            var a when a.Contains("FILE") || a.Contains("DOCUMENT") => "fas fa-file",
            var a when a.Contains("REPORT") => "fas fa-chart-bar",
            var a when a.Contains("SETTING") => "fas fa-cogs",
            var a when a.Contains("INTEGRATION") => "fas fa-plug",
            _ => "fas fa-history"
        };
    }

    /// <summary>
    /// Gets the resource icon for an audit resource (for UI display)
    /// </summary>
    public static string GetResourceIcon(string resource)
    {
        return resource switch
        {
            var r when r.Contains("USER") => "fas fa-user",
            var r when r.Contains("AUTH") => "fas fa-shield-alt",
            var r when r.Contains("TOKEN") => "fas fa-key",
            var r when r.Contains("ROLE") => "fas fa-user-tag",
            var r when r.Contains("SYSTEM") => "fas fa-cog",
            var r when r.Contains("AUDIT") => "fas fa-clipboard-list",
            var r when r.Contains("SECURITY") => "fas fa-shield-alt",
            var r when r.Contains("API") => "fas fa-code",
            var r when r.Contains("NOTIFICATION") => "fas fa-bell",
            var r when r.Contains("PROFILE") => "fas fa-id-card",
            var r when r.Contains("DEAL") => "fas fa-handshake",
            var r when r.Contains("VEHICLE") => "fas fa-car",
            var r when r.Contains("CUSTOMER") => "fas fa-users",
            var r when r.Contains("FILE") => "fas fa-file",
            var r when r.Contains("REPORT") => "fas fa-chart-bar",
            var r when r.Contains("SETTING") => "fas fa-cogs",
            var r when r.Contains("INTEGRATION") => "fas fa-plug",
            _ => "fas fa-cube"
        };
    }

    /// <summary>
    /// Converts string to AuditSeverity enum
    /// </summary>
    public static AuditSeverity ToAuditSeverity(this string severity)
    {
        if (Enum.TryParse<AuditSeverity>(severity, true, out var result))
        {
            return result;
        }

        // Try to parse by number
        if (int.TryParse(severity, out var severityNumber) &&
            Enum.IsDefined(typeof(AuditSeverity), severityNumber))
        {
            return (AuditSeverity)severityNumber;
        }

        return AuditSeverity.Information; // Default fallback
    }

    /// <summary>
    /// Gets all available audit actions
    /// </summary>
    public static List<string> GetAllActions()
    {
        return typeof(Domain.Enums.AuditActions)
            .GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
            .Where(f => f.IsLiteral && !f.IsInitOnly)
            .Select(f => f.GetValue(null)?.ToString() ?? string.Empty)
            .Where(value => !string.IsNullOrEmpty(value))
            .ToList();
    }

    /// <summary>
    /// Gets all available audit resources
    /// </summary>
    public static List<string> GetAllResources()
    {
        return typeof(Domain.Enums.AuditResources)
            .GetFields(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static)
            .Where(f => f.IsLiteral && !f.IsInitOnly)
            .Select(f => f.GetValue(null)?.ToString() ?? string.Empty)
            .Where(value => !string.IsNullOrEmpty(value))
            .ToList();
    }

    /// <summary>
    /// Validates if an action is a known audit action
    /// </summary>
    public static bool IsKnownAction(string action)
    {
        return GetAllActions().Contains(action);
    }

    /// <summary>
    /// Validates if a resource is a known audit resource
    /// </summary>
    public static bool IsKnownResource(string resource)
    {
        return GetAllResources().Contains(resource);
    }
}

---- File: AuditService.Shared\Enums\AuditSeverity.cs ----
namespace AuditService.Shared.Enums;

/// <summary>
/// Severity levels for audit events
/// </summary>
public enum AuditSeverity
{
    /// <summary>
    /// Debug-level information for development and troubleshooting
    /// </summary>
    Debug = 1,

    /// <summary>
    /// Normal system operations and user actions
    /// </summary>
    Information = 2,

    /// <summary>
    /// Warning events that might indicate potential issues
    /// </summary>
    Warning = 3,

    /// <summary>
    /// Error events that indicate failures but don't break the system
    /// </summary>
    Error = 4,

    /// <summary>
    /// Critical events that require immediate attention
    /// </summary>
    Critical = 5
}

---- File: AuditService.Shared\Settings\CacheSettings.cs ----
namespace AuditService.Shared.Settings;

/// <summary>
/// Configuration settings for caching
/// </summary>
public class CacheSettings
{
    /// <summary>
    /// Redis connection string
    /// </summary>
    public string RedisConnectionString { get; set; } = "localhost:6379";

    /// <summary>
    /// Default cache expiration time in minutes
    /// </summary>
    public int DefaultExpirationMinutes { get; set; } = 30;

    /// <summary>
    /// Audit log cache expiration in minutes
    /// </summary>
    public int AuditLogCacheExpirationMinutes { get; set; } = 15;

    /// <summary>
    /// Statistics cache expiration in minutes
    /// </summary>
    public int StatisticsCacheExpirationMinutes { get; set; } = 5;

    /// <summary>
    /// Whether to enable distributed caching
    /// </summary>
    public bool EnableDistributedCache { get; set; } = true;

    /// <summary>
    /// Whether to enable in-memory caching as fallback
    /// </summary>
    public bool EnableMemoryCache { get; set; } = true;

    /// <summary>
    /// Maximum memory cache size in megabytes
    /// </summary>
    public int MaxMemoryCacheSizeMB { get; set; } = 100;

    /// <summary>
    /// Cache key prefix for audit service
    /// </summary>
    public string CacheKeyPrefix { get; set; } = "auditservice_";

    /// <summary>
    /// Cache key for audit statistics
    /// </summary>
    public string StatisticsCacheKey { get; set; } = "audit_statistics";

    /// <summary>
    /// Cache key for user audit history
    /// </summary>
    public string UserAuditHistoryKey { get; set; } = "user_audit_history_{0}";

    /// <summary>
    /// Cache key for recent audits
    /// </summary>
    public string RecentAuditsKey { get; set; } = "recent_audits";
}

---- File: AuditService.Shared\Settings\DatabaseSettings.cs ----
namespace AuditService.Shared.Settings;

/// <summary>
/// Configuration settings for database connectivity
/// </summary>
public class DatabaseSettings
{
    /// <summary>
    /// Database connection string
    /// </summary>
    public string ConnectionString { get; set; } = "Host=localhost;Database=auditservice;Username=postgres;Password=password";

    /// <summary>
    /// Database provider (PostgreSQL, SQLServer, SQLite, etc.)
    /// </summary>
    public string Provider { get; set; } = "PostgreSQL";

    /// <summary>
    /// Whether to enable sensitive data logging (should be false in production)
    /// </summary>
    public bool EnableSensitiveDataLogging { get; set; } = false;

    /// <summary>
    /// Whether to enable detailed errors
    /// </summary>
    public bool EnableDetailedErrors { get; set; } = false;

    /// <summary>
    /// Command timeout in seconds
    /// </summary>
    public int CommandTimeout { get; set; } = 30;

    /// <summary>
    /// Maximum number of retry attempts for database operations
    /// </summary>
    public int MaxRetryCount { get; set; } = 3;

    /// <summary>
    /// Whether to enable query tracking
    /// </summary>
    public bool EnableQueryTracking { get; set; } = false;

    /// <summary>
    /// Maximum number of records to return in a single query
    /// </summary>
    public int MaxPageSize { get; set; } = 1000;

    /// <summary>
    /// Default page size for paginated queries
    /// </summary>
    public int DefaultPageSize { get; set; } = 50;

    /// <summary>
    /// Database schema to use
    /// </summary>
    public string Schema { get; set; } = "public";

    /// <summary>
    /// Whether to automatically apply migrations on startup
    /// </summary>
    public bool AutoMigrate { get; set; } = true;

    /// <summary>
    /// Whether to enable database health checks
    /// </summary>
    public bool EnableHealthChecks { get; set; } = true;
}

---- File: AuditService.Shared\Settings\HealthCheckSettings.cs ----
namespace AuditService.Shared.Settings;

/// <summary>
/// Configuration settings for health checks
/// </summary>
public class HealthCheckSettings
{
    /// <summary>
    /// Whether health checks are enabled
    /// </summary>
    public bool Enabled { get; set; } = true;

    /// <summary>
    /// Database health check timeout in seconds
    /// </summary>
    public int DatabaseTimeout { get; set; } = 30;

    /// <summary>
    /// Redis health check timeout in seconds
    /// </summary>
    public int RedisTimeout { get; set; } = 10;

    /// <summary>
    /// External services health check timeout in seconds
    /// </summary>
    public int ExternalServicesTimeout { get; set; } = 30;

    /// <summary>
    /// Health check endpoint path
    /// </summary>
    public string EndpointPath { get; set; } = "/health";

    /// <summary>
    /// Health check UI endpoint path
    /// </summary>
    public string UiEndpointPath { get; set; } = "/health-ui";

    /// <summary>
    /// Health check database name for testing
    /// </summary>
    public string DatabaseName { get; set; } = "auditservice";

    /// <summary>
    /// Whether to include detailed health information
    /// </summary>
    public bool IncludeDetails { get; set; } = true;

    /// <summary>
    /// Health check evaluation time in seconds
    /// </summary>
    public int EvaluationTimeInSeconds { get; set; } = 30;

    /// <summary>
    /// Maximum history entries to keep
    /// </summary>
    public int MaximumHistoryEntriesPerEndpoint { get; set; } = 100;

    /// <summary>
    /// Minimum seconds between health checks
    /// </summary>
    public int MinimumSecondsBetweenFailureNotifications { get; set; } = 60;
}

