## Code Bundle - Aggregated Files
## Microservicio: backend\AuthService
## Generado: 11/11/2025 12:27:44
## Carpetas excluidas: bin, obj, Properties

---- File: AuthService.sln ----

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuthService.Application", "AuthService.Application\AuthService.Application.csproj", "{5CFE035B-BF10-411F-860E-8A706FCC47CF}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuthService.Domain", "AuthService.Domain\AuthService.Domain.csproj", "{01FD245B-1AD3-4D9B-92B5-F06E8442D93C}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuthService.Infrastructure", "AuthService.Infrastructure\AuthService.Infrastructure.csproj", "{F60000BC-C22A-48F6-B350-A62D97D687E1}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuthService.Shared", "AuthService.Shared\AuthService.Shared.csproj", "{D993BD4F-7A71-49D5-8BA8-4BA5A7D337EA}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AuthService.Api", "AuthService.Api\AuthService.Api.csproj", "{DC3C522F-60EC-47F7-9326-92CB306D563A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FC707A80-9A1B-4202-9093-8D279FAE5A36}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{FC707A80-9A1B-4202-9093-8D279FAE5A36}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{FC707A80-9A1B-4202-9093-8D279FAE5A36}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{FC707A80-9A1B-4202-9093-8D279FAE5A36}.Release|Any CPU.Build.0 = Release|Any CPU
		{5CFE035B-BF10-411F-860E-8A706FCC47CF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5CFE035B-BF10-411F-860E-8A706FCC47CF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5CFE035B-BF10-411F-860E-8A706FCC47CF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5CFE035B-BF10-411F-860E-8A706FCC47CF}.Release|Any CPU.Build.0 = Release|Any CPU
		{01FD245B-1AD3-4D9B-92B5-F06E8442D93C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{01FD245B-1AD3-4D9B-92B5-F06E8442D93C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{01FD245B-1AD3-4D9B-92B5-F06E8442D93C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{01FD245B-1AD3-4D9B-92B5-F06E8442D93C}.Release|Any CPU.Build.0 = Release|Any CPU
		{F60000BC-C22A-48F6-B350-A62D97D687E1}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{F60000BC-C22A-48F6-B350-A62D97D687E1}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{F60000BC-C22A-48F6-B350-A62D97D687E1}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{F60000BC-C22A-48F6-B350-A62D97D687E1}.Release|Any CPU.Build.0 = Release|Any CPU
		{D993BD4F-7A71-49D5-8BA8-4BA5A7D337EA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{D993BD4F-7A71-49D5-8BA8-4BA5A7D337EA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{D993BD4F-7A71-49D5-8BA8-4BA5A7D337EA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{D993BD4F-7A71-49D5-8BA8-4BA5A7D337EA}.Release|Any CPU.Build.0 = Release|Any CPU
		{DC3C522F-60EC-47F7-9326-92CB306D563A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DC3C522F-60EC-47F7-9326-92CB306D563A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DC3C522F-60EC-47F7-9326-92CB306D563A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DC3C522F-60EC-47F7-9326-92CB306D563A}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal

---- File: AuthService.Api\appsettings.Development.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information"
    }
  },
  "Jwt": {
    "Key": "clave-super-secreta-desarrollo-32-caracteres-aaa",
    "Issuer": "AuthService-Dev",
    "Audience": "CarGurus-Dev",
    "ExpiresMinutes": 120
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=authservice-db;Database=authservice;Username=postgres;Password=password",
    "Redis": "redis:6379"
  },
  "Email": {
    "Host": "localhost",
    "Port": 25,
    "UseSsl": false,
    "Username": "",
    "Password": "",
    "From": "dev@cargurus.com"
  }
}

---- File: AuthService.Api\appsettings.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "Serilog": {
    "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/authservice-.txt",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 7
        }
      }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "AllowedHosts": "*",
  "Jwt": {
    "Key": "YourSuperSecretKeyThatIsAtLeast32CharactersLong!1234567890",
    "Issuer": "AuthService",
    "Audience": "AuthServiceClients",
    "ExpiresMinutes": 60,
    "RefreshTokenExpiresDays": 7,
    "ClockSkewMinutes": 5
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=authservice-db;Database=authservice;Username=postgres;Password=password",
    "ErrorServiceConnection": "Host=errorservice-db;Database=errorservice;Username=postgres;Password=password",
    "Redis": "redis:6379"
  },
  "ErrorService": {
    "BaseUrl": "http://errorservice:80",
    "TimeoutSeconds": 30,
    "EnableErrorLogging": true,
    "ServiceName": "AuthService",
    "Environment": "Development",
    "EnableRabbitMQ": true,
    "QueueName": "error-queue",
    "ExchangeName": "error-exchange",
    "RoutingKey": "error.routing.key"
  },
  "NotificationService": {
    "EnableRabbitMQ": true,
    "QueueName": "notification-queue",
    "ExchangeName": "notification-exchange",
    "RoutingKey": "notification.auth",
    "BaseUrl": "http://notificationservice:80",
    "TimeoutSeconds": 30,
    "EnableNotifications": true
  },
  "RabbitMQ": {
    "Host": "rabbitmq",
    "Port": 5672,
    "Username": "guest",
    "Password": "guest",
    "VirtualHost": "/"
  },
  "Authentication": {
    "Google": {
      "ClientId": "tu-google-client-id",
      "ClientSecret": "tu-google-client-secret"
    },
    "Microsoft": {
      "ClientId": "tu-microsoft-client-id",
      "ClientSecret": "tu-microsoft-client-secret",
      "TenantId": "common"
    },
    "Facebook": {
      "ClientId": "tu-facebook-app-id",
      "ClientSecret": "tu-facebook-app-secret"
    }
  },
  "Security": {
    "PasswordPolicy": {
      "RequiredLength": 8,
      "RequireUppercase": true,
      "RequireLowercase": true,
      "RequireDigit": true,
      "RequireNonAlphanumeric": false,
      "MaxFailedAttempts": 5
    },
    "LockoutPolicy": {
      "Enabled": true,
      "DefaultLockoutMinutes": 30,
      "MaxFailedAccessAttempts": 5
    },
    "TwoFactor": {
      "Enabled": true,
      "Providers": [ "Email", "SMS" ],
      "RememberBrowserDays": 14
    },
    "RateLimit": {
      "Enabled": true,
      "RequestsPerMinute": 60,
      "LoginAttemptsPerHour": 10,
      "PasswordResetAttemptsPerHour": 5
    }
  },
  "Cache": {
    "RedisConnectionString": "redis:6379",
    "DefaultExpirationMinutes": 30,
    "UserCacheExpirationMinutes": 15,
    "TokenCacheExpirationMinutes": 5,
    "EnableDistributedCache": true
  },
  "HealthChecks": {
    "Enabled": true,
    "DatabaseTimeout": 30,
    "RedisTimeout": 10,
    "ExternalServicesTimeout": 30
  },
  "Cors": {
    "AllowedOrigins": [
      "http://localhost:3000",
      "http://localhost:3001",
      "http://localhost:5173"
    ],
    "AllowedMethods": [ "GET", "POST", "PUT", "DELETE", "OPTIONS" ],
    "AllowedHeaders": [ "*" ],
    "AllowCredentials": true
  }
}

---- File: AuthService.Api\appsettings.Production.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}

---- File: AuthService.Api\AuthService.Api.csproj ----
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <RootNamespace>AuthService.Api</RootNamespace>
    <AssemblyName>AuthService.Api</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.11" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.8" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.4.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.0" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="5.0.1" />
    <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
    
    <!-- NUEVOS PAQUETES PARA HEALTH CHECKS -->
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore" Version="8.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.Redis" Version="8.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.NpgSql" Version="8.0.0" />
    <PackageReference Include="AspNetCore.HealthChecks.Uris" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AuthService.Application\AuthService.Application.csproj" />
    <ProjectReference Include="..\AuthService.Infrastructure\AuthService.Infrastructure.csproj" />
    <ProjectReference Include="..\AuthService.Shared\AuthService.Shared.csproj" />
    <ProjectReference Include="..\..\ErrorService\ErrorService.Shared\ErrorService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: AuthService.Api\AuthService.Api.http ----
@AuthService.Api_HostAddress = http://localhost:5083

GET {{AuthService.Api_HostAddress}}/weatherforecast/
Accept: application/json

###

---- File: AuthService.Api\Dockerfile.dev ----
############################################
# Etapa única de desarrollo: SDK + hot-reload + debugger
############################################
FROM mcr.microsoft.com/dotnet/sdk:8.0

# 1) Instala dotnet-watch y vsdbg para hot-reload y depuración remota
RUN dotnet tool install --global dotnet-watch \
    && export PATH="$PATH:/root/.dotnet/tools" \
 && apt-get update \
 && apt-get install -y unzip curl \
 && curl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l /vsdbg

WORKDIR /app

# 2) Copia y restaura sólo el csproj de la API
COPY AuthService/AuthService.Api/AuthService.Api.csproj ./AuthService/AuthService.Api/
RUN dotnet restore "AuthService/AuthService.Api/AuthService.Api.csproj"

# 3) Copia el resto del código fuente
COPY . .

# 4) Variables de entorno para desarrollo
ENV ASPNETCORE_ENVIRONMENT=Development \
    ASPNETCORE_URLS="http://+:80" \
    DOTNET_MSBUILD_CONFIGURATION=Debug  \
    DOTNET_BUILD_CONFIGURATION=Debug  \
    DOTNET_USE_POLLING_FILE_WATCHER=true \
    NUGET_XMLDOC_MODE=none

# 5) Exponer puertos HTTP y debug (mapped to 4023:4022)
EXPOSE 80
EXPOSE 4022

# 6) Arranca vsdbg en modo servidor y luego hot-reload de la app
ENTRYPOINT ["bash", "-lc", "\
  /vsdbg/vsdbg --interpreter=vscode --server --port 4022 & \
  dotnet watch run --project AuthService/AuthService.Api/AuthService.Api.csproj --urls http://0.0.0.0:80\n"]

---- File: AuthService.Api\Dockerfile.prod ----
# Stage 1: Build & Publish
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# Copiar sln y csproj para cache de dependencias
COPY AuthService/AuthService.sln .
COPY AuthService/AuthService.Api/AuthService.Api.csproj AuthService.Api/
COPY AuthService/AuthService.Application/AuthService.Application.csproj AuthService.Application/
COPY AuthService/AuthService.Domain/AuthService.Domain.csproj AuthService.Domain/
COPY AuthService/AuthService.Infrastructure/AuthService.Infrastructure.csproj AuthService.Infrastructure/
COPY AuthService/AuthService.Shared/AuthService.Shared.csproj AuthService.Shared/

RUN dotnet restore AuthService.sln

# Copiar todo y publicar
COPY . .
RUN dotnet publish AuthService/AuthService.Api -c Release -o /app

# Stage 2: Runtime
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app

# Variables según docker-compose.production.yml (expose 80)
ENV ASPNETCORE_ENVIRONMENT=Production
ENV ASPNETCORE_URLS="http://+:80"
ENV DOTNET_RUNNING_IN_CONTAINER=true

# Usuario no-root
RUN adduser --disabled-password --gecos '' appuser \
    && chown -R appuser:appuser /app
USER appuser

# Copiar publicación
COPY --from=build --chown=appuser:appuser /app ./

# Expone puerto 80 (compose expone 80)
EXPOSE 80

# Healthcheck a /health
HEALTHCHECK --interval=30s --timeout=3s \
    CMD curl -f http://localhost:80/health || exit 1

ENTRYPOINT ["dotnet", "AuthService.Api.dll"]

---- File: AuthService.Api\Program.cs ----
using Microsoft.EntityFrameworkCore;
using AuthService.Infrastructure.Extensions;
using AuthService.Infrastructure.Persistence;
using Serilog;
using System.Reflection;
using FluentValidation;
using AuthService.Shared;
using ErrorService.Shared.Extensions;
using Microsoft.AspNetCore.RateLimiting;
using Microsoft.AspNetCore.Cors;
using System.Threading.RateLimiting;
using AuthService.Infrastructure.Services.Messaging;
using AuthService.Infrastructure.Middleware;
using AuthService.Domain.Interfaces.Services;
using AuthService.Infrastructure.External;
using AuthService.Infrastructure.Services.Notification;
using Microsoft.Extensions.Options;

var builder = WebApplication.CreateBuilder(args);

// Configurar Serilog
builder.Host.UseSerilog((context, configuration) =>
    configuration.ReadFrom.Configuration(context.Configuration));

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddLogging();

// Rate Limiting
builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("AuthPolicy", limiterOptions =>
    {
        var rateLimitSettings = builder.Configuration.GetSection("Security:RateLimit").Get<RateLimitSettings>();
        limiterOptions.PermitLimit = rateLimitSettings?.RequestsPerMinute ?? 60;
        limiterOptions.Window = TimeSpan.FromMinutes(1);
        limiterOptions.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;
        limiterOptions.QueueLimit = 0;
    });
});

// CORS 
builder.Services.AddCors(options =>
{
    options.AddDefaultPolicy(policy =>
    {
        var allowedOrigins = builder.Configuration.GetSection("Cors:AllowedOrigins").Get<string[]>() ?? new string[0];
        var allowedMethods = builder.Configuration.GetSection("Cors:AllowedMethods").Get<string[]>() ?? new string[0];
        var allowedHeaders = builder.Configuration.GetSection("Cors:AllowedHeaders").Get<string[]>() ?? new string[0];
        var allowCredentials = builder.Configuration.GetValue<bool>("Cors:AllowCredentials");

        policy.WithOrigins(allowedOrigins)
              .WithMethods(allowedMethods)
              .WithHeaders(allowedHeaders);

        if (allowCredentials)
        {
            policy.AllowCredentials();
        }
    });
});

// TODA LA CONFIGURACIÓN EN UN SOLO LUGAR
builder.Services.AddInfrastructure(builder.Configuration);

// DbContext
var authConn = builder.Configuration.GetConnectionString("DefaultConnection");
if (string.IsNullOrWhiteSpace(authConn))
    throw new InvalidOperationException("La cadena DefaultConnection no está configurada.");

builder.Services.AddDbContext<ApplicationDbContext>(opts =>
    opts.UseNpgsql(authConn).UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking));

// Error Handling
builder.Services.AddErrorHandling("AuthService");

// MediatR & FluentValidation
builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssembly(Assembly.Load("AuthService.Application")));
builder.Services.AddValidatorsFromAssembly(Assembly.Load("AuthService.Application"));

// Settings
builder.Services.Configure<JwtSettings>(builder.Configuration.GetSection("Jwt"));
builder.Services.Configure<NotificationServiceSettings>(builder.Configuration.GetSection("NotificationService"));

// Configurar RabbitMQ
builder.Services.Configure<RabbitMQSettings>(builder.Configuration.GetSection("RabbitMQ"));
builder.Services.Configure<ErrorServiceRabbitMQSettings>(builder.Configuration.GetSection("ErrorService"));
builder.Services.Configure<NotificationServiceRabbitMQSettings>(builder.Configuration.GetSection("NotificationService"));

// Registrar servicios de RabbitMQ
builder.Services.AddSingleton<IErrorEventProducer, RabbitMQErrorProducer>();
builder.Services.AddSingleton<INotificationEventProducer, RabbitMQNotificationProducer>();

// Registrar AuthNotificationService con el constructor CORRECTO (5 parámetros)
builder.Services.AddScoped<IAuthNotificationService>(provider =>
{
    var notificationClient = provider.GetRequiredService<NotificationServiceClient>();
    var notificationProducer = provider.GetRequiredService<INotificationEventProducer>();
    var settings = provider.GetRequiredService<IOptions<NotificationServiceSettings>>();
    var rabbitMqSettings = provider.GetRequiredService<IOptions<NotificationServiceRabbitMQSettings>>();
    var logger = provider.GetRequiredService<ILogger<AuthNotificationService>>();

    return new AuthNotificationService(
        notificationClient,
        notificationProducer,
        settings,
        rabbitMqSettings,
        logger
    );
});

// 🚨 CONSTRUIR LA APLICACIÓN
var app = builder.Build();

// Migraciones
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;
    try
    {
        var authContext = services.GetRequiredService<ApplicationDbContext>();
        authContext.Database.Migrate();
        Log.Information("AuthService database migrations applied successfully.");
    }
    catch (Exception ex)
    {
        var logger = services.GetRequiredService<ILogger<Program>>();
        logger.LogError(ex, "Error during database migration");
    }
}

// Pipeline
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseMiddleware<ErrorHandlingMiddleware>();
app.UseErrorHandling();
app.UseCors();
app.UseRateLimiter();
app.UseAuthentication();
app.UseAuthorization();

// Health Checks (ahora configurado en Infrastructure)
app.MapHealthChecks("/health");

app.MapControllers();

Log.Information("AuthService starting up...");
app.Run();

---- File: AuthService.Api\Controllers\AuthController.cs ----
using AuthService.Application.Features.Auth.Commands.Login;
using AuthService.Application.Features.Auth.Commands.Register;
using AuthService.Application.Features.Auth.Commands.ForgotPassword;
using AuthService.Application.Features.Auth.Commands.ResetPassword;
using AuthService.Application.Features.Auth.Commands.RefreshToken;
using AuthService.Application.Features.Auth.Commands.Logout;
using AuthService.Application.Features.Auth.Commands.VerifyEmail;
using AuthService.Shared;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.RateLimiting;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
[EnableRateLimiting("AuthPolicy")]
public class AuthController : ControllerBase
{
    private readonly IMediator _mediator;
    public AuthController(IMediator mediator) => _mediator = mediator;

    [HttpPost("register")]
    public async Task<IActionResult> Register([FromBody] RegisterRequest request)
    {
        var command = new RegisterCommand(request.UserName, request.Email, request.Password);
        var result = await _mediator.Send(command);
        return Ok(ApiResponse<RegisterResponse>.Ok(result));
    }

    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginRequest request)
    {
        var command = new LoginCommand(request.Email, request.Password);
        var result = await _mediator.Send(command);
        return Ok(ApiResponse<LoginResponse>.Ok(result));
    }

    [HttpPost("forgot-password")]
    public async Task<IActionResult> ForgotPassword([FromBody] ForgotPasswordRequest request)
    {
        var command = new ForgotPasswordCommand(request.Email);
        var result = await _mediator.Send(command);
        return Ok(ApiResponse<ForgotPasswordResponse>.Ok(result));
    }

    [HttpPost("reset-password")]
    public async Task<IActionResult> ResetPassword([FromBody] ResetPasswordRequest request)
    {
        var command = new ResetPasswordCommand(request.Token, request.NewPassword, request.ConfirmPassword);
        var result = await _mediator.Send(command);
        return Ok(ApiResponse<ResetPasswordResponse>.Ok(result));
    }

    [HttpPost("verify-email")]
    public async Task<IActionResult> VerifyEmail([FromBody] VerifyEmailRequest request)
    {
        var command = new VerifyEmailCommand(request.Token);
        await _mediator.Send(command);
        return Ok(ApiResponse.Ok());
    }

    [HttpPost("refresh-token")]
    [Authorize]
    public async Task<IActionResult> RefreshToken([FromBody] RefreshTokenRequest request)
    {
        var command = new RefreshTokenCommand(request.RefreshToken);
        var result = await _mediator.Send(command);
        return Ok(ApiResponse<RefreshTokenResponse>.Ok(result));
    }

    [HttpPost("logout")]
    [Authorize]
    public async Task<IActionResult> Logout([FromBody] LogoutRequest request)
    {
        var command = new LogoutCommand(request.RefreshToken);
        await _mediator.Send(command);
        return Ok(ApiResponse.Ok());
    }
}

---- File: AuthService.Api\Controllers\ExternalAuthController.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using AuthService.Application.Features.ExternalAuth.Commands.ExternalAuth;
using AuthService.Application.Features.ExternalAuth.Commands.ExternalAuthCallback;
using AuthService.Application.Features.ExternalAuth.Commands.ExternalLogin;
using AuthService.Application.Features.ExternalAuth.Commands.LinkExternalAccount;
using AuthService.Application.Features.ExternalAuth.Commands.UnlinkExternalAccount;
using AuthService.Application.Features.ExternalAuth.Queries.GetLinkedAccounts;
using AuthService.Shared;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.RateLimiting;
using System.Security.Claims;

namespace AuthService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
[EnableRateLimiting("AuthPolicy")]
public class ExternalAuthController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<ExternalAuthController> _logger;

    public ExternalAuthController(IMediator mediator, ILogger<ExternalAuthController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    /// <summary>
    /// Authenticate with external provider using ID token
    /// </summary>
    [HttpPost("authenticate")]
    public async Task<ActionResult<ApiResponse<ExternalAuthResponse>>> Authenticate(
        [FromBody] ExternalAuthRequest request)
    {
        try
        {
            _logger.LogInformation("External authentication attempt with provider: {Provider}", request.Provider);

            var command = new ExternalAuthCommand(request.Provider, request.IdToken);
            var result = await _mediator.Send(command);

            _logger.LogInformation("External authentication successful for user {UserId} with provider {Provider}",
                result.UserId, request.Provider);

            return Ok(ApiResponse<ExternalAuthResponse>.Ok(result, new Dictionary<string, object>
            {
                ["isNewUser"] = result.IsNewUser,
                ["provider"] = request.Provider
            }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "External authentication failed for provider {Provider}", request.Provider);
            return BadRequest(ApiResponse<ExternalAuthResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Initiate external login flow and get authorization URL
    /// </summary>
    [HttpPost("login")]
    public async Task<ActionResult<ApiResponse<ExternalLoginResponse>>> Login(
        [FromBody] ExternalLoginRequest request)
    {
        try
        {
            _logger.LogInformation("Initiating external login flow for provider: {Provider}", request.Provider);

            var command = new ExternalLoginCommand(request.Provider, request.RedirectUri);
            var result = await _mediator.Send(command);

            _logger.LogInformation("External login URL generated for provider {Provider}", request.Provider);

            return Ok(ApiResponse<ExternalLoginResponse>.Ok(result));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "External login initiation failed for provider {Provider}", request.Provider);
            return BadRequest(ApiResponse<ExternalLoginResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Link external account to existing user
    /// </summary>
    [HttpPost("link-account")]
    [Authorize]
    public async Task<ActionResult<ApiResponse<ExternalAuthResponse>>> LinkAccount(
        [FromBody] ExternalAuthRequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<ExternalAuthResponse>.Fail("User not authenticated"));
            }

            _logger.LogInformation("Linking external account for user {UserId} with provider {Provider}",
                userId, request.Provider);

            var command = new LinkExternalAccountCommand(userId, request.Provider, request.IdToken);
            var result = await _mediator.Send(command);

            _logger.LogInformation("External account linked successfully for user {UserId}", userId);

            return Ok(ApiResponse<ExternalAuthResponse>.Ok(result, new Dictionary<string, object>
            {
                ["isLinked"] = true,
                ["provider"] = request.Provider
            }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to link external account for user");
            return BadRequest(ApiResponse<ExternalAuthResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Unlink external account from user
    /// </summary>
    [HttpDelete("unlink-account")]
    [Authorize]
    public async Task<ActionResult<ApiResponse>> UnlinkAccount([FromBody] UnlinkExternalAccountRequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse.Fail("User not authenticated"));
            }

            _logger.LogInformation("Unlinking external account for user {UserId} with provider {Provider}",
                userId, request.Provider);

            var command = new UnlinkExternalAccountCommand(userId, request.Provider);
            await _mediator.Send(command);

            _logger.LogInformation("External account unlinked successfully for user {UserId}", userId);

            return Ok(ApiResponse.Ok(new Dictionary<string, object>
            {
                ["message"] = $"External account from {request.Provider} unlinked successfully",
                ["provider"] = request.Provider
            }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to unlink external account for user");
            return BadRequest(ApiResponse.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Get linked external accounts for current user
    /// </summary>
    [HttpGet("linked-accounts")]
    [Authorize]
    public async Task<ActionResult<ApiResponse<List<LinkedAccountResponse>>>> GetLinkedAccounts()
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<List<LinkedAccountResponse>>.Fail("User not authenticated"));
            }

            _logger.LogInformation("Getting linked accounts for user {UserId}", userId);

            var query = new GetLinkedAccountsQuery(userId);
            var result = await _mediator.Send(query);

            return Ok(ApiResponse<List<LinkedAccountResponse>>.Ok(result));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get linked accounts for user");
            return BadRequest(ApiResponse<List<LinkedAccountResponse>>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Handle external authentication callback
    /// </summary>
    [HttpPost("callback")]
    public async Task<ActionResult<ApiResponse<ExternalAuthResponse>>> Callback(
        [FromBody] ExternalAuthCallbackRequest request)
    {
        try
        {
            _logger.LogInformation("Processing external auth callback for provider: {Provider}", request.Provider);

            var command = new ExternalAuthCallbackCommand(
                request.Provider,
                request.Code,
                request.IdToken,
                request.RedirectUri,
                request.State);

            var result = await _mediator.Send(command);

            _logger.LogInformation("External auth callback processed successfully for user {UserId}",
                result.UserId);

            return Ok(ApiResponse<ExternalAuthResponse>.Ok(result, new Dictionary<string, object>
            {
                ["isNewUser"] = result.IsNewUser,
                ["provider"] = request.Provider
            }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "External auth callback failed for provider {Provider}", request.Provider);
            return BadRequest(ApiResponse<ExternalAuthResponse>.Fail(ex.Message));
        }
    }
}

---- File: AuthService.Api\Controllers\PhoneVerificationController.cs ----
using AuthService.Application.DTOs.Auth;
using AuthService.Application.DTOs.PhoneVerification;
using AuthService.Application.Features.TwoFactor.Commands.SendPhoneVerification;
using AuthService.Application.Features.TwoFactor.Commands.VerifyPhoneNumber;
using AuthService.Shared;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.RateLimiting;
using System.Security.Claims;

namespace AuthService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
[Authorize]
[EnableRateLimiting("AuthPolicy")]
public class PhoneVerificationController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<PhoneVerificationController> _logger;

    public PhoneVerificationController(IMediator mediator, ILogger<PhoneVerificationController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    /// <summary>
    /// Send phone verification code via SMS
    /// </summary>
    [HttpPost("send")]
    public async Task<ActionResult<ApiResponse<SendPhoneVerificationResponse>>> SendVerification(
        [FromBody] SendPhoneVerificationRequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<SendPhoneVerificationResponse>.Fail("User not authenticated"));
            }

            _logger.LogInformation("Sending phone verification code to user {UserId} for phone {PhoneNumber}",
                userId, request.PhoneNumber);

            var command = new SendPhoneVerificationCommand(userId, request.PhoneNumber);
            var result = await _mediator.Send(command);

            _logger.LogInformation("Phone verification code sent successfully to user {UserId}", userId);

            return Ok(ApiResponse<SendPhoneVerificationResponse>.Ok(result, new Dictionary<string, object>
            {
                ["expiresAt"] = result.ExpiresAt,
                ["phoneNumber"] = request.PhoneNumber
            }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send phone verification code for user");
            return BadRequest(ApiResponse<SendPhoneVerificationResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Verify phone number with received code
    /// </summary>
    [HttpPost("verify")]
    public async Task<ActionResult<ApiResponse<VerifyPhoneNumberResponse>>> Verify(
        [FromBody] VerifyPhoneRequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<VerifyPhoneNumberResponse>.Fail("User not authenticated"));
            }

            _logger.LogInformation("Verifying phone number for user {UserId} with code", userId);

            var command = new VerifyPhoneNumberCommand(userId, request.PhoneNumber, request.VerificationCode);
            var result = await _mediator.Send(command);

            if (result.Success && result.IsVerified)
            {
                _logger.LogInformation("Phone number verified successfully for user {UserId}", userId);
                return Ok(ApiResponse<VerifyPhoneNumberResponse>.Ok(result, new Dictionary<string, object>
                {
                    ["isVerified"] = true,
                    ["phoneNumber"] = request.PhoneNumber
                }));
            }
            else
            {
                _logger.LogWarning("Phone number verification failed for user {UserId}", userId);
                return BadRequest(ApiResponse<VerifyPhoneNumberResponse>.Fail(result.Message));
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to verify phone number for user");
            return BadRequest(ApiResponse<VerifyPhoneNumberResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Resend phone verification code
    /// </summary>
    [HttpPost("resend")]
    public async Task<ActionResult<ApiResponse<SendPhoneVerificationResponse>>> ResendVerification(
        [FromBody] ResendPhoneVerificationRequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<SendPhoneVerificationResponse>.Fail("User not authenticated"));
            }

            _logger.LogInformation("Resending phone verification code to user {UserId} for phone {PhoneNumber}",
                userId, request.PhoneNumber);

            var command = new SendPhoneVerificationCommand(userId, request.PhoneNumber);
            var result = await _mediator.Send(command);

            _logger.LogInformation("Phone verification code resent successfully to user {UserId}", userId);

            return Ok(ApiResponse<SendPhoneVerificationResponse>.Ok(result, new Dictionary<string, object>
            {
                ["expiresAt"] = result.ExpiresAt,
                ["phoneNumber"] = request.PhoneNumber,
                ["isResend"] = true
            }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to resend phone verification code for user");
            return BadRequest(ApiResponse<SendPhoneVerificationResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Check if phone number is verified for current user
    /// </summary>
    [HttpGet("status")]
    public async Task<ActionResult<ApiResponse<PhoneVerificationStatusResponse>>> GetVerificationStatus()
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<PhoneVerificationStatusResponse>.Fail("User not authenticated"));
            }

            _logger.LogInformation("Getting phone verification status for user {UserId}", userId);

            // Note: You'll need to create GetPhoneVerificationStatusQuery and its handler
            // var query = new GetPhoneVerificationStatusQuery(userId);
            // var result = await _mediator.Send(query);

            // Placeholder response
            var result = new PhoneVerificationStatusResponse(false, null, DateTime.UtcNow);

            return Ok(ApiResponse<PhoneVerificationStatusResponse>.Ok(result));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get phone verification status for user");
            return BadRequest(ApiResponse<PhoneVerificationStatusResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Update phone number and send verification
    /// </summary>
    [HttpPut("update")]
    public async Task<ActionResult<ApiResponse<SendPhoneVerificationResponse>>> UpdatePhoneNumber(
        [FromBody] UpdatePhoneNumberRequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<SendPhoneVerificationResponse>.Fail("User not authenticated"));
            }

            _logger.LogInformation("Updating phone number for user {UserId} to {NewPhoneNumber}",
                userId, request.NewPhoneNumber);

            // Note: You'll need to create UpdatePhoneNumberCommand and its handler
            // var command = new UpdatePhoneNumberCommand(userId, request.NewPhoneNumber);
            // var result = await _mediator.Send(command);

            // For now, using the send verification command
            var sendCommand = new SendPhoneVerificationCommand(userId, request.NewPhoneNumber);
            var result = await _mediator.Send(sendCommand);

            _logger.LogInformation("Phone number updated and verification sent for user {UserId}", userId);

            return Ok(ApiResponse<SendPhoneVerificationResponse>.Ok(result, new Dictionary<string, object>
            {
                ["expiresAt"] = result.ExpiresAt,
                ["phoneNumber"] = request.NewPhoneNumber,
                ["isUpdate"] = true
            }));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to update phone number for user");
            return BadRequest(ApiResponse<SendPhoneVerificationResponse>.Fail(ex.Message));
        }
    }
}

---- File: AuthService.Api\Controllers\TwoFactorController.cs ----
using AuthService.Application.DTOs.TwoFactor;
using AuthService.Application.Features.TwoFactor.Commands.Disable2FA;
using AuthService.Application.Features.TwoFactor.Commands.Enable2FA;
using AuthService.Application.Features.TwoFactor.Commands.GenerateRecoveryCodes;
using AuthService.Application.Features.TwoFactor.Commands.TwoFactorLogin;
using AuthService.Application.Features.TwoFactor.Commands.Verify2FA;
using AuthService.Application.Features.TwoFactor.Commands.VerifyRecoveryCode;
using AuthService.Shared;
using MediatR;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace AuthService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
[Authorize]
public class TwoFactorController : ControllerBase
{
    private readonly IMediator _mediator;
    private readonly ILogger<TwoFactorController> _logger;

    public TwoFactorController(IMediator mediator, ILogger<TwoFactorController> logger)
    {
        _mediator = mediator;
        _logger = logger;
    }

    /// <summary>
    /// Enable two-factor authentication for the current user
    /// </summary>
    [HttpPost("enable")]
    public async Task<ActionResult<ApiResponse<Enable2FAResponse>>> Enable2FA([FromBody] Enable2FARequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<Enable2FAResponse>.Fail("User not authenticated"));
            }

            var command = new Enable2FACommand(userId, request.Type);
            var result = await _mediator.Send(command);

            _logger.LogInformation("2FA enabled successfully for user {UserId} with type {Type}", userId, request.Type);
            return Ok(ApiResponse<Enable2FAResponse>.Ok(result));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error enabling 2FA for user");
            return BadRequest(ApiResponse<Enable2FAResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Verify two-factor authentication setup
    /// </summary>
    [HttpPost("verify")]
    public async Task<ActionResult<ApiResponse<Verify2FAResponse>>> Verify2FA([FromBody] Verify2FARequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<Verify2FAResponse>.Fail("User not authenticated"));
            }

            var command = new Verify2FACommand(userId, request.Code, request.Type);
            var result = await _mediator.Send(command);

            if (result.Success)
            {
                _logger.LogInformation("2FA verified successfully for user {UserId}", userId);
                return Ok(ApiResponse<Verify2FAResponse>.Ok(result));
            }
            else
            {
                return BadRequest(ApiResponse<Verify2FAResponse>.Fail(result.Message));
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error verifying 2FA for user");
            return BadRequest(ApiResponse<Verify2FAResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Disable two-factor authentication for the current user
    /// </summary>
    [HttpPost("disable")]
    public async Task<ActionResult<ApiResponse<Verify2FAResponse>>> Disable2FA([FromBody] Disable2FARequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<Verify2FAResponse>.Fail("User not authenticated"));
            }

            var command = new Disable2FACommand(userId, request.Password);
            var result = await _mediator.Send(command);

            _logger.LogInformation("2FA disabled successfully for user {UserId}", userId);
            return Ok(ApiResponse<Verify2FAResponse>.Ok(result));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error disabling 2FA for user");
            return BadRequest(ApiResponse<Verify2FAResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Generate new recovery codes for two-factor authentication
    /// </summary>
    [HttpPost("generate-recovery-codes")]
    public async Task<ActionResult<ApiResponse<GenerateRecoveryCodesResponse>>> GenerateRecoveryCodes([FromBody] GenerateRecoveryCodesRequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<GenerateRecoveryCodesResponse>.Fail("User not authenticated"));
            }

            var command = new GenerateRecoveryCodesCommand(userId, request.Password);
            var result = await _mediator.Send(command);

            _logger.LogInformation("Recovery codes generated successfully for user {UserId}", userId);
            return Ok(ApiResponse<GenerateRecoveryCodesResponse>.Ok(result));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating recovery codes for user");
            return BadRequest(ApiResponse<GenerateRecoveryCodesResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Verify a recovery code for two-factor authentication
    /// </summary>
    [HttpPost("verify-recovery-code")]
    [AllowAnonymous]
    public async Task<ActionResult<ApiResponse<Verify2FAResponse>>> VerifyRecoveryCode([FromBody] VerifyRecoveryCodeRequest request)
    {
        try
        {
            var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (string.IsNullOrEmpty(userId))
            {
                return Unauthorized(ApiResponse<Verify2FAResponse>.Fail("User not authenticated"));
            }

            var command = new VerifyRecoveryCodeCommand(userId, request.Code);
            var result = await _mediator.Send(command);

            if (result.Success)
            {
                _logger.LogInformation("Recovery code verified successfully for user {UserId}", userId);
                return Ok(ApiResponse<Verify2FAResponse>.Ok(result));
            }
            else
            {
                return BadRequest(ApiResponse<Verify2FAResponse>.Fail(result.Message));
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error verifying recovery code for user");
            return BadRequest(ApiResponse<Verify2FAResponse>.Fail(ex.Message));
        }
    }

    /// <summary>
    /// Complete two-factor authentication login
    /// </summary>
    [HttpPost("login")]
    [AllowAnonymous]
    public async Task<ActionResult<ApiResponse<TwoFactorLoginResponse>>> TwoFactorLogin([FromBody] TwoFactorLoginRequest request)
    {
        try
        {
            var command = new TwoFactorLoginCommand(request.TempToken, request.TwoFactorCode);
            var result = await _mediator.Send(command);

            _logger.LogInformation("2FA login completed successfully for user {UserId}", result.UserId);
            return Ok(ApiResponse<TwoFactorLoginResponse>.Ok(result));
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during 2FA login");
            return BadRequest(ApiResponse<TwoFactorLoginResponse>.Fail(ex.Message));
        }
    }
}

---- File: AuthService.Application\AuthService.Application.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <!-- Agregar MediatR -->
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="FluentValidation" Version="11.9.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <!-- Referencias a proyectos internos -->
    <ProjectReference Include="..\AuthService.Domain\AuthService.Domain.csproj" />
    <ProjectReference Include="..\AuthService.Shared\AuthService.Shared.csproj" />
    <ProjectReference Include="..\..\ErrorService\ErrorService.Shared\ErrorService.Shared.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Folder Include="Common\Behaviours\" />
    <Folder Include="Common\Mappings\" />
  </ItemGroup>

</Project>

---- File: AuthService.Application\DTOs\Auth\ForgotPasswordRequest.cs ----
namespace AuthService.Application.DTOs.Auth;

public record ForgotPasswordRequest(string Email);

---- File: AuthService.Application\DTOs\Auth\ForgotPasswordResponse.cs ----
// AuthService.Application/DTOs/ForgotPasswordResponse.cs
namespace AuthService.Application.DTOs.Auth;

public record ForgotPasswordResponse(bool Success, string Message);

---- File: AuthService.Application\DTOs\Auth\LoginRequest.cs ----
namespace AuthService.Application.DTOs.Auth;

public record LoginRequest(string Email, string Password);

---- File: AuthService.Application\DTOs\Auth\LoginResponse.cs ----
namespace AuthService.Application.DTOs.Auth;

public record LoginResponse(
    string UserId,
    string Email,
    string AccessToken,
    string RefreshToken,
    DateTime ExpiresAt,
    bool RequiresTwoFactor = false,
    string? TempToken = null
);

---- File: AuthService.Application\DTOs\Auth\LogoutRequest.cs ----
namespace AuthService.Application.DTOs.Auth;

public record LogoutRequest(string RefreshToken);

---- File: AuthService.Application\DTOs\Auth\RefreshTokenRequest.cs ----
namespace AuthService.Application.DTOs.Auth;

public record RefreshTokenRequest(string RefreshToken);

---- File: AuthService.Application\DTOs\Auth\RefreshTokenResponse.cs ----
namespace AuthService.Application.DTOs.Auth;

public record RefreshTokenResponse(
    string AccessToken,
    string RefreshToken,
    DateTime ExpiresAt
);

---- File: AuthService.Application\DTOs\Auth\RegisterRequest.cs ----
namespace AuthService.Application.DTOs.Auth;

public record RegisterRequest(string UserName, string Email, string Password);

---- File: AuthService.Application\DTOs\Auth\RegisterResponse.cs ----
namespace AuthService.Application.DTOs.Auth;

public record RegisterResponse(
    string UserId,
    string UserName,
    string Email,
    string AccessToken,
    string RefreshToken,
    DateTime ExpiresAt
);

---- File: AuthService.Application\DTOs\Auth\ResetPasswordRequest.cs ----
namespace AuthService.Application.DTOs.Auth;

public record ResetPasswordRequest(string Token, string NewPassword, string ConfirmPassword);

---- File: AuthService.Application\DTOs\Auth\ResetPasswordResponse.cs ----
// AuthService.Application/DTOs/ResetPasswordResponse.cs  
namespace AuthService.Application.DTOs.Auth;

public record ResetPasswordResponse(bool Success, string Message);

---- File: AuthService.Application\DTOs\Auth\VerifyEmailRequest.cs ----
namespace AuthService.Application.DTOs.Auth;

public record VerifyEmailRequest(string Token);

---- File: AuthService.Application\DTOs\Auth\VerifyPhoneNumberResponse.cs ----
namespace AuthService.Application.DTOs.Auth;

public record VerifyPhoneNumberResponse(
    bool Success,
    string Message,
    bool IsVerified = false
);

---- File: AuthService.Application\DTOs\ExternalAuth\ExternalAuthCallbackRequest.cs ----
namespace AuthService.Application.DTOs.ExternalAuth;

public record ExternalAuthCallbackRequest(
    string Provider,
    string? Code,
    string? IdToken,
    string? RedirectUri,
    string? State
);

---- File: AuthService.Application\DTOs\ExternalAuth\ExternalAuthRequest.cs ----
namespace AuthService.Application.DTOs.ExternalAuth;

public record ExternalAuthRequest(string Provider, string IdToken);

---- File: AuthService.Application\DTOs\ExternalAuth\ExternalAuthResponse.cs ----
namespace AuthService.Application.DTOs.ExternalAuth;

public record ExternalAuthResponse(
    string UserId,
    string UserName,
    string Email,
    string AccessToken,
    string RefreshToken,
    DateTime ExpiresAt,
    bool IsNewUser = false
);

---- File: AuthService.Application\DTOs\ExternalAuth\ExternalLoginRequest.cs ----
namespace AuthService.Application.DTOs.ExternalAuth;

public record ExternalLoginRequest(string Provider, string RedirectUri);

---- File: AuthService.Application\DTOs\ExternalAuth\ExternalLoginResponse.cs ----
namespace AuthService.Application.DTOs.ExternalAuth;

public record ExternalLoginResponse(string AuthorizationUrl);

---- File: AuthService.Application\DTOs\ExternalAuth\LinkedAccountResponse.cs ----
namespace AuthService.Application.DTOs.ExternalAuth;

public record LinkedAccountResponse(
    string Provider,
    string ExternalUserId,
    string Email,
    DateTime LinkedAt
);

---- File: AuthService.Application\DTOs\ExternalAuth\UnlinkExternalAccountRequest.cs ----
namespace AuthService.Application.DTOs.ExternalAuth;

public record UnlinkExternalAccountRequest(string Provider);

---- File: AuthService.Application\DTOs\PhoneVerification\PhoneVerificationStatusResponse.cs ----

namespace AuthService.Application.DTOs.PhoneVerification;

public record PhoneVerificationStatusResponse(
    bool IsVerified,
    string? PhoneNumber,
    DateTime LastUpdated
);

---- File: AuthService.Application\DTOs\PhoneVerification\ResendPhoneVerificationRequest.cs ----

namespace AuthService.Application.DTOs.PhoneVerification;

public record ResendPhoneVerificationRequest(string PhoneNumber);

---- File: AuthService.Application\DTOs\PhoneVerification\SendPhoneVerificationRequest.cs ----

namespace AuthService.Application.DTOs.PhoneVerification;

public record SendPhoneVerificationRequest(string PhoneNumber);




---- File: AuthService.Application\DTOs\PhoneVerification\SendPhoneVerificationResponse.cs ----
namespace AuthService.Application.DTOs.PhoneVerification;

public record SendPhoneVerificationResponse(
    bool Success,
    string Message,
    DateTime? ExpiresAt = null
);

---- File: AuthService.Application\DTOs\PhoneVerification\UpdatePhoneNumberRequest.cs ----

namespace AuthService.Application.DTOs.PhoneVerification;

public record UpdatePhoneNumberRequest(string NewPhoneNumber);

---- File: AuthService.Application\DTOs\PhoneVerification\VerifyPhoneRequest.cs ----

namespace AuthService.Application.DTOs.PhoneVerification;

public record VerifyPhoneRequest(string PhoneNumber, string VerificationCode);

---- File: AuthService.Application\DTOs\TwoFactor\Add2FAMethodRequest.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Application.DTOs.TwoFactor;

public record Add2FAMethodRequest(
    string UserId,
    string Password,
    TwoFactorAuthType Method,
    string? PhoneNumber = null
);

---- File: AuthService.Application\DTOs\TwoFactor\Change2FAMethodRequest.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Application.DTOs.TwoFactor;

public record Change2FAMethodRequest(
    string UserId,
    string Password,
    TwoFactorAuthType NewMethod,
    string? PhoneNumber = null
);


---- File: AuthService.Application\DTOs\TwoFactor\Change2FAMethodResponse.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Application.DTOs.TwoFactor;

public record Change2FAMethodResponse(
    bool Success,
    string Message,
    string? Secret = null,
    string? QrCodeUri = null,
    string? PhoneNumber = null
);

---- File: AuthService.Application\DTOs\TwoFactor\Disable2FARequest.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record Disable2FARequest(
    string Password
);

---- File: AuthService.Application\DTOs\TwoFactor\Enable2FARequest.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Application.DTOs.TwoFactor;

public record Enable2FARequest(
    string UserId,
    TwoFactorAuthType Type
);

---- File: AuthService.Application\DTOs\TwoFactor\Enable2FAResponse.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record Enable2FAResponse(
    string Secret,
    string QrCodeUri,
    List<string> RecoveryCodes,
    string Message = "Two-factor authentication setup completed successfully. Please verify your authenticator app."
);

---- File: AuthService.Application\DTOs\TwoFactor\GenerateRecoveryCodesRequest.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record GenerateRecoveryCodesRequest(
    string UserId,
    string Password
);

---- File: AuthService.Application\DTOs\TwoFactor\GenerateRecoveryCodesResponse.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record GenerateRecoveryCodesResponse(
    List<string> RecoveryCodes,
    string Message = "Recovery codes generated successfully. Please save them in a secure place."
);

---- File: AuthService.Application\DTOs\TwoFactor\Get2FAMethodsResponse.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Application.DTOs.TwoFactor;

public record Get2FAMethodsResponse(
    string UserId,
    TwoFactorAuthType PrimaryMethod,
    List<TwoFactorAuthType> EnabledMethods,
    bool IsEnabled,
    bool HasPhoneNumber,
    bool HasAuthenticator
);

---- File: AuthService.Application\DTOs\TwoFactor\TwoFactorLoginRequest.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record TwoFactorLoginRequest(
    string TempToken,
    string TwoFactorCode
);

---- File: AuthService.Application\DTOs\TwoFactor\TwoFactorLoginResponse.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record TwoFactorLoginResponse(
    string UserId,
    string Email,
    string AccessToken,
    string RefreshToken,
    DateTime ExpiresAt,
    bool IsTwoFactorEnabled = true
);

---- File: AuthService.Application\DTOs\TwoFactor\TwoFactorRequiredResponse.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record TwoFactorRequiredResponse(
    string UserId,
    string TempToken,
    DateTime ExpiresAt,
    string[] AvailableMethods,
    string Message = "Two-factor authentication required"
);

---- File: AuthService.Application\DTOs\TwoFactor\Verify2FARequest.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Application.DTOs.TwoFactor;

public record Verify2FARequest(
    string UserId,
    string Code,
    TwoFactorAuthType Type
);

---- File: AuthService.Application\DTOs\TwoFactor\Verify2FAResponse.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record Verify2FAResponse(
    bool Success,
    string Message,
    bool IsSetupComplete = false
);

---- File: AuthService.Application\DTOs\TwoFactor\VerifyRecoveryCodeRequest.cs ----
namespace AuthService.Application.DTOs.TwoFactor;

public record VerifyRecoveryCodeRequest(
    string Code
);

---- File: AuthService.Application\Features\Auth\Commands\ForgotPassword\ForgotPasswordCommand.cs ----
using MediatR;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.Auth.Commands.ForgotPassword;

public record ForgotPasswordCommand(string Email) : IRequest<ForgotPasswordResponse>;

---- File: AuthService.Application\Features\Auth\Commands\ForgotPassword\ForgotPasswordCommandHandler.cs ----
using MediatR;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using Microsoft.Extensions.Logging;
using ErrorService.Shared.Exceptions;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.Auth.Commands.ForgotPassword;

public class ForgotPasswordCommandHandler : IRequestHandler<ForgotPasswordCommand, ForgotPasswordResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IAuthNotificationService _notificationService;
    private readonly IPasswordResetTokenService _tokenService;
    private readonly ILogger<ForgotPasswordCommandHandler> _logger;

    public ForgotPasswordCommandHandler(
      IUserRepository userRepository,
      IAuthNotificationService notificationService,
      IPasswordResetTokenService tokenService,
      ILogger<ForgotPasswordCommandHandler> logger)
    {
        _userRepository = userRepository;
        _notificationService = notificationService;
        _tokenService = tokenService;
        _logger = logger;
    }

    public async Task<ForgotPasswordResponse> Handle(ForgotPasswordCommand request, CancellationToken cancellationToken)
    {
        try
        {
            var user = await _userRepository.GetByEmailAsync(request.Email);

            // Por seguridad, siempre devolvemos éxito incluso si el email no existe
            if (user == null)
            {
                _logger.LogInformation("Password reset requested for non-existent email: {Email}", request.Email);
                return new ForgotPasswordResponse(true, "If the email exists, a reset link has been sent.");
            }

            // Generar token de reset
            var resetToken = _tokenService.GenerateResetToken(request.Email);

            // Enviar email
            await _notificationService.SendPasswordResetEmailAsync(request.Email, resetToken);

            _logger.LogInformation("Password reset email sent to {Email}", request.Email);

            return new ForgotPasswordResponse(true, "Password reset email sent successfully.");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing password reset for {Email}", request.Email);
            throw new ServiceUnavailableException("An error occurred while processing your request.");
        }
    }
}

---- File: AuthService.Application\Features\Auth\Commands\ForgotPassword\ForgotPasswordCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.Auth.Commands.ForgotPassword;

public class ForgotPasswordCommandValidator : AbstractValidator<ForgotPasswordCommand>
{
    public ForgotPasswordCommandValidator()
    {
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("Email is required")
            .EmailAddress().WithMessage("Invalid email address format")
            .MaximumLength(255).WithMessage("Email cannot exceed 255 characters");
    }
}

---- File: AuthService.Application\Features\Auth\Commands\Login\LoginCommand.cs ----
using AuthService.Application.DTOs.Auth;
using MediatR;

namespace AuthService.Application.Features.Auth.Commands.Login;

public record LoginCommand(string Email, string Password) : IRequest<LoginResponse>;

---- File: AuthService.Application\Features\Auth\Commands\Login\LoginCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using RefreshTokenEntity = AuthService.Domain.Entities.RefreshToken;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.Auth.Commands.Login;

public class LoginCommandHandler : IRequestHandler<LoginCommand, LoginResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher _passwordHasher;
    private readonly IJwtGenerator _jwtGenerator;
    private readonly IRefreshTokenRepository _refreshTokenRepository;

    public LoginCommandHandler(
        IUserRepository userRepository,
        IPasswordHasher passwordHasher,
        IJwtGenerator jwtGenerator,
        IRefreshTokenRepository refreshTokenRepository)
    {
        _userRepository = userRepository;
        _passwordHasher = passwordHasher;
        _jwtGenerator = jwtGenerator;
        _refreshTokenRepository = refreshTokenRepository;
    }

    public async Task<LoginResponse> Handle(LoginCommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByEmailAsync(request.Email, cancellationToken)
                   ?? throw new UnauthorizedException("Invalid credentials.");

        // Verificar que PasswordHash no sea nulo
        if (string.IsNullOrEmpty(user.PasswordHash))
            throw new UnauthorizedException("Invalid credentials.");

        if (!_passwordHasher.Verify(request.Password, user.PasswordHash))
            throw new UnauthorizedException("Invalid credentials.");

        if (!user.EmailConfirmed)
            throw new UnauthorizedException("Please verify your email before logging in.");

        if (user.IsLockedOut())
            throw new UnauthorizedException("Account is temporarily locked. Please try again later.");

        // Verificar si requiere 2FA
        if (user.IsTwoFactorEnabled)
        {
            // Generar token temporal para 2FA
            var tempToken = _jwtGenerator.GenerateTempToken(user.Id);

            return new LoginResponse(
                user.Id,
                user.Email!,
                string.Empty, // No access token yet
                string.Empty, // No refresh token yet
                DateTime.UtcNow.AddMinutes(5), // Short expiration for 2FA
                true, // requiresTwoFactor
                tempToken
            );
        }

        // Flujo normal sin 2FA
        var accessToken = _jwtGenerator.GenerateToken(user);
        var refreshTokenValue = _jwtGenerator.GenerateRefreshToken();
        var expiresAt = DateTime.UtcNow.AddMinutes(60);

        var refreshTokenEntity = new RefreshTokenEntity(
            user.Id,
            refreshTokenValue,
            DateTime.UtcNow.AddDays(7),
            "127.0.0.1"
        );

        await _refreshTokenRepository.AddAsync(refreshTokenEntity, cancellationToken);
        user.ResetAccessFailedCount();
        await _userRepository.UpdateAsync(user, cancellationToken);

        return new LoginResponse(
            user.Id,
            user.Email!,
            accessToken,
            refreshTokenValue,
            expiresAt,
            false // requiresTwoFactor
        );
    }
}

---- File: AuthService.Application\Features\Auth\Commands\Login\LoginCommandValidator.cs ----
// File: backend/AuthService/AuthService.Application/UseCases/Login/LoginCommandValidator.cs
using FluentValidation;
using AuthService.Application.Features.Auth.Commands.Login;

public class LoginCommandValidator : AbstractValidator<LoginCommand>
{
    public LoginCommandValidator()
    {
        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("This field is required.")
            .EmailAddress().WithMessage("Invalid email format.")
            .Matches(@"^[^@\s]+@[^@\s]+\.[^@\s]+$")
                .WithMessage("Email must be in the format name@example.com.");

        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("This field is required.")
            .MinimumLength(8).WithMessage("Password must be at least 8 characters long.")
            .Matches(@"^(?=.*[A-Z])(?=.*\d).+$")
                .WithMessage("Password must include at least one uppercase letter and one number.");
    }
}

---- File: AuthService.Application\Features\Auth\Commands\Logout\LogoutCommand.cs ----
using MediatR;

namespace AuthService.Application.Features.Auth.Commands.Logout;

public record LogoutCommand(string RefreshToken) : IRequest<Unit>;

---- File: AuthService.Application\Features\Auth\Commands\Logout\LogoutCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Interfaces.Repositories;
using MediatR;

namespace AuthService.Application.Features.Auth.Commands.Logout;

public class LogoutCommandHandler : IRequestHandler<LogoutCommand, Unit>
{
    private readonly IRefreshTokenRepository _refreshTokenRepository;

    public LogoutCommandHandler(IRefreshTokenRepository refreshTokenRepository)
    {
        _refreshTokenRepository = refreshTokenRepository;
    }

    public async Task<Unit> Handle(LogoutCommand request, CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(request.RefreshToken))
            throw new BadRequestException("Refresh token is required.");

        var storedToken = await _refreshTokenRepository.GetByTokenAsync(request.RefreshToken, cancellationToken);

        if (storedToken != null && !storedToken.IsRevoked)
        {
            storedToken.Revoke("logout", "user");
            await _refreshTokenRepository.UpdateAsync(storedToken, cancellationToken);
        }

        return Unit.Value;
    }
}

---- File: AuthService.Application\Features\Auth\Commands\Logout\LogoutCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.Auth.Commands.Logout;

public class LogoutCommandValidator : AbstractValidator<LogoutCommand>
{
    public LogoutCommandValidator()
    {
        RuleFor(x => x.RefreshToken)
            .NotEmpty().WithMessage("Refresh token is required.");
    }
}

---- File: AuthService.Application\Features\Auth\Commands\RefreshToken\RefreshTokenCommand.cs ----
using AuthService.Application.DTOs.Auth;
using MediatR;

namespace AuthService.Application.Features.Auth.Commands.RefreshToken;

public record RefreshTokenCommand(string RefreshToken) : IRequest<RefreshTokenResponse>;

---- File: AuthService.Application\Features\Auth\Commands\RefreshToken\RefreshTokenCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.Auth.Commands.RefreshToken;

public class RefreshTokenCommandHandler : IRequestHandler<RefreshTokenCommand, RefreshTokenResponse>
{
    private readonly IRefreshTokenRepository _refreshTokenRepository;
    private readonly IUserRepository _userRepository;
    private readonly IJwtGenerator _jwtGenerator;

    public RefreshTokenCommandHandler(
        IRefreshTokenRepository refreshTokenRepository,
        IUserRepository userRepository,
        IJwtGenerator jwtGenerator)
    {
        _refreshTokenRepository = refreshTokenRepository;
        _userRepository = userRepository;
        _jwtGenerator = jwtGenerator;
    }

    public async Task<RefreshTokenResponse> Handle(RefreshTokenCommand request, CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(request.RefreshToken))
            throw new BadRequestException("Refresh token is required.");

        var storedToken = await _refreshTokenRepository.GetByTokenAsync(request.RefreshToken, cancellationToken)
                          ?? throw new UnauthorizedException("Invalid refresh token.");

        if (storedToken.IsRevoked)
            throw new UnauthorizedException("Refresh token has been revoked.");

        if (storedToken.IsExpired)
            throw new UnauthorizedException("Refresh token has expired.");

        var user = await _userRepository.GetByIdAsync(storedToken.UserId, cancellationToken)
                   ?? throw new NotFoundException("User not found.");

        if (user.IsLockedOut())
            throw new UnauthorizedException("Account is locked.");

        // Generate new access token
        var newAccessToken = _jwtGenerator.GenerateToken(user);
        var expiresAt = DateTime.UtcNow.AddMinutes(60);

        // Rotate refresh token
        var newRefreshTokenValue = _jwtGenerator.GenerateRefreshToken();

        // Revoke old token and save new one
        storedToken.Revoke("rotated", "system", newRefreshTokenValue);

        // Usar nombre completo para evitar conflicto
        var newRefreshTokenEntity = new Domain.Entities.RefreshToken(
            user.Id,
            newRefreshTokenValue,
            DateTime.UtcNow.AddDays(7),
            "127.0.0.1" // TODO: Get actual IP from context
        );

        await _refreshTokenRepository.UpdateAsync(storedToken, cancellationToken);
        await _refreshTokenRepository.AddAsync(newRefreshTokenEntity, cancellationToken);

        return new RefreshTokenResponse(
            newAccessToken,
            newRefreshTokenValue,
            expiresAt
        );
    }
}

---- File: AuthService.Application\Features\Auth\Commands\RefreshToken\RefreshTokenCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.Auth.Commands.RefreshToken;

public class RefreshTokenCommandValidator : AbstractValidator<RefreshTokenCommand>
{
    public RefreshTokenCommandValidator()
    {
        RuleFor(x => x.RefreshToken)
            .NotEmpty().WithMessage("Refresh token is required.");
    }
}

---- File: AuthService.Application\Features\Auth\Commands\Register\RegisterCommand.cs ----
using AuthService.Application.DTOs.Auth;
using MediatR;

namespace AuthService.Application.Features.Auth.Commands.Register;

public record RegisterCommand(string UserName, string Email, string Password)
    : IRequest<RegisterResponse>;

---- File: AuthService.Application\Features\Auth\Commands\Register\RegisterCommandHandler.cs ----
// AuthService.Application/UseCases/Register/RegisterCommandHandler.cs
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using RefreshTokenEntity = AuthService.Domain.Entities.RefreshToken;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.Auth.Commands.Register;

public class RegisterCommandHandler : IRequestHandler<RegisterCommand, RegisterResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher _passwordHasher;
    private readonly IJwtGenerator _jwtGenerator;
    private readonly IRefreshTokenRepository _refreshTokenRepository;
    private readonly IVerificationTokenRepository _verificationTokenRepository;
    private readonly IAuthNotificationService _notificationService;

    public RegisterCommandHandler(
        IUserRepository userRepository,
        IPasswordHasher passwordHasher,
        IJwtGenerator jwtGenerator,
        IRefreshTokenRepository refreshTokenRepository,
        IVerificationTokenRepository verificationTokenRepository,
        IAuthNotificationService notificationService)
    {
        _userRepository = userRepository;
        _passwordHasher = passwordHasher;
        _jwtGenerator = jwtGenerator;
        _refreshTokenRepository = refreshTokenRepository;
        _verificationTokenRepository = verificationTokenRepository;
        _notificationService = notificationService;
    }

    public async Task<RegisterResponse> Handle(RegisterCommand request, CancellationToken cancellationToken)
    {
        // Check if user already exists
        var existingUser = await _userRepository.GetByEmailAsync(request.Email, cancellationToken);
        if (existingUser != null)
            throw new ConflictException("User with this email already exists.");

        // Hash password
        var passwordHash = _passwordHasher.Hash(request.Password);

        // Create user
        var user = new ApplicationUser(request.UserName, request.Email, passwordHash);
        await _userRepository.AddAsync(user, cancellationToken);

        // Generate tokens
        var accessToken = _jwtGenerator.GenerateToken(user);
        var refreshTokenValue = _jwtGenerator.GenerateRefreshToken();
        var expiresAt = DateTime.UtcNow.AddMinutes(60);

        // Save refresh token
        var refreshTokenEntity = new RefreshTokenEntity(
            user.Id,
            refreshTokenValue,
            DateTime.UtcNow.AddDays(7),
            "127.0.0.1" // TODO: Get actual IP from context
        );

        await _refreshTokenRepository.AddAsync(refreshTokenEntity, cancellationToken);

        // Create verification token and send email
        var verificationToken = new VerificationToken(
            user.Id,
            VerificationTokenType.EmailVerification,
            TimeSpan.FromHours(24)
        );

        await _verificationTokenRepository.AddAsync(verificationToken);

        // CORRECCIÓN: Usar operador de supresión nula (!) ya que sabemos que no son nulos
        await _notificationService.SendEmailConfirmationAsync(user.Email!, verificationToken.Token);

        // Send welcome email
        await _notificationService.SendWelcomeEmailAsync(user.Email!, user.UserName!);

        // CORRECCIÓN: Usar operador de supresión nula (!) para evitar warnings
        return new RegisterResponse(
            user.Id,
            user.UserName!,
            user.Email!,
            accessToken,
            refreshTokenValue,
            expiresAt
        );
    }
}

---- File: AuthService.Application\Features\Auth\Commands\Register\RegisterCommandValidator.cs ----
// File: backend/AuthService/AuthService.Application/UseCases/Register/RegisterCommandValidator.cs
using FluentValidation;
using AuthService.Application.Features.Auth.Commands.Register;

public class RegisterCommandValidator: AbstractValidator<RegisterCommand>
{
    public RegisterCommandValidator()
    {
        RuleFor(x => x.UserName)
            .NotEmpty().WithMessage("This field is required.");

        RuleFor(x => x.Email)
            .NotEmpty().WithMessage("This field is required.")
            .EmailAddress().WithMessage("Invalid email format.")
            .Matches(@"^[^@\s]+@[^@\s]+\.[^@\s]+$")
                .WithMessage("Email must be in the format name@example.com.");

        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("This field is required.")
            .MinimumLength(8).WithMessage("Password must be at least 8 characters long.")
            .Matches(@"^(?=.*[A-Z])(?=.*\d).+$")
                .WithMessage("Password must include at least one uppercase letter and one number.");
    }
}

---- File: AuthService.Application\Features\Auth\Commands\ResetPassword\ResetPasswordCommand.cs ----
using MediatR;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.Auth.Commands.ResetPassword;

public record ResetPasswordCommand(string Token, string NewPassword, string ConfirmPassword)
    : IRequest<ResetPasswordResponse>;

---- File: AuthService.Application\Features\Auth\Commands\ResetPassword\ResetPasswordCommandHandler.cs ----
using MediatR;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using Microsoft.Extensions.Logging;
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Exceptions;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.Auth.Commands.ResetPassword;

public class ResetPasswordCommandHandler : IRequestHandler<ResetPasswordCommand, ResetPasswordResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher _passwordHasher;
    private readonly IPasswordResetTokenService _tokenService;
    private readonly ILogger<ResetPasswordCommandHandler> _logger;

    public ResetPasswordCommandHandler(
      IUserRepository userRepository,
      IPasswordHasher passwordHasher,
      IPasswordResetTokenService tokenService,
      ILogger<ResetPasswordCommandHandler> logger)
    {
        _userRepository = userRepository;
        _passwordHasher = passwordHasher;
        _tokenService = tokenService;
        _logger = logger;
    }

    public async Task<ResetPasswordResponse> Handle(ResetPasswordCommand request, CancellationToken cancellationToken)
    {
        try
        {
            // Validar token
            if (!_tokenService.ValidateResetToken(request.Token, out var email))
            {
                throw new BadRequestException("Invalid or expired reset token.");
            }

            // Verificar que el token es válido para el email
            if (!await _tokenService.IsTokenValidAsync(email, request.Token))
            {
                throw new BadRequestException("Invalid or expired reset token.");
            }

            // Buscar usuario
            var user = await _userRepository.GetByEmailAsync(email);
            if (user == null)
            {
                throw new NotFoundException("User not found.");
            }

            // <--- CORRECCIÓN: Pasa la contraseña en texto plano y el hasher.
            // La entidad ApplicationUser se encarga de hashear y verificar.
            user.UpdatePassword(request.NewPassword, _passwordHasher);
            await _userRepository.UpdateAsync(user);

            // Invalidar token
            await _tokenService.InvalidateTokenAsync(email);

            _logger.LogInformation("Password reset successfully for user {Email}", email);

            return new ResetPasswordResponse(true, "Password reset successfully.");
        }
        catch (AppException) // Excepciones como BadRequest, NotFound
        {
            throw;
        }
        catch (DomainException ex) // Ej: "La nueva contraseña no puede ser igual a la anterior"
        {
            throw new BadRequestException(ex.Message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error resetting password with token");
            throw new ServiceUnavailableException("An error occurred while resetting your password.");
        }
    }
}

---- File: AuthService.Application\Features\Auth\Commands\ResetPassword\ResetPasswordCommandValidator.cs ----
using FluentValidation;
using AuthService.Application.Features.Auth.Commands.ResetPassword;

public class ResetPasswordCommandValidator : AbstractValidator<ResetPasswordCommand>
{
    public ResetPasswordCommandValidator()
    {
        RuleFor(x => x.Token)
            .NotEmpty().WithMessage("Reset token is required.");

        RuleFor(x => x.NewPassword)
            .NotEmpty().WithMessage("New password is required.")
            .MinimumLength(8).WithMessage("Password must be at least 8 characters long.")
            .Matches(@"^(?=.*[A-Z])(?=.*\d).+$")
                .WithMessage("Password must include at least one uppercase letter and one number.");
    }
}

---- File: AuthService.Application\Features\Auth\Commands\VerifyEmail\VerifyEmailCommand.cs ----
using MediatR;

namespace AuthService.Application.Features.Auth.Commands.VerifyEmail;

public record VerifyEmailCommand(string Token) : IRequest<Unit>;

---- File: AuthService.Application\Features\Auth\Commands\VerifyEmail\VerifyEmailCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Interfaces.Services;
using MediatR;

namespace AuthService.Application.Features.Auth.Commands.VerifyEmail;

public class VerifyEmailCommandHandler : IRequestHandler<VerifyEmailCommand, Unit>
{
    private readonly IEmailVerificationService _emailVerificationService;

    public VerifyEmailCommandHandler(IEmailVerificationService emailVerificationService)
    {
        _emailVerificationService = emailVerificationService;
    }

    public async Task<Unit> Handle(VerifyEmailCommand request, CancellationToken cancellationToken)
    {
        var success = await _emailVerificationService.VerifyAsync(request.Token);

        if (!success)
            throw new BadRequestException("Invalid or expired verification token.");

        return Unit.Value;
    }
}

---- File: AuthService.Application\Features\Auth\Commands\VerifyEmail\VerifyEmailCommandValidator.cs ----
using FluentValidation;
using AuthService.Application.Features.Auth.Commands.VerifyEmail;

public class VerifyEmailCommandValidator : AbstractValidator<VerifyEmailCommand>
{
    public VerifyEmailCommandValidator()
    {
        RuleFor(x => x.Token)
            .NotEmpty().WithMessage("Verification token is required.");
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\ExternalAuth\ExternalAuthCommand.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using MediatR;

namespace AuthService.Application.Features.ExternalAuth.Commands.ExternalAuth;


public record ExternalAuthCommand(string Provider, string IdToken) : IRequest<ExternalAuthResponse>;

---- File: AuthService.Application\Features\ExternalAuth\Commands\ExternalAuth\ExternalAuthCommandHandler.cs ----
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Services;
using AuthService.Domain.Interfaces.Repositories;
using MediatR;
using AuthService.Application.DTOs.ExternalAuth;
using ErrorService.Shared.Exceptions;
using Microsoft.Extensions.Logging;

namespace AuthService.Application.Features.ExternalAuth.Commands.ExternalAuth;

public class ExternalAuthCommandHandler : IRequestHandler<ExternalAuthCommand, ExternalAuthResponse>
{
    private readonly IExternalAuthService _externalAuthService;
    private readonly IJwtGenerator _jwtGenerator;
    private readonly IRefreshTokenRepository _refreshTokenRepository;
    private readonly ILogger<ExternalAuthCommandHandler> _logger;

    public ExternalAuthCommandHandler(
        IExternalAuthService externalAuthService,
        IJwtGenerator jwtGenerator,
        IRefreshTokenRepository refreshTokenRepository,
        ILogger<ExternalAuthCommandHandler> logger)
    {
        _externalAuthService = externalAuthService;
        _jwtGenerator = jwtGenerator;
        _refreshTokenRepository = refreshTokenRepository;
        _logger = logger;
    }

    public async Task<ExternalAuthResponse> Handle(ExternalAuthCommand request, CancellationToken cancellationToken)
    {
        // Validar provider
        if (!Enum.TryParse<ExternalAuthProvider>(request.Provider, true, out var provider))
            throw new BadRequestException($"Unsupported provider: {request.Provider}");

        // Autenticar con proveedor externo
        var (user, isNewUser) = await _externalAuthService.AuthenticateAsync(provider, request.IdToken);

        if (user.IsLockedOut())
            throw new UnauthorizedException("Account is temporarily locked. Please try again later.");

        // Generar tokens
        var accessToken = _jwtGenerator.GenerateToken(user);
        var refreshTokenValue = _jwtGenerator.GenerateRefreshToken();
        var expiresAt = DateTime.UtcNow.AddMinutes(60);

        var refreshTokenEntity = new Domain.Entities.RefreshToken(
            user.Id,
            refreshTokenValue,
            DateTime.UtcNow.AddDays(7),
            "127.0.0.1" // TODO: Get actual IP from context
        );

        await _refreshTokenRepository.AddAsync(refreshTokenEntity, cancellationToken);

        _logger.LogInformation("External authentication successful for user {Email} with provider {Provider}",
            user.Email, provider);

        return new ExternalAuthResponse(
            user.Id,
            user.UserName!,
            user.Email!,
            accessToken,
            refreshTokenValue,
            expiresAt,
            isNewUser
        );
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\ExternalAuth\ExternalAuthCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.ExternalAuth.Commands.ExternalAuth;

public class ExternalAuthCommandValidator : AbstractValidator<ExternalAuthCommand>
{
    public ExternalAuthCommandValidator()
    {
        RuleFor(x => x.Provider)
            .NotEmpty().WithMessage("Provider is required")
            .Must(BeValidProvider).WithMessage("Provider must be either 'Google' or 'Microsoft'");

        RuleFor(x => x.IdToken)
            .NotEmpty().WithMessage("ID token is required")
            .MinimumLength(10).WithMessage("Invalid ID token");
    }

    private bool BeValidProvider(string provider)
    {
        return provider.Equals("Google", StringComparison.OrdinalIgnoreCase) ||
               provider.Equals("Microsoft", StringComparison.OrdinalIgnoreCase);
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\ExternalAuthCallback\ExternalAuthCallbackCommand.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using MediatR;

namespace AuthService.Application.Features.ExternalAuth.Commands.ExternalAuthCallback;

public record ExternalAuthCallbackCommand(
    string Provider,
    string? Code,
    string? IdToken,
    string? RedirectUri,
    string? State)
    : IRequest<ExternalAuthResponse>;

---- File: AuthService.Application\Features\ExternalAuth\Commands\ExternalAuthCallback\ExternalAuthCallbackCommandHandler.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using Microsoft.Extensions.Logging;
using AuthService.Application.Features.ExternalAuth.Commands.ExternalAuth;

namespace AuthService.Application.Features.ExternalAuth.Commands.ExternalAuthCallback;

public class ExternalAuthCallbackCommandHandler : IRequestHandler<ExternalAuthCallbackCommand, ExternalAuthResponse>
{
    private readonly IExternalAuthService _externalAuthService;
    private readonly ILogger<ExternalAuthCallbackCommandHandler> _logger;

    public ExternalAuthCallbackCommandHandler(
        IExternalAuthService externalAuthService,
        ILogger<ExternalAuthCallbackCommandHandler> logger)
    {
        _externalAuthService = externalAuthService;
        _logger = logger;
    }

    public async Task<ExternalAuthResponse> Handle(ExternalAuthCallbackCommand request, CancellationToken cancellationToken)
    {
        try
        {
            // Validate provider
            if (!Enum.TryParse<ExternalAuthProvider>(request.Provider, true, out var provider))
                throw new ArgumentException($"Unsupported provider: {request.Provider}");

            string idToken;

            // If we have a code, we need to exchange it for an ID token
            if (!string.IsNullOrEmpty(request.Code))
            {
                idToken = await ExchangeCodeForIdToken(provider, request.Code, request.RedirectUri);
            }
            else if (!string.IsNullOrEmpty(request.IdToken))
            {
                idToken = request.IdToken;
            }
            else
            {
                throw new ArgumentException("Either Code or IdToken must be provided");
            }

            // Use the existing ExternalAuthCommand flow
            var authCommand = new ExternalAuthCommand(
                request.Provider, idToken);

            // Since we can't directly call another handler, we'll simulate the flow
            // In a real scenario, you might refactor to use a shared service
            var (user, isNewUser) = await _externalAuthService.AuthenticateAsync(provider, idToken);

            _logger.LogInformation("External auth callback processed successfully for user {UserId}",
                user.Id);

            // Return a response (you would generate actual tokens here)
            return new ExternalAuthResponse(
                user.Id,
                user.UserName!,
                user.Email!,
                "access_token_placeholder", // Generate actual token
                "refresh_token_placeholder", // Generate actual token
                DateTime.UtcNow.AddHours(1),
                isNewUser
            );
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing external auth callback for provider {Provider}",
                request.Provider);
            throw;
        }
    }

    private async Task<string> ExchangeCodeForIdToken(ExternalAuthProvider provider, string code, string? redirectUri)
    {
        // Implement OAuth code exchange logic here
        // This would make a server-side call to the provider's token endpoint
        // For now, return a placeholder
        _logger.LogInformation("Exchanging code for ID token for provider {Provider}", provider);

        // TODO: Implement actual OAuth code exchange
        await Task.Delay(100); // Simulate async work

        return $"id_token_placeholder_for_{provider}";
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\ExternalLogin\ExternalLoginCommand.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using MediatR;

namespace AuthService.Application.Features.ExternalAuth.Commands.ExternalLogin;

public record ExternalLoginCommand(string Provider, string RedirectUri): IRequest<ExternalLoginResponse>;

---- File: AuthService.Application\Features\ExternalAuth\Commands\ExternalLogin\ExternalLoginCommandHandler.cs ----
using FluentValidation;

namespace AuthService.Application.Features.ExternalAuth.Commands.ExternalLogin;

public class ExternalLoginCommandValidator : AbstractValidator<ExternalLoginCommand>
{
    public ExternalLoginCommandValidator()
    {
        RuleFor(x => x.Provider)
            .NotEmpty().WithMessage("Provider is required")
            .Must(BeValidProvider).WithMessage("Provider must be either 'Google', 'Microsoft', or 'Facebook'");

        RuleFor(x => x.RedirectUri)
            .NotEmpty().WithMessage("Redirect URI is required")
            .Must(BeValidUri).WithMessage("Redirect URI must be a valid URL");
    }

    private bool BeValidProvider(string provider)
    {
        return provider.Equals("Google", StringComparison.OrdinalIgnoreCase) ||
               provider.Equals("Microsoft", StringComparison.OrdinalIgnoreCase) ||
               provider.Equals("Facebook", StringComparison.OrdinalIgnoreCase);
    }

    private bool BeValidUri(string uri)
    {
        return Uri.TryCreate(uri, UriKind.Absolute, out _);
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\ExternalLogin\ExternalLoginCommandValidator.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuthService.Application.Features.ExternalAuth.Commands.ExternalLogin;

public class ExternalLoginCommandHandler : IRequestHandler<ExternalLoginCommand, ExternalLoginResponse>
{
    private readonly IExternalAuthService _externalAuthService;
    private readonly ILogger<ExternalLoginCommandHandler> _logger;

    public ExternalLoginCommandHandler(
        IExternalAuthService externalAuthService,
        ILogger<ExternalLoginCommandHandler> logger)
    {
        _externalAuthService = externalAuthService;
        _logger = logger;
    }

    public Task<ExternalLoginResponse> Handle(ExternalLoginCommand request, CancellationToken cancellationToken)
    {
        try
        {
            // Generate authorization URL for the external provider
            var authorizationUrl = GenerateAuthorizationUrl(request.Provider, request.RedirectUri);
            var response = new ExternalLoginResponse(authorizationUrl);

            _logger.LogInformation("Generated authorization URL for provider {Provider}", request.Provider);

            return Task.FromResult(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error generating authorization URL for provider {Provider}", request.Provider);
            throw;
        }
    }

    private string GenerateAuthorizationUrl(string provider, string redirectUri)
    {
        return provider.ToLower() switch
        {
            "google" => $"https://accounts.google.com/o/oauth2/v2/auth?client_id=YOUR_CLIENT_ID&redirect_uri={redirectUri}&response_type=code&scope=openid%20email%20profile",
            "microsoft" => $"https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=YOUR_CLIENT_ID&redirect_uri={redirectUri}&response_type=code&scope=openid%20email%20profile",
            "facebook" => $"https://www.facebook.com/v12.0/dialog/oauth?client_id=YOUR_CLIENT_ID&redirect_uri={redirectUri}&response_type=code&scope=email",
            _ => throw new ArgumentException($"Unsupported provider: {provider}")
        };
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\LinkExternalAccount\LinkExternalAccountCommand.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using MediatR;

namespace AuthService.Application.Features.ExternalAuth.Commands.LinkExternalAccount;

public record LinkExternalAccountCommand(string UserId, string Provider, string IdToken): IRequest<ExternalAuthResponse>;

---- File: AuthService.Application\Features\ExternalAuth\Commands\LinkExternalAccount\LinkExternalAccountCommandHandler.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using ErrorService.Shared.Exceptions;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuthService.Application.Features.ExternalAuth.Commands.LinkExternalAccount;

public class LinkExternalAccountCommandHandler : IRequestHandler<LinkExternalAccountCommand, ExternalAuthResponse>
{
    private readonly IExternalAuthService _externalAuthService;
    private readonly IUserRepository _userRepository;
    private readonly IJwtGenerator _jwtGenerator;
    private readonly IRefreshTokenRepository _refreshTokenRepository;
    private readonly ILogger<LinkExternalAccountCommandHandler> _logger;

    public LinkExternalAccountCommandHandler(
        IExternalAuthService externalAuthService,
        IUserRepository userRepository,
        IJwtGenerator jwtGenerator,
        IRefreshTokenRepository refreshTokenRepository,
        ILogger<LinkExternalAccountCommandHandler> logger)
    {
        _externalAuthService = externalAuthService;
        _userRepository = userRepository;
        _jwtGenerator = jwtGenerator;
        _refreshTokenRepository = refreshTokenRepository;
        _logger = logger;
    }

    public async Task<ExternalAuthResponse> Handle(LinkExternalAccountCommand request, CancellationToken cancellationToken)
    {
        try
        {
            // Validate provider
            if (!Enum.TryParse<ExternalAuthProvider>(request.Provider, true, out var provider))
                throw new BadRequestException($"Unsupported provider: {request.Provider}");

            // Get user
            var user = await _userRepository.GetByIdAsync(request.UserId)
                ?? throw new NotFoundException("User not found.");

            // Check if user already has an external account
            if (user.IsExternalUser)
                throw new BadRequestException("User already has an external account linked.");

            // Authenticate with external provider
            var (externalUser, isNewUser) = await _externalAuthService.AuthenticateAsync(provider, request.IdToken);

            // Link the external account to existing user
            user.LinkExternalAccount(provider, externalUser.ExternalUserId!);

            // Update user
            await _userRepository.UpdateAsync(user, cancellationToken);

            // Generate tokens
            var accessToken = _jwtGenerator.GenerateToken(user);
            var refreshTokenValue = _jwtGenerator.GenerateRefreshToken();
            var expiresAt = DateTime.UtcNow.AddMinutes(60);

            var refreshTokenEntity = new RefreshToken(
                user.Id,
                refreshTokenValue,
                DateTime.UtcNow.AddDays(7),
                "127.0.0.1" // TODO: Get actual IP from context
            );

            await _refreshTokenRepository.AddAsync(refreshTokenEntity, cancellationToken);

            _logger.LogInformation("External account linked successfully for user {UserId} with provider {Provider}",
                request.UserId, request.Provider);

            return new ExternalAuthResponse(
                user.Id,
                user.UserName!,
                user.Email!,
                accessToken,
                refreshTokenValue,
                expiresAt,
                false // isNewUser should be false since we're linking to existing account
            );
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error linking external account for user {UserId}", request.UserId);
            throw;
        }
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\LinkExternalAccount\LinkExternalAccountCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.ExternalAuth.Commands.LinkExternalAccount;

public class LinkExternalAccountCommandValidator : AbstractValidator<LinkExternalAccountCommand>
{
    public LinkExternalAccountCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required");

        RuleFor(x => x.Provider)
            .NotEmpty().WithMessage("Provider is required")
            .Must(BeValidProvider).WithMessage("Provider must be either 'Google' or 'Microsoft'");

        RuleFor(x => x.IdToken)
            .NotEmpty().WithMessage("ID token is required")
            .MinimumLength(10).WithMessage("Invalid ID token");
    }

    private bool BeValidProvider(string provider)
    {
        return provider.Equals("Google", StringComparison.OrdinalIgnoreCase) ||
               provider.Equals("Microsoft", StringComparison.OrdinalIgnoreCase);
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\UnlinkExternalAccount\UnlinkExternalAccountCommand.cs ----
using MediatR;

namespace AuthService.Application.Features.ExternalAuth.Commands.UnlinkExternalAccount;

public record UnlinkExternalAccountCommand(string UserId, string Provider) : IRequest<Unit>;

---- File: AuthService.Application\Features\ExternalAuth\Commands\UnlinkExternalAccount\UnlinkExternalAccountCommandHandler.cs ----
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Repositories;
using ErrorService.Shared.Exceptions;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuthService.Application.Features.ExternalAuth.Commands.UnlinkExternalAccount;

public class UnlinkExternalAccountCommandHandler : IRequestHandler<UnlinkExternalAccountCommand, Unit>
{
    private readonly IUserRepository _userRepository;
    private readonly ILogger<UnlinkExternalAccountCommandHandler> _logger;

    public UnlinkExternalAccountCommandHandler(
        IUserRepository userRepository,
        ILogger<UnlinkExternalAccountCommandHandler> logger)
    {
        _userRepository = userRepository;
        _logger = logger;
    }

    public async Task<Unit> Handle(UnlinkExternalAccountCommand request, CancellationToken cancellationToken)
    {
        try
        {
            // Validate provider
            if (!Enum.TryParse<ExternalAuthProvider>(request.Provider, true, out var provider))
                throw new BadRequestException($"Unsupported provider: {request.Provider}");

            // Get user
            var user = await _userRepository.GetByIdAsync(request.UserId)
                ?? throw new NotFoundException("User not found.");

            // Check if user has an external account from this provider
            if (!user.IsExternalUser || user.ExternalAuthProvider != provider)
                throw new BadRequestException($"User does not have a linked {request.Provider} account.");

            // Unlink the external account using the entity method
            user.UnlinkExternalAccount();

            // Update user
            await _userRepository.UpdateAsync(user, cancellationToken);

            _logger.LogInformation("External account unlinked successfully for user {UserId} with provider {Provider}",
                request.UserId, request.Provider);

            return Unit.Value;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error unlinking external account for user {UserId}", request.UserId);
            throw;
        }
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Commands\UnlinkExternalAccount\UnlinkExternalAccountCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.ExternalAuth.Commands.UnlinkExternalAccount;

public class UnlinkExternalAccountCommandValidator : AbstractValidator<UnlinkExternalAccountCommand>
{
    public UnlinkExternalAccountCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required");

        RuleFor(x => x.Provider)
            .NotEmpty().WithMessage("Provider is required")
            .Must(BeValidProvider).WithMessage("Provider must be either 'Google' or 'Microsoft'");
    }

    private bool BeValidProvider(string provider)
    {
        return provider.Equals("Google", StringComparison.OrdinalIgnoreCase) ||
               provider.Equals("Microsoft", StringComparison.OrdinalIgnoreCase);
    }
}

---- File: AuthService.Application\Features\ExternalAuth\Queries\GetLinkedAccounts\GetLinkedAccountsQuery.cs ----
using AuthService.Application.DTOs.ExternalAuth;
using MediatR;

namespace AuthService.Application.Features.ExternalAuth.Queries.GetLinkedAccounts;

public record GetLinkedAccountsQuery(string UserId): IRequest<List<LinkedAccountResponse>>;

---- File: AuthService.Application\Features\PhoneVerication\Commands\UpdatePhoneNumber\UpdatePhoneNumberCommand.cs ----
using AuthService.Application.DTOs.PhoneVerification;
using MediatR;

namespace AuthService.Application.Features.PhoneVerification.Commands.UpdatePhoneNumber;

public record UpdatePhoneNumberCommand(string UserId, string NewPhoneNumber)
    : IRequest<SendPhoneVerificationResponse>;

---- File: AuthService.Application\Features\PhoneVerication\Commands\UpdatePhoneNumber\UpdatePhoneNumberCommandHandler.cs ----
using AuthService.Application.DTOs.Auth;
using AuthService.Application.DTOs.PhoneVerification;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using ErrorService.Shared.Exceptions;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuthService.Application.Features.PhoneVerification.Commands.UpdatePhoneNumber;

public class UpdatePhoneNumberCommandHandler : IRequestHandler<UpdatePhoneNumberCommand, SendPhoneVerificationResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly ITwoFactorService _twoFactorService;
    private readonly IAuthNotificationService _notificationService;
    private readonly ILogger<UpdatePhoneNumberCommandHandler> _logger;

    public UpdatePhoneNumberCommandHandler(
        IUserRepository userRepository,
        ITwoFactorService twoFactorService,
        IAuthNotificationService notificationService,
        ILogger<UpdatePhoneNumberCommandHandler> logger)
    {
        _userRepository = userRepository;
        _twoFactorService = twoFactorService;
        _notificationService = notificationService;
        _logger = logger;
    }

    public async Task<SendPhoneVerificationResponse> Handle(UpdatePhoneNumberCommand request, CancellationToken cancellationToken)
    {
        try
        {
            var user = await _userRepository.GetByIdAsync(request.UserId)
                ?? throw new NotFoundException("User not found.");

            // Update phone number and mark as unverified
            user.PhoneNumber = request.NewPhoneNumber;
            user.PhoneNumberConfirmed = false;

            await _userRepository.UpdateAsync(user, cancellationToken);

            // Generate and send verification code
            var verificationCode = await _twoFactorService.GenerateSmsCodeAsync(user.Id);

            await _notificationService.SendTwoFactorCodeAsync(
                request.NewPhoneNumber,
                verificationCode,
                AuthService.Domain.Enums.TwoFactorAuthType.SMS);

            _logger.LogInformation("Phone number updated and verification sent for user {UserId}", request.UserId);

            return new SendPhoneVerificationResponse(
                true,
                "Phone number updated and verification code sent successfully.",
                DateTime.UtcNow.AddMinutes(10)
            );
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error updating phone number for user {UserId}", request.UserId);
            throw;
        }
    }
}

---- File: AuthService.Application\Features\PhoneVerication\Commands\UpdatePhoneNumber\UpdatePhoneNumberCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.PhoneVerification.Commands.UpdatePhoneNumber;

public class UpdatePhoneNumberCommandValidator : AbstractValidator<UpdatePhoneNumberCommand>
{
    public UpdatePhoneNumberCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required.");

        RuleFor(x => x.NewPhoneNumber)
            .NotEmpty().WithMessage("Phone number is required.")
            .Matches(@"^\+?[1-9]\d{1,14}$").WithMessage("Invalid phone number format.");
    }
}

---- File: AuthService.Application\Features\PhoneVerication\Queries\GetPhoneVerificationStatus\GetPhoneVerificationStatusQuery.cs ----
using AuthService.Application.DTOs.PhoneVerification;
using MediatR;

namespace AuthService.Application.Features.PhoneVerification.Queries.GetPhoneVerificationStatus;

public record GetPhoneVerificationStatusQuery(string UserId) : IRequest<PhoneVerificationStatusResponse>;

---- File: AuthService.Application\Features\PhoneVerication\Queries\GetPhoneVerificationStatus\GetPhoneVerificationStatusQueryHandler.cs ----
using AuthService.Application.DTOs.Auth;
using AuthService.Application.DTOs.PhoneVerification;
using AuthService.Domain.Interfaces.Repositories;
using ErrorService.Shared.Exceptions;
using MediatR;
using Microsoft.Extensions.Logging;

namespace AuthService.Application.Features.PhoneVerification.Queries.GetPhoneVerificationStatus;

public class GetPhoneVerificationStatusQueryHandler : IRequestHandler<GetPhoneVerificationStatusQuery, PhoneVerificationStatusResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly ILogger<GetPhoneVerificationStatusQueryHandler> _logger;

    public GetPhoneVerificationStatusQueryHandler(
        IUserRepository userRepository,
        ILogger<GetPhoneVerificationStatusQueryHandler> logger)
    {
        _userRepository = userRepository;
        _logger = logger;
    }

    public async Task<PhoneVerificationStatusResponse> Handle(GetPhoneVerificationStatusQuery request, CancellationToken cancellationToken)
    {
        try
        {
            var user = await _userRepository.GetByIdAsync(request.UserId)
                ?? throw new NotFoundException("User not found.");

            return new PhoneVerificationStatusResponse(
                user.PhoneNumberConfirmed,
                user.PhoneNumber,
                user.UpdatedAt ?? user.CreatedAt
            );
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting phone verification status for user {UserId}", request.UserId);
            throw;
        }
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\Add2FAMethod\Add2FAMethodCommand.cs ----
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Add2FAMethod;

public record Add2FAMethodCommand(
    string UserId,
    string Password,
    TwoFactorAuthType Method,
    string? PhoneNumber = null
) : IRequest<Change2FAMethodResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\Add2FAMethod\Add2FAMethodCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Add2FAMethod;

public class Add2FAMethodCommandHandler : IRequestHandler<Add2FAMethodCommand, Change2FAMethodResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher _passwordHasher;
    private readonly ITwoFactorService _twoFactorService;
    private readonly IAuthNotificationService _notificationService;

    public Add2FAMethodCommandHandler(
        IUserRepository userRepository,
        IPasswordHasher passwordHasher,
        ITwoFactorService twoFactorService,
        IAuthNotificationService notificationService)
    {
        _userRepository = userRepository;
        _passwordHasher = passwordHasher;
        _twoFactorService = twoFactorService;
        _notificationService = notificationService;
    }

    public async Task<Change2FAMethodResponse> Handle(Add2FAMethodCommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        if (string.IsNullOrEmpty(user.PasswordHash) || !_passwordHasher.Verify(request.Password, user.PasswordHash))
            throw new UnauthorizedException("Invalid password.");

        if (!user.IsTwoFactorEnabled)
            throw new BadRequestException("Two-factor authentication is not enabled.");

        var twoFactorAuth = await _userRepository.GetTwoFactorAuthAsync(user.Id);
        if (twoFactorAuth == null)
            throw new NotFoundException("Two-factor authentication configuration not found.");

        if (twoFactorAuth.IsMethodEnabled(request.Method))
            throw new BadRequestException($"Method {request.Method} is already enabled.");

        string? secret = null;
        string? qrCodeUri = null;
        string? phoneNumber = request.PhoneNumber;

        switch (request.Method)
        {
            case TwoFactorAuthType.Authenticator:
                (secret, qrCodeUri) = await _twoFactorService.GenerateAuthenticatorKeyAsync(user.Id, user.Email!);
                break;

            case TwoFactorAuthType.SMS:
                if (string.IsNullOrEmpty(phoneNumber))
                    throw new BadRequestException("Phone number is required for SMS 2FA.");

                if (!IsValidPhoneNumber(phoneNumber))
                    throw new BadRequestException("Invalid phone number format.");

                secret = await _twoFactorService.GenerateSmsCodeAsync(user.Id);
                await _notificationService.SendTwoFactorCodeAsync(phoneNumber, secret, TwoFactorAuthType.SMS);
                break;

            case TwoFactorAuthType.Email:
                secret = await _twoFactorService.GenerateEmailCodeAsync(user.Id);
                await _notificationService.SendTwoFactorCodeAsync(user.Email!, secret, TwoFactorAuthType.Email);
                break;

            default:
                throw new BadRequestException("Invalid two-factor authentication method.");
        }

        twoFactorAuth.AddSecondaryMethod(request.Method);
        await _userRepository.AddOrUpdateTwoFactorAuthAsync(twoFactorAuth);

        return new Change2FAMethodResponse(
            true,
            $"Two-factor authentication method {request.Method} added successfully.",
            secret,
            qrCodeUri,
            phoneNumber
        );
    }

    private bool IsValidPhoneNumber(string phoneNumber) =>
        !string.IsNullOrWhiteSpace(phoneNumber) && phoneNumber.Length >= 10;
}

---- File: AuthService.Application\Features\TwoFactor\Commands\Change2FAMethod\Change2FAMethodCommand.cs ----
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Change2FAMethod;

public record Change2FAMethodCommand(
    string UserId,
    string Password,
    TwoFactorAuthType NewMethod,
    string? PhoneNumber = null
) : IRequest<Change2FAMethodResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\Change2FAMethod\Change2FAMethodCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Change2FAMethod;

public class Change2FAMethodCommandHandler : IRequestHandler<Change2FAMethodCommand, Change2FAMethodResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher _passwordHasher;
    private readonly ITwoFactorService _twoFactorService;
    private readonly IAuthNotificationService _notificationService;

    public Change2FAMethodCommandHandler(
        IUserRepository userRepository,
        IPasswordHasher passwordHasher,
        ITwoFactorService twoFactorService,
        IAuthNotificationService notificationService)
    {
        _userRepository = userRepository;
        _passwordHasher = passwordHasher;
        _twoFactorService = twoFactorService;
        _notificationService = notificationService;
    }

    public async Task<Change2FAMethodResponse> Handle(Change2FAMethodCommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        if (string.IsNullOrEmpty(user.PasswordHash) || !_passwordHasher.Verify(request.Password, user.PasswordHash))
            throw new UnauthorizedException("Invalid password.");

        if (!user.IsTwoFactorEnabled)
            throw new BadRequestException("Two-factor authentication is not enabled.");

        var twoFactorAuth = await _userRepository.GetTwoFactorAuthAsync(user.Id);
        if (twoFactorAuth == null)
            throw new NotFoundException("Two-factor authentication configuration not found.");

        string? secret = null;
        string? qrCodeUri = null;
        string? phoneNumber = request.PhoneNumber;

        switch (request.NewMethod)
        {
            case TwoFactorAuthType.Authenticator:
                (secret, qrCodeUri) = await _twoFactorService.GenerateAuthenticatorKeyAsync(user.Id, user.Email!);
                break;

            case TwoFactorAuthType.SMS:
                if (string.IsNullOrEmpty(phoneNumber))
                    throw new BadRequestException("Phone number is required for SMS 2FA.");

                if (!IsValidPhoneNumber(phoneNumber))
                    throw new BadRequestException("Invalid phone number format.");

                secret = await _twoFactorService.GenerateSmsCodeAsync(user.Id);
                await _notificationService.SendTwoFactorCodeAsync(phoneNumber, secret, TwoFactorAuthType.SMS);
                break;

            case TwoFactorAuthType.Email:
                secret = await _twoFactorService.GenerateEmailCodeAsync(user.Id);
                await _notificationService.SendTwoFactorCodeAsync(user.Email!, secret, TwoFactorAuthType.Email);
                break;

            default:
                throw new BadRequestException("Invalid two-factor authentication method.");
        }

        twoFactorAuth.ChangePrimaryMethod(request.NewMethod, secret, phoneNumber);

        if (!twoFactorAuth.EnabledMethods.Contains(request.NewMethod))
            twoFactorAuth.AddSecondaryMethod(request.NewMethod);

        await _userRepository.AddOrUpdateTwoFactorAuthAsync(twoFactorAuth);

        return new Change2FAMethodResponse(
            true,
            $"Two-factor authentication method changed to {request.NewMethod} successfully.",
            secret,
            qrCodeUri,
            phoneNumber
        );
    }

    private bool IsValidPhoneNumber(string phoneNumber) =>
        !string.IsNullOrWhiteSpace(phoneNumber) && phoneNumber.Length >= 10;
}

---- File: AuthService.Application\Features\TwoFactor\Commands\Disable2FA\Disable2FACommand.cs ----
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Disable2FA;

public record Disable2FACommand(string UserId, string Password) : IRequest<Verify2FAResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\Disable2FA\Disable2FACommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Disable2FA;

public class Disable2FACommandHandler : IRequestHandler<Disable2FACommand, Verify2FAResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher _passwordHasher;
    private readonly ITwoFactorService _twoFactorService;

    public Disable2FACommandHandler(
        IUserRepository userRepository,
        IPasswordHasher passwordHasher,
        ITwoFactorService twoFactorService)
    {
        _userRepository = userRepository;
        _passwordHasher = passwordHasher;
        _twoFactorService = twoFactorService;
    }

    public async Task<Verify2FAResponse> Handle(Disable2FACommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        // Verificar contraseña
        if (string.IsNullOrEmpty(user.PasswordHash) || !_passwordHasher.Verify(request.Password, user.PasswordHash))
            throw new UnauthorizedException("Invalid password.");

        if (!user.IsTwoFactorEnabled)
            throw new BadRequestException("Two-factor authentication is not enabled.");

        // Deshabilitar 2FA
        user.DisableTwoFactorAuth();
        await _userRepository.UpdateAsync(user, cancellationToken);

        return new Verify2FAResponse(true, "Two-factor authentication has been disabled successfully.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\Disable2FA\Disable2FACommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.TwoFactor.Commands.Disable2FA;

public class Disable2FACommandValidator : AbstractValidator<Disable2FACommand>
{
    public Disable2FACommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required.");

        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("Password is required to disable two-factor authentication.")
            .MinimumLength(8).WithMessage("Password must be at least 8 characters long.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\Enable2FA\Enable2FACommand.cs ----
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Enable2FA;

public record Enable2FACommand(string UserId, TwoFactorAuthType Type) : IRequest<Enable2FAResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\Enable2FA\Enable2FACommandHandler.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using ErrorService.Shared.Exceptions;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Enable2FA;

public class Enable2FACommandHandler : IRequestHandler<Enable2FACommand, Enable2FAResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly ITwoFactorService _twoFactorService;
    private readonly IAuthNotificationService _notificationService;

    public Enable2FACommandHandler(
        IUserRepository userRepository,
        ITwoFactorService twoFactorService,
        IAuthNotificationService notificationService)
    {
        _userRepository = userRepository;
        _twoFactorService = twoFactorService;
        _notificationService = notificationService;
    }

    public async Task<Enable2FAResponse> Handle(Enable2FACommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        if (user.IsTwoFactorEnabled)
            throw new BadRequestException("Two-factor authentication is already enabled.");

        string secret = string.Empty;
        string qrCodeUri = string.Empty;
        List<string> recoveryCodes;

        // Generar según el tipo de 2FA
        switch (request.Type)
        {
            case TwoFactorAuthType.Authenticator:
                // Generar clave para Authenticator App
                (secret, qrCodeUri) = await _twoFactorService.GenerateAuthenticatorKeyAsync(user.Id, user.Email!);
                break;

            case TwoFactorAuthType.SMS:
            case TwoFactorAuthType.Email:
                // Para SMS/Email, generar códigos pero no QR
                secret = await _twoFactorService.GenerateEmailCodeAsync(user.Id);
                qrCodeUri = string.Empty;
                break;

            default:
                throw new BadRequestException("Invalid two-factor authentication type.");
        }

        // Generar códigos de recuperación
        recoveryCodes = await _twoFactorService.GenerateRecoveryCodesAsync(user.Id);

        // Crear y guardar entidad 2FA
        var twoFactorAuth = new TwoFactorAuth(user.Id, request.Type);
        twoFactorAuth.Enable(secret, recoveryCodes);

        // GUARDAR en base de datos
        await _userRepository.AddOrUpdateTwoFactorAuthAsync(twoFactorAuth);

        // Enviar códigos de recuperación por email
        await _notificationService.SendTwoFactorBackupCodesAsync(user.Email!, recoveryCodes);

        return new Enable2FAResponse(secret, qrCodeUri, recoveryCodes);
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\Enable2FA\Enable2FACommandValidator.cs ----
using FluentValidation;
using AuthService.Domain.Enums;

namespace AuthService.Application.Features.TwoFactor.Commands.Enable2FA;

public class Enable2FACommandValidator : AbstractValidator<Enable2FACommand>
{
    public Enable2FACommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required.")
            .MinimumLength(1).WithMessage("User ID cannot be empty.");

        RuleFor(x => x.Type)
            .IsInEnum().WithMessage("Invalid two-factor authentication type.")
            .Must(type => type != TwoFactorAuthType.SMS || type != TwoFactorAuthType.Email || type != TwoFactorAuthType.Authenticator)
            .WithMessage("Supported two-factor authentication types are: Authenticator, SMS, and Email.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\GenerateRecoveryCodes\GenerateRecoveryCodesCommand.cs ----
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.GenerateRecoveryCodes;

public record GenerateRecoveryCodesCommand(string UserId, string Password) : IRequest<GenerateRecoveryCodesResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\GenerateRecoveryCodes\GenerateRecoveryCodesCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.GenerateRecoveryCodes;

public class GenerateRecoveryCodesCommandHandler : IRequestHandler<GenerateRecoveryCodesCommand, GenerateRecoveryCodesResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IPasswordHasher _passwordHasher;
    private readonly ITwoFactorService _twoFactorService;
    private readonly IAuthNotificationService _notificationService;

    public GenerateRecoveryCodesCommandHandler(
        IUserRepository userRepository,
        IPasswordHasher passwordHasher,
        ITwoFactorService twoFactorService,
        IAuthNotificationService notificationService)
    {
        _userRepository = userRepository;
        _passwordHasher = passwordHasher;
        _twoFactorService = twoFactorService;
        _notificationService = notificationService;
    }

    public async Task<GenerateRecoveryCodesResponse> Handle(GenerateRecoveryCodesCommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        // Verificar contraseña
        if (string.IsNullOrEmpty(user.PasswordHash) || !_passwordHasher.Verify(request.Password, user.PasswordHash))
            throw new UnauthorizedException("Invalid password.");

        if (!user.IsTwoFactorEnabled)
            throw new BadRequestException("Two-factor authentication is not enabled.");

        // Generar nuevos códigos de recuperación
        var recoveryCodes = await _twoFactorService.GenerateRecoveryCodesAsync(user.Id);

        // Enviar códigos por email
        await _notificationService.SendTwoFactorBackupCodesAsync(user.Email!, recoveryCodes);

        return new GenerateRecoveryCodesResponse(recoveryCodes);
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\GenerateRecoveryCodes\GenerateRecoveryCodesCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.TwoFactor.Commands.GenerateRecoveryCodes;

public class GenerateRecoveryCodesCommandValidator : AbstractValidator<GenerateRecoveryCodesCommand>
{
    public GenerateRecoveryCodesCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required.");

        RuleFor(x => x.Password)
            .NotEmpty().WithMessage("Password is required to generate recovery codes.")
            .MinimumLength(8).WithMessage("Password must be at least 8 characters long.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\SendPhoneVerification\SendPhoneVerificationCommand.cs ----
using MediatR;
using AuthService.Application.DTOs.PhoneVerification;

namespace AuthService.Application.Features.TwoFactor.Commands.SendPhoneVerification;

public record SendPhoneVerificationCommand(string UserId, string PhoneNumber)
    : IRequest<SendPhoneVerificationResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\SendPhoneVerification\SendPhoneVerificationCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.PhoneVerification;

namespace AuthService.Application.Features.TwoFactor.Commands.SendPhoneVerification;

public class SendPhoneVerificationCommandHandler : IRequestHandler<SendPhoneVerificationCommand, SendPhoneVerificationResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly ITwoFactorService _twoFactorService;
    private readonly IAuthNotificationService _notificationService;

    public SendPhoneVerificationCommandHandler(
        IUserRepository userRepository,
        ITwoFactorService twoFactorService,
        IAuthNotificationService notificationService)
    {
        _userRepository = userRepository;
        _twoFactorService = twoFactorService;
        _notificationService = notificationService;
    }

    public async Task<SendPhoneVerificationResponse> Handle(SendPhoneVerificationCommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        // Generar código de verificación
        var verificationCode = await _twoFactorService.GenerateSmsCodeAsync(user.Id);

        await _notificationService.SendTwoFactorCodeAsync(
            request.PhoneNumber,
            verificationCode,
            TwoFactorAuthType.SMS);

        return new SendPhoneVerificationResponse(
            true,
            "Verification code sent successfully.",
            DateTime.UtcNow.AddMinutes(10)
        );
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\TwoFactorLogin\TwoFactorLoginCommand.cs ----
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.TwoFactorLogin;

public record TwoFactorLoginCommand(string TempToken, string TwoFactorCode) : IRequest<TwoFactorLoginResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\TwoFactorLogin\TwoFactorLoginCommandHandler.cs ----
// AuthService.Application/UseCases/TwoFactorLogin/TwoFactorLoginCommandHandler.cs
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.TwoFactorLogin;

public class TwoFactorLoginCommandHandler : IRequestHandler<TwoFactorLoginCommand, TwoFactorLoginResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly IJwtGenerator _jwtGenerator;
    private readonly IRefreshTokenRepository _refreshTokenRepository;
    private readonly ITwoFactorService _twoFactorService;

    public TwoFactorLoginCommandHandler(
        IUserRepository userRepository,
        IJwtGenerator jwtGenerator,
        IRefreshTokenRepository refreshTokenRepository,
        ITwoFactorService twoFactorService)
    {
        _userRepository = userRepository;
        _jwtGenerator = jwtGenerator;
        _refreshTokenRepository = refreshTokenRepository;
        _twoFactorService = twoFactorService;
    }

    public async Task<TwoFactorLoginResponse> Handle(TwoFactorLoginCommand request, CancellationToken cancellationToken)
    {
        // Validar token temporal
        var tempTokenData = _jwtGenerator.ValidateTempToken(request.TempToken);
        if (tempTokenData == null)
            throw new UnauthorizedException("Invalid or expired temporary token.");

        var user = await _userRepository.GetByIdAsync(tempTokenData.Value.userId)
            ?? throw new NotFoundException("User not found.");

        if (!user.IsTwoFactorEnabled)
            throw new BadRequestException("Two-factor authentication is not enabled for this user.");

        var twoFactorAuth = await _userRepository.GetTwoFactorAuthAsync(user.Id);
        if (twoFactorAuth == null)
            throw new NotFoundException("Two-factor authentication configuration not found.");

        bool isValid = false;

        // CORRECCIÓN: Usar PrimaryMethod en lugar de Type
        if (twoFactorAuth.PrimaryMethod == TwoFactorAuthType.Authenticator)
        {
            isValid = _twoFactorService.VerifyAuthenticatorCode(twoFactorAuth.Secret, request.TwoFactorCode);
        }
        else if (twoFactorAuth.PrimaryMethod == TwoFactorAuthType.SMS)
        {
            isValid = await _twoFactorService.VerifyCodeAsync(user.Id, request.TwoFactorCode, TwoFactorAuthType.SMS);
        }
        else if (twoFactorAuth.PrimaryMethod == TwoFactorAuthType.Email)
        {
            isValid = await _twoFactorService.VerifyCodeAsync(user.Id, request.TwoFactorCode, TwoFactorAuthType.Email);
        }

        if (!isValid)
        {
            // También verificar métodos secundarios si el primario falla
            foreach (var method in twoFactorAuth.EnabledMethods)
            {
                if (method == TwoFactorAuthType.Authenticator && method != twoFactorAuth.PrimaryMethod)
                {
                    isValid = _twoFactorService.VerifyAuthenticatorCode(twoFactorAuth.Secret, request.TwoFactorCode);
                    if (isValid) break;
                }
                else if (method == TwoFactorAuthType.SMS && method != twoFactorAuth.PrimaryMethod)
                {
                    isValid = await _twoFactorService.VerifyCodeAsync(user.Id, request.TwoFactorCode, TwoFactorAuthType.SMS);
                    if (isValid) break;
                }
                else if (method == TwoFactorAuthType.Email && method != twoFactorAuth.PrimaryMethod)
                {
                    isValid = await _twoFactorService.VerifyCodeAsync(user.Id, request.TwoFactorCode, TwoFactorAuthType.Email);
                    if (isValid) break;
                }
            }
        }

        if (!isValid)
        {
            twoFactorAuth.IncrementFailedAttempts();
            await _userRepository.AddOrUpdateTwoFactorAuthAsync(twoFactorAuth);
            throw new UnauthorizedException("Invalid two-factor authentication code.");
        }

        // Generar tokens finales
        var accessToken = _jwtGenerator.GenerateToken(user);
        var refreshTokenValue = _jwtGenerator.GenerateRefreshToken();
        var expiresAt = DateTime.UtcNow.AddMinutes(60);

        var refreshTokenEntity = new RefreshToken(
            user.Id,
            refreshTokenValue,
            DateTime.UtcNow.AddDays(7),
            "127.0.0.1"
        );

        await _refreshTokenRepository.AddAsync(refreshTokenEntity, cancellationToken);
        user.ResetAccessFailedCount();
        twoFactorAuth.ResetFailedAttempts();
        twoFactorAuth.MarkAsUsed();
        await _userRepository.UpdateAsync(user, cancellationToken);
        await _userRepository.AddOrUpdateTwoFactorAuthAsync(twoFactorAuth);

        return new TwoFactorLoginResponse(
            user.Id,
            user.Email!,
            accessToken,
            refreshTokenValue,
            expiresAt
        );
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\Verify2FA\Verify2FACommand.cs ----
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Verify2FA;

public record Verify2FACommand(string UserId, string Code, TwoFactorAuthType Type) : IRequest<Verify2FAResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\Verify2FA\Verify2FACommandHandler.cs ----
// AuthService.Application/UseCases/Verify2FA/Verify2FACommandHandler.cs
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.Verify2FA;

public class Verify2FACommandHandler : IRequestHandler<Verify2FACommand, Verify2FAResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly ITwoFactorService _twoFactorService;

    public Verify2FACommandHandler(
        IUserRepository userRepository,
        ITwoFactorService twoFactorService)
    {
        _userRepository = userRepository;
        _twoFactorService = twoFactorService;
    }

    public async Task<Verify2FAResponse> Handle(Verify2FACommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        bool isValid;

        // CORRECCIÓN: Usar PrimaryMethod en lugar de Type
        switch (request.Type)
        {
            case TwoFactorAuthType.Authenticator:
                if (user.TwoFactorAuth?.Secret == null)
                    throw new BadRequestException("Two-factor authentication is not set up for this user.");

                isValid = _twoFactorService.VerifyAuthenticatorCode(user.TwoFactorAuth.Secret, request.Code);
                break;

            case TwoFactorAuthType.SMS:
            case TwoFactorAuthType.Email:
                isValid = await _twoFactorService.VerifyCodeAsync(user.Id, request.Code, request.Type);
                break;

            default:
                throw new BadRequestException("Invalid two-factor authentication type.");
        }

        if (isValid)
        {
            // Marcar como usado si es necesario
            user.TwoFactorAuth?.MarkAsUsed();
            await _userRepository.UpdateAsync(user, cancellationToken);

            return new Verify2FAResponse(true, "Two-factor authentication verified successfully.");
        }

        return new Verify2FAResponse(false, "Invalid verification code.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\Verify2FA\Verify2FACommandValidator.cs ----
using FluentValidation;
using AuthService.Domain.Enums;

namespace AuthService.Application.Features.TwoFactor.Commands.Verify2FA;

public class Verify2FACommandValidator : AbstractValidator<Verify2FACommand>
{
    public Verify2FACommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required.");

        RuleFor(x => x.Code)
            .NotEmpty().WithMessage("Verification code is required.")
            .Length(6).WithMessage("Verification code must be 6 characters long.")
            .Matches(@"^\d+$").WithMessage("Verification code must contain only digits.");

        RuleFor(x => x.Type)
            .IsInEnum().WithMessage("Invalid two-factor authentication type.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\VerifyPhoneNumber\VerifyPhoneNumberCommand.cs ----
using MediatR;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.TwoFactor.Commands.VerifyPhoneNumber;

public record VerifyPhoneNumberCommand(string UserId, string PhoneNumber, string VerificationCode)
    : IRequest<VerifyPhoneNumberResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\VerifyPhoneNumber\VerifyPhoneNumberCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.Auth;

namespace AuthService.Application.Features.TwoFactor.Commands.VerifyPhoneNumber;

public class VerifyPhoneNumberCommandHandler : IRequestHandler<VerifyPhoneNumberCommand, VerifyPhoneNumberResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly ITwoFactorService _twoFactorService;
    private readonly IAuthNotificationService _notificationService;

    public VerifyPhoneNumberCommandHandler(
        IUserRepository userRepository,
        ITwoFactorService twoFactorService,
        IAuthNotificationService notificationService)
    {
        _userRepository = userRepository;
        _twoFactorService = twoFactorService;
        _notificationService = notificationService;
    }

    public async Task<VerifyPhoneNumberResponse> Handle(VerifyPhoneNumberCommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        // Verificar si el número ya está verificado
        if (user.PhoneNumberConfirmed && user.PhoneNumber == request.PhoneNumber)
        {
            return new VerifyPhoneNumberResponse(true, "Phone number is already verified.", true);
        }

        // Validar código de verificación
        bool isValidCode = await _twoFactorService.VerifyCodeAsync(
            user.Id,
            request.VerificationCode,
            TwoFactorAuthType.SMS);

        if (!isValidCode)
        {
            throw new BadRequestException("Invalid verification code.");
        }

        // Actualizar número de teléfono y marcarlo como verificado
        user.PhoneNumber = request.PhoneNumber;
        user.PhoneNumberConfirmed = true;

        await _userRepository.UpdateAsync(user, cancellationToken);

        return new VerifyPhoneNumberResponse(true, "Phone number verified successfully.", true);
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\VerifyPhoneNumber\VerifyPhoneNumberCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.TwoFactor.Commands.VerifyPhoneNumber;

public class VerifyPhoneNumberCommandValidator : AbstractValidator<VerifyPhoneNumberCommand>
{
    public VerifyPhoneNumberCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required.");

        RuleFor(x => x.PhoneNumber)
            .NotEmpty().WithMessage("Phone number is required.")
            .Matches(@"^\+?[1-9]\d{1,14}$").WithMessage("Invalid phone number format.");

        RuleFor(x => x.VerificationCode)
            .NotEmpty().WithMessage("Verification code is required.")
            .Length(6).WithMessage("Verification code must be 6 characters long.")
            .Matches(@"^\d+$").WithMessage("Verification code must contain only digits.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\VerifyRecoveryCode\VerifyRecoveryCodeCommand.cs ----
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.VerifyRecoveryCode;

public record VerifyRecoveryCodeCommand(string UserId, string Code) : IRequest<Verify2FAResponse>;

---- File: AuthService.Application\Features\TwoFactor\Commands\VerifyRecoveryCode\VerifyRecoveryCodeCommandHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Commands.VerifyRecoveryCode;

public class VerifyRecoveryCodeCommandHandler : IRequestHandler<VerifyRecoveryCodeCommand, Verify2FAResponse>
{
    private readonly IUserRepository _userRepository;
    private readonly ITwoFactorService _twoFactorService;

    public VerifyRecoveryCodeCommandHandler(
        IUserRepository userRepository,
        ITwoFactorService twoFactorService)
    {
        _userRepository = userRepository;
        _twoFactorService = twoFactorService;
    }

    public async Task<Verify2FAResponse> Handle(VerifyRecoveryCodeCommand request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        if (!user.IsTwoFactorEnabled)
            throw new BadRequestException("Two-factor authentication is not enabled.");

        var isValid = await _twoFactorService.VerifyRecoveryCodeAsync(user.Id, request.Code);

        if (isValid)
        {
            return new Verify2FAResponse(true, "Recovery code verified successfully.");
        }

        return new Verify2FAResponse(false, "Invalid recovery code.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Commands\VerifyRecoveryCode\VerifyRecoveryCodeCommandValidator.cs ----
using FluentValidation;

namespace AuthService.Application.Features.TwoFactor.Commands.VerifyRecoveryCode;

public class VerifyRecoveryCodeCommandValidator : AbstractValidator<VerifyRecoveryCodeCommand>
{
    public VerifyRecoveryCodeCommandValidator()
    {
        RuleFor(x => x.UserId)
            .NotEmpty().WithMessage("User ID is required.");

        RuleFor(x => x.Code)
            .NotEmpty().WithMessage("Recovery code is required.")
            .Length(8).WithMessage("Recovery code must be 8 characters long.")
            .Matches(@"^[A-Z0-9]+$").WithMessage("Recovery code must contain only uppercase letters and numbers.");
    }
}

---- File: AuthService.Application\Features\TwoFactor\Queries\Get2FAMethods\Get2FAMethodsQuery.cs ----
using MediatR;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Queries.Get2FAMethods;

public record Get2FAMethodsQuery(string UserId) : IRequest<Get2FAMethodsResponse>;

---- File: AuthService.Application\Features\TwoFactor\Queries\Get2FAMethods\Get2FAMethodsQueryHandler.cs ----
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Interfaces.Repositories;
using MediatR;
using AuthService.Domain.Enums;
using AuthService.Application.DTOs.TwoFactor;

namespace AuthService.Application.Features.TwoFactor.Queries.Get2FAMethods;

public class Get2FAMethodsQueryHandler : IRequestHandler<Get2FAMethodsQuery, Get2FAMethodsResponse>
{
    private readonly IUserRepository _userRepository;

    public Get2FAMethodsQueryHandler(IUserRepository userRepository)
    {
        _userRepository = userRepository;
    }

    public async Task<Get2FAMethodsResponse> Handle(Get2FAMethodsQuery request, CancellationToken cancellationToken)
    {
        var user = await _userRepository.GetByIdAsync(request.UserId)
            ?? throw new NotFoundException("User not found.");

        var twoFactorAuth = await _userRepository.GetTwoFactorAuthAsync(user.Id);

        if (twoFactorAuth == null || !user.IsTwoFactorEnabled)
        {
            return new Get2FAMethodsResponse(
                user.Id,
                TwoFactorAuthType.Authenticator,
                new List<TwoFactorAuthType>(),
                false,
                !string.IsNullOrEmpty(user.PhoneNumber),
                false
            );
        }

        return new Get2FAMethodsResponse(
            user.Id,
            twoFactorAuth.PrimaryMethod,
            twoFactorAuth.EnabledMethods,
            true,
            !string.IsNullOrEmpty(twoFactorAuth.PhoneNumber),
            twoFactorAuth.EnabledMethods.Contains(TwoFactorAuthType.Authenticator)
        );
    }
}

---- File: AuthService.Domain\AuthService.Domain.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MediatR.Contracts" Version="1.0.1" />
    <PackageReference Include="Microsoft.AspNetCore.Identity.EntityFrameworkCore" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AuthService.Shared\AuthService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: AuthService.Domain\Common\EntityBase.cs ----
using MediatR;

namespace AuthService.Domain.Common;

public abstract class EntityBase : IEquatable<EntityBase>
{
    public string Id { get; protected set; } = string.Empty;
    public DateTime CreatedAt { get; protected set; } = DateTime.UtcNow;
    public DateTime? UpdatedAt { get; protected set; }

    private readonly List<INotification> _domainEvents = new();
    public IReadOnlyCollection<INotification> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(INotification eventItem)
    {
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(INotification eventItem)
    {
        _domainEvents.Remove(eventItem);
    }

    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }

    public void MarkAsUpdated()
    {
        UpdatedAt = DateTime.UtcNow;
    }

    public override bool Equals(object? obj)
    {
        return obj is EntityBase entity && Id.Equals(entity.Id);
    }

    public bool Equals(EntityBase? other)
    {
        return Equals((object?)other);
    }

    public override int GetHashCode()
    {
        return Id.GetHashCode();
    }

    public static bool operator ==(EntityBase? left, EntityBase? right)
    {
        return Equals(left, right);
    }

    public static bool operator !=(EntityBase? left, EntityBase? right)
    {
        return !Equals(left, right);
    }
}

public interface IAggregateRoot { }

---- File: AuthService.Domain\Entities\ApplicationUser.cs ----
using Microsoft.AspNetCore.Identity;
using AuthService.Domain.Common;
using AuthService.Domain.Events;
using AuthService.Domain.Exceptions;
using AuthService.Domain.Interfaces.Services;
using AuthService.Domain.Enums;
using MediatR;

namespace AuthService.Domain.Entities;

public class ApplicationUser : IdentityUser, IAggregateRoot
{
    private readonly List<INotification> _domainEvents = new();

    // Navigation properties
    public virtual ICollection<RefreshToken> RefreshTokens { get; private set; } = new List<RefreshToken>();
    public virtual ICollection<VerificationToken> VerificationTokens { get; private set; } = new List<VerificationToken>();

    // Relación 1:1 con TwoFactorAuth
    public virtual TwoFactorAuth? TwoFactorAuth { get; private set; }

    // Propiedades adicionales
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime? UpdatedAt { get; set; }

    // Propiedad computada para 2FA
    public bool IsTwoFactorEnabled => TwoFactorAuth != null && TwoFactorAuth.Status == TwoFactorAuthStatus.Enabled;

    // Domain Events
    public IReadOnlyCollection<INotification> DomainEvents => _domainEvents.AsReadOnly();

    public void AddDomainEvent(INotification eventItem) => _domainEvents.Add(eventItem);
    public void RemoveDomainEvent(INotification eventItem) => _domainEvents.Remove(eventItem);
    public void ClearDomainEvents() => _domainEvents.Clear();
    public void MarkAsUpdated() => UpdatedAt = DateTime.UtcNow;

    // Nuevas propiedades para autenticación externa
    public ExternalAuthProvider? ExternalAuthProvider { get; private set; }
    public string? ExternalUserId { get; private set; }
    public bool IsExternalUser => ExternalAuthProvider.HasValue;


    // EF Core constructor
    protected ApplicationUser() : base() { }

    public ApplicationUser(string userName, string email, string passwordHash) : base(userName)
    {
        if (string.IsNullOrWhiteSpace(userName))
            throw new DomainException("Username cannot be empty");

        if (string.IsNullOrWhiteSpace(email) || !IsValidEmail(email))
            throw new InvalidEmailException(email);

        if (string.IsNullOrWhiteSpace(passwordHash))
            throw new DomainException("Password hash cannot be empty");

        Email = email.ToLower().Trim();
        NormalizedEmail = Email.ToUpperInvariant();
        PasswordHash = passwordHash;
        EmailConfirmed = false;
        AccessFailedCount = 0;
        LockoutEnabled = true;

        AddDomainEvent(new UserRegisteredEvent(Id, Email, UserName!));
    }

    // Métodos para 2FA
    public void EnableTwoFactorAuth(TwoFactorAuth twoFactorAuth)
    {
        TwoFactorAuth = twoFactorAuth;
        MarkAsUpdated();
    }

    public void DisableTwoFactorAuth()
    {
        TwoFactorAuth = null;
        MarkAsUpdated();
    }

    public void ConfirmEmail()
    {
        if (EmailConfirmed)
            throw new DomainException("Email is already confirmed");

        EmailConfirmed = true;
        AddDomainEvent(new EmailConfirmedEvent(Id, Email!));
    }

    public void UpdatePassword(string newPlainPassword, IPasswordHasher passwordHasher)
    {
        if (string.IsNullOrWhiteSpace(newPlainPassword))
            throw new DomainException("Password cannot be empty");

        if (string.IsNullOrWhiteSpace(PasswordHash))
            throw new DomainException("No password is set for this user");

        if (passwordHasher.Verify(newPlainPassword, PasswordHash))
            throw new DomainException("New password must be different from current password");

        PasswordHash = passwordHasher.Hash(newPlainPassword);
        SecurityStamp = Guid.NewGuid().ToString();
        MarkAsUpdated();
        AddDomainEvent(new PasswordChangedEvent(Id));
    }

    public void IncrementAccessFailedCount()
    {
        AccessFailedCount++;

        if (AccessFailedCount >= 5)
        {
            LockoutEnabled = true;
            LockoutEnd = DateTimeOffset.UtcNow.AddMinutes(30);
        }
        MarkAsUpdated();
    }

    public void ResetAccessFailedCount()
    {
        AccessFailedCount = 0;
        LockoutEnd = null;
        MarkAsUpdated();
    }

    public bool IsLockedOut() => LockoutEnabled && LockoutEnd.HasValue && LockoutEnd > DateTimeOffset.UtcNow;

    public bool CheckPassword(string password, IPasswordHasher passwordHasher)
    {
        if (string.IsNullOrWhiteSpace(PasswordHash))
            throw new DomainException("No password is set for this user");

        return passwordHasher.Verify(password, PasswordHash);
    }

    public void AddRefreshToken(RefreshToken refreshToken) => RefreshTokens.Add(refreshToken);

    public void RevokeAllRefreshTokens(string reason = "user_action")
    {
        foreach (var token in RefreshTokens.Where(t => !t.IsRevoked))
            token.Revoke(reason, "system");
    }

    private static bool IsValidEmail(string email)
    {
        try
        {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        }
        catch
        {
            return false;
        }
    }

    // Método para crear usuario externo
    public static ApplicationUser CreateExternalUser(
        string userName,
        string email,
        ExternalAuthProvider provider,
        string externalUserId)
    {
        if (string.IsNullOrWhiteSpace(userName))
            throw new DomainException("Username cannot be empty");

        if (string.IsNullOrWhiteSpace(email) || !IsValidEmail(email))
            throw new InvalidEmailException(email);

        var user = new ApplicationUser
        {
            UserName = userName,
            Email = email.ToLower().Trim(),
            NormalizedEmail = email.ToUpperInvariant(),
            ExternalAuthProvider = provider,
            ExternalUserId = externalUserId,
            EmailConfirmed = true, // Los emails de proveedores externos están confirmados
            SecurityStamp = Guid.NewGuid().ToString()
        };

        user.AddDomainEvent(new UserRegisteredEvent(user.Id, user.Email, user.UserName!));
        return user;
    }

    // Método para vincular cuenta externa a usuario existente
    public void LinkExternalAccount(ExternalAuthProvider provider, string externalUserId)
    {
        if (IsExternalUser)
            throw new DomainException("User already has an external account linked");

        ExternalAuthProvider = provider;
        ExternalUserId = externalUserId;
        MarkAsUpdated();
    }

    public void UnlinkExternalAccount()
    {
        if (!IsExternalUser)
            throw new DomainException("User does not have a linked external account.");

        ExternalAuthProvider = null;
        ExternalUserId = null;
        MarkAsUpdated();

    }




}

---- File: AuthService.Domain\Entities\RefreshToken.cs ----
using AuthService.Domain.Common;

namespace AuthService.Domain.Entities;

public class RefreshToken : EntityBase
{
    public string Token { get; private set; } = string.Empty;
    public string UserId { get; private set; } = string.Empty;
    public DateTime ExpiresAt { get; private set; }
    public string CreatedByIp { get; private set; } = string.Empty;
    public DateTime? RevokedAt { get; private set; }
    public string? RevokedByIp { get; private set; }
    public string? RevokedReason { get; private set; }
    public string? ReplacedByToken { get; private set; }

    public bool IsExpired => DateTime.UtcNow >= ExpiresAt;
    public bool IsRevoked => RevokedAt.HasValue;
    public bool IsActive => !IsRevoked && !IsExpired;

    // Navigation property
    public virtual ApplicationUser User { get; private set; } = null!;

    // EF Core constructor
    private RefreshToken() { }


    // Este es el constructor correcto para RefreshToken
    public RefreshToken(string userId, string token, DateTime expiresAt, string createdByIp)
    {
        if (string.IsNullOrWhiteSpace(userId))
            throw new ArgumentException("User ID cannot be empty", nameof(userId));

        if (string.IsNullOrWhiteSpace(token))
            throw new ArgumentException("Token cannot be empty", nameof(token));

        Id = Guid.NewGuid().ToString(); // Asegúrate que EntityBase maneje la asignación de ID o hazla aquí
        UserId = userId;
        Token = token;
        ExpiresAt = expiresAt;
        CreatedByIp = createdByIp;
        // CreatedAt se asigna en EntityBase si lo heredas
    }

    public void Revoke(string revokedByIp, string reason = "revoked", string? replacedByToken = null)
    {
        if (IsRevoked)
            throw new InvalidOperationException("Token is already revoked");

        RevokedAt = DateTime.UtcNow;
        RevokedByIp = revokedByIp;
        RevokedReason = reason;
        ReplacedByToken = replacedByToken;
        MarkAsUpdated(); // Si EntityBase tiene este método
    }

    // Nota: El método Rotate debería probablemente estar en un servicio, no en la entidad.
    // Pero si lo dejas aquí, asegúrate que funcione correctamente.
    public RefreshToken Rotate(string newToken, DateTime newExpiresAt, string createdByIp)
    {
        Revoke(createdByIp, "rotated", newToken);
        return new RefreshToken(UserId, newToken, newExpiresAt, createdByIp);
    }
}

---- File: AuthService.Domain\Entities\TwoFactorAuth.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Domain.Entities;

public class TwoFactorAuth
{
    public string Id { get; private set; }
    public string UserId { get; private set; }
    public TwoFactorAuthType PrimaryMethod { get; private set; }
    public TwoFactorAuthStatus Status { get; private set; }
    public string Secret { get; private set; } = string.Empty;
    public string? PhoneNumber { get; private set; }
    public DateTime? EnabledAt { get; private set; }
    public DateTime? LastUsedAt { get; private set; }
    public List<string> RecoveryCodes { get; private set; } = new();
    public int FailedAttempts { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime? UpdatedAt { get; private set; }

    // Métodos secundarios habilitados
    public List<TwoFactorAuthType> EnabledMethods { get; private set; } = new();

    // Navigation property (relación 1:1)
    public virtual ApplicationUser User { get; private set; } = null!;

    // CORRECCIÓN: Constructor privado inicializa todas las propiedades requeridas
    private TwoFactorAuth()
    {
        Id = Guid.NewGuid().ToString();
        UserId = string.Empty; // Inicializar con valor por defecto
        PrimaryMethod = TwoFactorAuthType.Authenticator; // Valor por defecto
        Status = TwoFactorAuthStatus.Disabled; // Valor por defecto
        CreatedAt = DateTime.UtcNow;
    }

    public TwoFactorAuth(string userId, TwoFactorAuthType primaryMethod, string? phoneNumber = null)
    {
        Id = Guid.NewGuid().ToString();
        UserId = userId ?? throw new ArgumentNullException(nameof(userId));
        PrimaryMethod = primaryMethod;
        Status = TwoFactorAuthStatus.PendingVerification;
        PhoneNumber = phoneNumber;
        CreatedAt = DateTime.UtcNow;
    }

    public void Enable(string secret, List<string> recoveryCodes, List<TwoFactorAuthType>? enabledMethods = null)
    {
        if (Status == TwoFactorAuthStatus.Enabled)
            throw new InvalidOperationException("2FA is already enabled");

        Secret = secret ?? throw new ArgumentNullException(nameof(secret));
        RecoveryCodes = recoveryCodes ?? throw new ArgumentNullException(nameof(recoveryCodes));
        EnabledMethods = enabledMethods ?? new List<TwoFactorAuthType> { PrimaryMethod };
        Status = TwoFactorAuthStatus.Enabled;
        EnabledAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
    }

    public void ChangePrimaryMethod(TwoFactorAuthType newMethod, string? newSecret = null, string? newPhoneNumber = null)
    {
        if (Status != TwoFactorAuthStatus.Enabled)
            throw new InvalidOperationException("2FA must be enabled to change method");

        PrimaryMethod = newMethod;

        if (!string.IsNullOrEmpty(newSecret))
            Secret = newSecret;

        if (!string.IsNullOrEmpty(newPhoneNumber))
            PhoneNumber = newPhoneNumber;

        UpdatedAt = DateTime.UtcNow;
    }

    public void AddSecondaryMethod(TwoFactorAuthType method)
    {
        if (!EnabledMethods.Contains(method))
        {
            EnabledMethods.Add(method);
            UpdatedAt = DateTime.UtcNow;
        }
    }

    public void RemoveSecondaryMethod(TwoFactorAuthType method)
    {
        if (method == PrimaryMethod)
            throw new InvalidOperationException("Cannot remove primary method");

        if (EnabledMethods.Contains(method))
        {
            EnabledMethods.Remove(method);
            UpdatedAt = DateTime.UtcNow;
        }
    }

    public bool IsMethodEnabled(TwoFactorAuthType method) => EnabledMethods.Contains(method);

    public void Disable()
    {
        Status = TwoFactorAuthStatus.Disabled;
        Secret = string.Empty;
        RecoveryCodes.Clear();
        EnabledMethods.Clear();
        UpdatedAt = DateTime.UtcNow;
    }

    public void MarkAsUsed()
    {
        LastUsedAt = DateTime.UtcNow;
        UpdatedAt = DateTime.UtcNow;
    }

    public void IncrementFailedAttempts()
    {
        FailedAttempts++;
        UpdatedAt = DateTime.UtcNow;
    }

    public void ResetFailedAttempts()
    {
        FailedAttempts = 0;
        UpdatedAt = DateTime.UtcNow;
    }

    public bool UseRecoveryCode(string code)
    {
        if (RecoveryCodes.Contains(code))
        {
            RecoveryCodes.Remove(code);
            UpdatedAt = DateTime.UtcNow;
            return true;
        }
        return false;
    }

    public bool HasRecoveryCodes => RecoveryCodes.Any();
}

---- File: AuthService.Domain\Entities\VerificationToken.cs ----
using AuthService.Domain.Enums;
using System; // <--- Asegúrate de tener este using

namespace AuthService.Domain.Entities;

public class VerificationToken
{
    public Guid Id { get; set; }
    public string Token { get; set; } = string.Empty;
    public string Email { get; set; } = string.Empty;
    public VerificationTokenType Type { get; set; }
    public DateTime ExpiresAt { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public bool IsUsed { get; set; } = false;
    public DateTime? UsedAt { get; set; }
    public string UserId { get; set; } = string.Empty;

    // Asegúrate de que esta propiedad existe y es pública
    public virtual ApplicationUser User { get; set; } = null!;

    // Constructor vacío (necesario para EF Core y los Factory Methods)
    public VerificationToken()
    {
        Id = Guid.NewGuid();
        CreatedAt = DateTime.UtcNow;
    }

    // --- ESTE ES EL CONSTRUCTOR QUE FALTABA ---
    public VerificationToken(string userId, VerificationTokenType type, TimeSpan expiresIn) : this()
    {
        if (string.IsNullOrWhiteSpace(userId))
            throw new ArgumentNullException(nameof(userId), "User ID cannot be empty when creating a verification token.");

        UserId = userId;
        Type = type;
        ExpiresAt = DateTime.UtcNow.Add(expiresIn);

        byte[] tokenData = new byte[32];
        using (var rng = System.Security.Cryptography.RandomNumberGenerator.Create())
        {
            rng.GetBytes(tokenData);
        }
        Token = Convert.ToBase64String(tokenData)
                       .Replace('+', '-')
                       .Replace('/', '_')
                       .TrimEnd('=');
    }

    // Factory methods (Estos ahora usan el constructor vacío y asignan propiedades)
    // Nota: Podrían modificarse para usar el nuevo constructor si tiene sentido
    public static VerificationToken CreateEmailVerificationToken(string email, string userId, int expiryHours = 24)
    {
        var token = new VerificationToken(userId, VerificationTokenType.EmailVerification, TimeSpan.FromHours(expiryHours));
        token.Email = email; // Asigna el email si aún lo necesitas por separado
        // El token ya se genera en el constructor
        return token;
    }

    public static VerificationToken CreatePasswordResetToken(string email, string userId, int expiryHours = 1)
    {
        var token = new VerificationToken(userId, VerificationTokenType.PasswordReset, TimeSpan.FromHours(expiryHours));
        token.Email = email; // Asigna el email si aún lo necesitas por separado
                             // El token ya se genera en el constructor
        return token;
    }

    // Business methods
    public bool IsValid()
    {
        return !IsUsed && ExpiresAt > DateTime.UtcNow;
    }

    public void MarkAsUsed()
    {
        if (IsUsed) return; // Evitar marcar como usado múltiples veces
        IsUsed = true;
        UsedAt = DateTime.UtcNow;
    }

    public bool IsExpired()
    {
        return DateTime.UtcNow > ExpiresAt;
    }
}

---- File: AuthService.Domain\Enums\ExternalAuthProvider.cs ----
namespace AuthService.Domain.Enums;

public enum ExternalAuthProvider
{
    Google = 1,
    Microsoft = 2
}

---- File: AuthService.Domain\Enums\TwoFactorAuthType.cs ----
namespace AuthService.Domain.Enums;

public enum TwoFactorAuthType
{
    Authenticator = 1,
    SMS = 2,
    Email = 3
}

public enum TwoFactorAuthStatus
{
    Disabled = 0,
    Enabled = 1,
    PendingVerification = 2
}

---- File: AuthService.Domain\Enums\VerificationTokenType.cs ----
namespace AuthService.Domain.Enums;

public enum VerificationTokenType
{
    EmailVerification = 1,
    PasswordReset = 2,
    PhoneVerification = 3
}

---- File: AuthService.Domain\Events\EmailConfirmedEvent.cs ----
using MediatR;

namespace AuthService.Domain.Events;

public class EmailConfirmedEvent : INotification
{
    public string UserId { get; }
    public string Email { get; }
    public DateTime OccurredAt { get; }

    public EmailConfirmedEvent(string userId, string email)
    {
        UserId = userId;
        Email = email;
        OccurredAt = DateTime.UtcNow;
    }
}

---- File: AuthService.Domain\Events\PasswordChangedEvent.cs ----
using MediatR;

namespace AuthService.Domain.Events;

public class PasswordChangedEvent : INotification
{
    public string UserId { get; }
    public DateTime OccurredAt { get; }

    public PasswordChangedEvent(string userId)
    {
        UserId = userId;
        OccurredAt = DateTime.UtcNow;
    }
}

---- File: AuthService.Domain\Events\UserRegisteredEvent.cs ----
using MediatR;

namespace AuthService.Domain.Events;

public class UserRegisteredEvent : INotification
{
    public string UserId { get; }
    public string Email { get; }
    public string UserName { get; }
    public DateTime OccurredAt { get; }

    public UserRegisteredEvent(string userId, string email, string userName)
    {
        UserId = userId;
        Email = email;
        UserName = userName;
        OccurredAt = DateTime.UtcNow;
    }
}

---- File: AuthService.Domain\Exceptions\DomainException.cs ----
namespace AuthService.Domain.Exceptions;

public class DomainException : Exception
{
    public DomainException(string message) : base(message)
    {
    }

    public DomainException(string message, Exception innerException) : base(message, innerException)
    {
    }
}

---- File: AuthService.Domain\Exceptions\InvalidEmailException.cs ----
namespace AuthService.Domain.Exceptions;

public class InvalidEmailException : DomainException
{
    public string Email { get; }

    public InvalidEmailException(string email)
        : base($"The email '{email}' is not valid")
    {
        Email = email;
    }
}

---- File: AuthService.Domain\Exceptions\UserNotFoundException.cs ----
namespace AuthService.Domain.Exceptions;

public class UserNotFoundException : DomainException
{
    public string UserId { get; }
    public string? Email { get; }

    public UserNotFoundException(string userId)
        : base($"User with ID '{userId}' was not found")
    {
        UserId = userId;
    }

    public UserNotFoundException(string userId, string email)
        : base($"User with ID '{userId}' and email '{email}' was not found")
    {
        UserId = userId;
        Email = email;
    }
}

---- File: AuthService.Domain\Interfaces\Repositories\IRefreshTokenRepository.cs ----
using AuthService.Domain.Entities;

namespace AuthService.Domain.Interfaces.Repositories;

public interface IRefreshTokenRepository
{
    Task<RefreshToken?> GetByTokenAsync(string token, CancellationToken cancellationToken = default);
    Task<IEnumerable<RefreshToken>> GetByUserIdAsync(string userId, CancellationToken cancellationToken = default);
    Task AddAsync(RefreshToken refreshToken, CancellationToken cancellationToken = default);
    Task UpdateAsync(RefreshToken refreshToken, CancellationToken cancellationToken = default);
    Task RevokeAllForUserAsync(string userId, string reason, CancellationToken cancellationToken = default);
    Task CleanupExpiredTokensAsync(CancellationToken cancellationToken = default);
}

---- File: AuthService.Domain\Interfaces\Repositories\IUserRepository.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;

namespace AuthService.Domain.Interfaces.Repositories;

public interface IUserRepository
{
    Task<ApplicationUser?> GetByIdAsync(string id, CancellationToken cancellationToken = default);
    Task<ApplicationUser?> GetByEmailAsync(string email, CancellationToken cancellationToken = default);
    Task<ApplicationUser?> GetByNormalizedEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default);
    Task<bool> ExistsAsync(string email, CancellationToken cancellationToken = default);
    Task AddAsync(ApplicationUser user, CancellationToken cancellationToken = default);
    Task UpdateAsync(ApplicationUser user, CancellationToken cancellationToken = default);
    Task DeleteAsync(ApplicationUser user, CancellationToken cancellationToken = default);
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
    Task<TwoFactorAuth?> GetTwoFactorAuthAsync(string userId);
    Task AddOrUpdateTwoFactorAuthAsync(TwoFactorAuth twoFactorAuth);
    Task RemoveTwoFactorAuthAsync(string userId);
    Task<ApplicationUser?> GetByExternalIdAsync(ExternalAuthProvider provider, string externalUserId);
    Task<List<ApplicationUser>> GetAllAsync(CancellationToken cancellationToken = default);

}

---- File: AuthService.Domain\Interfaces\Repositories\IVerificationTokenRepository.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;

namespace AuthService.Domain.Interfaces.Repositories;

public interface IVerificationTokenRepository
{
    Task<VerificationToken?> GetByTokenAsync(string token);
    Task<VerificationToken?> GetByTokenAndTypeAsync(string token, VerificationTokenType type);
    Task<IEnumerable<VerificationToken>> GetByEmailAsync(string email);
    Task<VerificationToken?> GetValidByEmailAndTypeAsync(string email, VerificationTokenType type);
    Task AddAsync(VerificationToken token);
    Task UpdateAsync(VerificationToken token);
    Task DeleteAsync(Guid id);
    Task DeleteExpiredTokensAsync();
    Task<bool> ExistsValidTokenAsync(string email, VerificationTokenType type);
}

---- File: AuthService.Domain\Interfaces\Services\IAuthNotificationService.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Domain.Interfaces.Services;

public interface IAuthNotificationService
{
    Task SendPasswordResetEmailAsync(string email, string resetToken);
    Task SendWelcomeEmailAsync(string email, string username);
    Task SendEmailConfirmationAsync(string email, string confirmationToken);
    Task SendTwoFactorCodeAsync(string email, string code, TwoFactorAuthType method);
    Task SendTwoFactorBackupCodesAsync(string email, List<string> backupCodes);
}

---- File: AuthService.Domain\Interfaces\Services\IEmailVerificationService.cs ----
using AuthService.Domain.Entities;
using System.Threading.Tasks;

namespace AuthService.Domain.Interfaces.Services;

public interface IEmailVerificationService
{
    Task SendVerificationEmailAsync(ApplicationUser user);
    Task<bool> VerifyAsync(string token);
}

---- File: AuthService.Domain\Interfaces\Services\IErrorEventProducer.cs ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AuthService.Domain.Interfaces.Services
{
    internal interface IErrorEventProducer
    {
    }
}

---- File: AuthService.Domain\Interfaces\Services\IExternalAuthService.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;
using AuthService.Domain.ValueObjects;

namespace AuthService.Domain.Interfaces.Services;

public interface IExternalAuthService
{
    Task<(ApplicationUser user, bool isNewUser)> AuthenticateAsync(ExternalAuthProvider provider, string idToken);
    Task<ApplicationUser?> FindUserByExternalIdAsync(ExternalAuthProvider provider, string externalUserId);
    Task<bool> ValidateTokenAsync(ExternalAuthProvider provider, string idToken);
    Task<string> GetUserInfoAsync(ExternalAuthProvider provider, string accessToken);
    Task<ExternalUserInfo> GetUserInfoTypedAsync(ExternalAuthProvider provider, string accessToken);
}

---- File: AuthService.Domain\Interfaces\Services\IExternalTokenValidator.cs ----
using AuthService.Domain.Enums;

namespace AuthService.Domain.Interfaces.Services;

public interface IExternalTokenValidator
{
    Task<(bool isValid, string email, string userId, string name)> ValidateGoogleTokenAsync(string idToken);
    Task<(bool isValid, string email, string userId, string name)> ValidateMicrosoftTokenAsync(string idToken);
}

---- File: AuthService.Domain\Interfaces\Services\IJwtGenerator.cs ----
using AuthService.Domain.Entities;

namespace AuthService.Domain.Interfaces.Services;

public interface IJwtGenerator
{
    string GenerateToken(ApplicationUser user);
    string GenerateRefreshToken();
    (string userId, string email)? ValidateToken(string token);
    string GenerateTempToken(string userId);
    (string userId, string email)? ValidateTempToken(string token);
}

---- File: AuthService.Domain\Interfaces\Services\INotificationEventProducer.cs ----
using AuthService.Shared.NotificationMessages;

namespace AuthService.Domain.Interfaces.Services;

public interface INotificationEventProducer
{
    Task PublishNotificationAsync(NotificationEvent notification);
    Task PublishEmailAsync(string to, string subject, string body, Dictionary<string, object>? data = null);
    Task PublishSmsAsync(string to, string message, Dictionary<string, object>? data = null);
}


---- File: AuthService.Domain\Interfaces\Services\INotificationService.cs ----
// AuthService.Domain/Interfaces/Services/INotificationService.cs
using AuthService.Domain.Entities;

namespace AuthService.Domain.Interfaces.Services;

public interface INotificationService
{
    Task SendEmailAsync(string to, string subject, string body, bool isHtml = true);
    Task SendSmsAsync(string to, string message);
    Task SendPushAsync(string deviceToken, string title, string body);
    Task<bool> IsHealthyAsync();
}


---- File: AuthService.Domain\Interfaces\Services\IPasswordHasher.cs ----
public interface IPasswordHasher
{
    string Hash(string password);
    bool Verify(string providedPassword, string hashedPassword);
}

---- File: AuthService.Domain\Interfaces\Services\IPasswordResetService.cs ----
using AuthService.Domain.Entities;
using System.Threading.Tasks;

namespace AuthService.Domain.Interfaces.Services;

public interface IPasswordResetService
{
    Task GenerateAndSendTokenAsync(ApplicationUser user);
    Task<bool> ResetAsync(string token, string newPassword);
}

---- File: AuthService.Domain\Interfaces\Services\IPasswordResetTokenService.cs ----
namespace AuthService.Domain.Interfaces.Services;

public interface IPasswordResetTokenService
{
    string GenerateResetToken(string email);
    bool ValidateResetToken(string token, out string email);
    Task<bool> IsTokenValidAsync(string email, string token);
    Task InvalidateTokenAsync(string email);
}

---- File: AuthService.Domain\Interfaces\Services\IQRCodeService.cs ----
namespace AuthService.Domain.Interfaces.Services;

public interface IQRCodeService
{
    string GenerateQRCode(string text, int size = 300);
}

---- File: AuthService.Domain\Interfaces\Services\ITokenService.cs ----
using AuthService.Domain.Entities;

namespace AuthService.Domain.Interfaces.Services;

public interface ITokenService
{
    Task<(string accessToken, string refreshToken)> GenerateTokensAsync(ApplicationUser user, string ipAddress);
    Task<bool> RevokeRefreshTokenAsync(string refreshToken, string ipAddress, string reason = "revoked");
    Task<bool> IsAccessTokenValidAsync(string accessToken, string userId);
    Task CleanupExpiredTokensAsync();
}

---- File: AuthService.Domain\Interfaces\Services\ITwoFactorService.cs ----
// AuthService.Domain/Interfaces/Services/ITwoFactorService.cs
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;

namespace AuthService.Domain.Interfaces.Services;

public interface ITwoFactorService
{
    // Authenticator App
    Task<(string secret, string qrCodeUri)> GenerateAuthenticatorKeyAsync(string userId, string email);
    bool VerifyAuthenticatorCode(string secret, string code);

    // SMS/Email
    Task<string> GenerateSmsCodeAsync(string userId);
    Task<string> GenerateEmailCodeAsync(string userId);
    Task<bool> VerifyCodeAsync(string userId, string code, TwoFactorAuthType type);

    // Recovery Codes
    Task<List<string>> GenerateRecoveryCodesAsync(string userId);
    Task<bool> VerifyRecoveryCodeAsync(string userId, string code);

    // General
    Task<bool> IsTwoFactorEnabledAsync(string userId);

    Task<bool> SendTwoFactorCodeAsync(string userId, TwoFactorAuthType type);
    Task<bool> SendTwoFactorCodeToDestinationAsync(string userId, TwoFactorAuthType type, string destination);
}

---- File: AuthService.Domain\ValueObjects\Email.cs ----
using AuthService.Domain.Exceptions;

namespace AuthService.Domain.ValueObjects;

public record Email
{
    public string Value { get; }
    public string NormalizedValue { get; }

    public Email(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new DomainException("Email cannot be empty");

        if (!IsValidEmail(value))
            throw new InvalidEmailException(value);

        Value = value.Trim().ToLower();
        NormalizedValue = Value.ToUpperInvariant();
    }

    public static implicit operator string(Email email) => email.Value;
    public static implicit operator Email(string email) => new(email);

    public override string ToString() => Value;

    public string GetDomain()
    {
        var atIndex = Value.IndexOf('@');
        return atIndex > 0 ? Value[(atIndex + 1)..] : string.Empty;
    }

    public string GetUsername()
    {
        var atIndex = Value.IndexOf('@');
        return atIndex > 0 ? Value[..atIndex] : Value;
    }

    private static bool IsValidEmail(string email)
    {
        try
        {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        }
        catch
        {
            return false;
        }
    }

    public override int GetHashCode() => Value.GetHashCode();

    public virtual bool Equals(Email? other)
    {
        if (other is null) return false;
        return Value == other.Value;
    }
}

---- File: AuthService.Domain\ValueObjects\ExternalUserInfo.cs ----
namespace AuthService.Domain.ValueObjects;

public record ExternalUserInfo(
    string UserId,
    string Email,
    string Name,
    string FirstName,
    string LastName,
    string? PictureUrl,
    string Provider,
    Dictionary<string, object> AdditionalData
);

---- File: AuthService.Domain\ValueObjects\Password.cs ----
using AuthService.Domain.Exceptions;

namespace AuthService.Domain.ValueObjects;

public record Password
{
    public string Hash { get; }
    public bool IsHashed { get; }

    private Password(string value, bool isHashed)
    {
        Hash = value;
        IsHashed = isHashed;
    }

    public static Password CreatePlain(string plainPassword)
    {
        if (string.IsNullOrWhiteSpace(plainPassword))
            throw new DomainException("Password cannot be empty");

        if (plainPassword.Length < 8)
            throw new DomainException("Password must be at least 8 characters long");

        if (!HasRequiredComplexity(plainPassword))
            throw new DomainException("Password must contain at least one uppercase letter, one lowercase letter, and one number");

        return new Password(plainPassword, false);
    }

    public static Password CreateHashed(string hash)
    {
        if (string.IsNullOrWhiteSpace(hash))
            throw new DomainException("Password hash cannot be empty");

        return new Password(hash, true);
    }

    private static bool HasRequiredComplexity(string password)
    {
        return password.Any(char.IsUpper) &&
               password.Any(char.IsLower) &&
               password.Any(char.IsDigit);
    }

    public override string ToString() => IsHashed ? "[HASHED]" : "[PLAIN]";

    public override int GetHashCode() => Hash.GetHashCode();

    public virtual bool Equals(Password? other)
    {
        if (other is null) return false;
        return Hash == other.Hash && IsHashed == other.IsHashed;
    }
}

---- File: AuthService.Infrastructure\AuthService.Infrastructure.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <!-- ASP.NET Core Identity -->
    <PackageReference Include="Microsoft.AspNetCore.Identity.EntityFrameworkCore" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Identity" Version="2.3.1" />
    
    <!-- JWT Authentication - ACTUALIZADO para evitar vulnerabilidad -->
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />
    <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.0.1" />
    
    <!-- Entity Framework -->
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.0" />
    
    <!-- Caching -->
    <PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" Version="8.0.1" />
    
    <!-- HTTP Client -->
    <PackageReference Include="Microsoft.Extensions.Http" Version="8.0.0" />
    <PackageReference Include="System.Net.Http.Json" Version="8.0.0" />
    
    <!-- Configuration -->
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />

    <PackageReference Include="Otp.NET" Version="1.4.0" />
    <PackageReference Include="QRCoder" Version="1.4.3" />

    <PackageReference Include="Microsoft.AspNetCore.Authentication.Google" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Authentication.MicrosoftAccount" Version="8.0.0" />

    <PackageReference Include="MediatR" Version="12.2.0" />
    
    <!-- RabbitMQ -->
    <PackageReference Include="RabbitMQ.Client" Version="6.8.1" />
    
  </ItemGroup>

  <ItemGroup>
  <ProjectReference Include="..\AuthService.Application\AuthService.Application.csproj" />
  <ProjectReference Include="..\AuthService.Domain\AuthService.Domain.csproj" />
  <ProjectReference Include="..\AuthService.Shared\AuthService.Shared.csproj" />
  <ProjectReference Include="..\..\ErrorService\ErrorService.Shared\ErrorService.Shared.csproj" />
</ItemGroup>


</Project>

---- File: AuthService.Infrastructure\packages.lock.json ----
{
  "version": 1,
  "dependencies": {
    "net8.0": {
      "MediatR": {
        "type": "Direct",
        "requested": "[12.2.0, )",
        "resolved": "12.2.0",
        "contentHash": "8TUFrHapKi6D74PhnSNEguRsH91HNGyP3R4ZQdgDorJgl9Wac5Prh0vA33QfrniAaS6L2xNNhc6vxzg+5AIbwA==",
        "dependencies": {
          "MediatR.Contracts": "[2.0.1, 3.0.0)",
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.0"
        }
      },
      "Microsoft.AspNetCore.Authentication.Google": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "dPE/IiHhBqnJ7WrD72T20+DcHGCaR9F4RmIFap83W1Ts/ze5gBVe4Ii02qJdJzkUniQy5S/v42zpRIgJTPzPqQ=="
      },
      "Microsoft.AspNetCore.Authentication.JwtBearer": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "rwxaZYHips5M9vqxRkGfJthTx+Ws4O4yCuefn17J371jL3ouC5Ker43h2hXb5yd9BMnImE9rznT75KJHm6bMgg==",
        "dependencies": {
          "Microsoft.IdentityModel.Protocols.OpenIdConnect": "7.0.3"
        }
      },
      "Microsoft.AspNetCore.Authentication.MicrosoftAccount": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "ktbBoHAGlm3YENnKQ0GKGCpSBnfn4ahREuKdCm0AUxaCU2QJoezbhUSKEFoXHjJlh7sIMsiDtbaq6yS5B7PswA=="
      },
      "Microsoft.AspNetCore.Identity": {
        "type": "Direct",
        "requested": "[2.3.1, )",
        "resolved": "2.3.1",
        "contentHash": "JcQ4pNXg+IISfcR95jeO2ZRt38N67MrUEj28HBmwfqD96BUyw4S54tQhrBmCOyPlf2vgNvSz/tsGAG7EgC0yRg==",
        "dependencies": {
          "Microsoft.AspNetCore.Authentication.Cookies": "2.3.0",
          "Microsoft.AspNetCore.Cryptography.KeyDerivation": "2.3.0",
          "Microsoft.AspNetCore.Hosting.Abstractions": "2.3.0",
          "Microsoft.Extensions.Identity.Core": "2.3.0"
        }
      },
      "Microsoft.AspNetCore.Identity.EntityFrameworkCore": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "ua2LSZY/f0BkNUUVPPm83eq4Xnt+FZYutiMimRrzSmv2K2t2Ia/PuP4CfibYNSwnKl6fbZ49Bwn2mQGWnmmvOA==",
        "dependencies": {
          "Microsoft.EntityFrameworkCore.Relational": "8.0.0",
          "Microsoft.Extensions.Identity.Stores": "8.0.0"
        }
      },
      "Microsoft.EntityFrameworkCore": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "SoODat83pGQUpWB9xULdMX6tuKpq/RTXDuJ2WeC1ldUKcKzLkaFJD1n+I0nOLY58odez/e7z8b6zdp235G/kyg==",
        "dependencies": {
          "Microsoft.EntityFrameworkCore.Abstractions": "8.0.0",
          "Microsoft.EntityFrameworkCore.Analyzers": "8.0.0",
          "Microsoft.Extensions.Caching.Memory": "8.0.0",
          "Microsoft.Extensions.Logging": "8.0.0"
        }
      },
      "Microsoft.EntityFrameworkCore.Design": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "94reKYu63jg4O75UI3LMJHwOSi8tQ6IfubiZhdnSsWcgtmAuF8OyLfjK/MIxuvaQRJZAF6E747FIuxjOtb8/og==",
        "dependencies": {
          "Humanizer.Core": "2.14.1",
          "Microsoft.CodeAnalysis.CSharp.Workspaces": "4.5.0",
          "Microsoft.EntityFrameworkCore.Relational": "8.0.0",
          "Microsoft.Extensions.DependencyModel": "8.0.0",
          "Mono.TextTemplating": "2.2.1"
        }
      },
      "Microsoft.Extensions.Caching.Memory": {
        "type": "Direct",
        "requested": "[8.0.1, )",
        "resolved": "8.0.1",
        "contentHash": "HFDnhYLccngrzyGgHkjEDU5FMLn4MpOsr5ElgsBMC4yx6lJh4jeWO7fHS8+TXPq+dgxCmUa/Trl8svObmwW4QA==",
        "dependencies": {
          "Microsoft.Extensions.Caching.Abstractions": "8.0.0",
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.2",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.2",
          "Microsoft.Extensions.Options": "8.0.2",
          "Microsoft.Extensions.Primitives": "8.0.0"
        }
      },
      "Microsoft.Extensions.Caching.StackExchangeRedis": {
        "type": "Direct",
        "requested": "[8.0.1, )",
        "resolved": "8.0.1",
        "contentHash": "Z6Wg+oyypeXfYNUbrFZ/zzqmoQOH0SpvAzj8fWEf8kF8HmmkLkJ4yIHGOu/R1tjCpoWzhgWxgME6Ct+ovRA+Ig==",
        "dependencies": {
          "Microsoft.Extensions.Caching.Abstractions": "8.0.0",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.0",
          "Microsoft.Extensions.Options": "8.0.1",
          "StackExchange.Redis": "2.6.122"
        }
      },
      "Microsoft.Extensions.Configuration.Binder": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "mBMoXLsr5s1y2zOHWmKsE9veDcx8h1x/c3rz4baEdQKTeDcmQAPNbB54Pi/lhFO3K431eEq6PFbMgLaa6PHFfA==",
        "dependencies": {
          "Microsoft.Extensions.Configuration.Abstractions": "8.0.0"
        }
      },
      "Microsoft.Extensions.Http": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "cWz4caHwvx0emoYe7NkHPxII/KkTI8R/LC9qdqJqnKv2poTJ4e2qqPGQqvRoQ5kaSA4FU5IV3qFAuLuOhoqULQ==",
        "dependencies": {
          "Microsoft.Extensions.Configuration.Abstractions": "8.0.0",
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.0",
          "Microsoft.Extensions.Diagnostics": "8.0.0",
          "Microsoft.Extensions.Logging": "8.0.0",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.0",
          "Microsoft.Extensions.Options": "8.0.0"
        }
      },
      "Microsoft.Extensions.Options.ConfigurationExtensions": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "0f4DMRqEd50zQh+UyJc+/HiBsZ3vhAQALgdkcQEalSH1L2isdC7Yj54M3cyo5e+BeO5fcBQ7Dxly8XiBBcvRgw==",
        "dependencies": {
          "Microsoft.Extensions.Configuration.Abstractions": "8.0.0",
          "Microsoft.Extensions.Configuration.Binder": "8.0.0",
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.0",
          "Microsoft.Extensions.Options": "8.0.0",
          "Microsoft.Extensions.Primitives": "8.0.0"
        }
      },
      "Npgsql.EntityFrameworkCore.PostgreSQL": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "GDXiMS9peEdjSCU/rfgyHruio7q6tYuywGaktqEi6UPQ6ILechp3fVVX+dHXkIXt4nklCBzYVWkzFrSL9ubKUA==",
        "dependencies": {
          "Microsoft.EntityFrameworkCore": "8.0.0",
          "Microsoft.EntityFrameworkCore.Abstractions": "8.0.0",
          "Microsoft.EntityFrameworkCore.Relational": "8.0.0",
          "Npgsql": "8.0.0"
        }
      },
      "Otp.NET": {
        "type": "Direct",
        "requested": "[1.4.0, )",
        "resolved": "1.4.0",
        "contentHash": "Fk1NKc0lWmlo6LAFYpFJInRgFKt72knRNEvxndDYoQHFwYOPXav+WEUBvQA0k4lxq5xt0SymrZ+oi0F/G40bPQ=="
      },
      "QRCoder": {
        "type": "Direct",
        "requested": "[1.4.3, )",
        "resolved": "1.4.3",
        "contentHash": "fWuFqjm8GTlEb2GqBl3Hi8HZZeZQwBSHxvRPtPjyNbT82H0ff0JwavKRBmMaXCno1Av6McPC8aJzri0Mj2w9Jw=="
      },
      "RabbitMQ.Client": {
        "type": "Direct",
        "requested": "[6.8.1, )",
        "resolved": "6.8.1",
        "contentHash": "jNsmGgmCNw2S/NzskeN2ijtGywtH4Sk/G6jWUTD5sY9SrC27Xz6BsLIiB8hdsfjeyWCa4j4GvCIGkpE8wrjU1Q==",
        "dependencies": {
          "System.Memory": "4.5.5",
          "System.Threading.Channels": "7.0.0"
        }
      },
      "System.IdentityModel.Tokens.Jwt": {
        "type": "Direct",
        "requested": "[8.0.1, )",
        "resolved": "8.0.1",
        "contentHash": "GJw3bYkWpOgvN3tJo5X4lYUeIFA2HD293FPUhKmp7qxS+g5ywAb34Dnd3cDAFLkcMohy5XTpoaZ4uAHuw0uSPQ==",
        "dependencies": {
          "Microsoft.IdentityModel.JsonWebTokens": "8.0.1",
          "Microsoft.IdentityModel.Tokens": "8.0.1"
        }
      },
      "System.Net.Http.Json": {
        "type": "Direct",
        "requested": "[8.0.0, )",
        "resolved": "8.0.0",
        "contentHash": "48Bxrd6zcGeQzS4GMEDVjuqCcAw/9wcEWnIu48FQJ5IzfKPiMR1nGtz9LrvGzU4+3TLbx/9FDlGmCUeLin1Eqg==",
        "dependencies": {
          "System.Text.Json": "8.0.0"
        }
      },
      "FluentValidation": {
        "type": "Transitive",
        "resolved": "11.9.0",
        "contentHash": "VneVlTvwYDkfHV5av3QrQ0amALgrLX6LV94wlYyEsh0B/klJBW7C8y2eAtj5tOZ3jH6CAVpr4s1ZGgew/QWyig=="
      },
      "Humanizer.Core": {
        "type": "Transitive",
        "resolved": "2.14.1",
        "contentHash": "lQKvtaTDOXnoVJ20ibTuSIOf2i0uO0MPbDhd1jm238I+U/2ZnRENj0cktKZhtchBMtCUSRQ5v4xBCUbKNmyVMw=="
      },
      "MediatR.Contracts": {
        "type": "Transitive",
        "resolved": "2.0.1",
        "contentHash": "FYv95bNT4UwcNA+G/J1oX5OpRiSUxteXaUt2BJbRSdRNiIUNbggJF69wy6mnk2wYToaanpdXZdCwVylt96MpwQ=="
      },
      "Microsoft.AspNetCore.Authentication": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "Tq6bxTOe65Ikh9dWVTEOqpvNqBGIQueO0J+zl2rQba0yP0YV66iYDkSz9MqTdRZftvJ2I5kMeRUm9Z2mjEAbUQ==",
        "dependencies": {
          "Microsoft.AspNetCore.Authentication.Core": "2.3.0",
          "Microsoft.AspNetCore.DataProtection": "2.3.0",
          "Microsoft.AspNetCore.Http": "2.3.0",
          "Microsoft.AspNetCore.Http.Extensions": "2.3.0",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.2",
          "Microsoft.Extensions.Options": "8.0.2",
          "Microsoft.Extensions.WebEncoders": "8.0.11"
        }
      },
      "Microsoft.AspNetCore.Authentication.Abstractions": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "ve6uvLwKNRkfnO/QeN9M8eUJ49lCnWv/6/9p6iTEuiI6Rtsz+myaBAjdMzLuTViQY032xbTF5AdZF5BJzJJyXQ==",
        "dependencies": {
          "Microsoft.AspNetCore.Http.Abstractions": "2.3.0",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.2",
          "Microsoft.Extensions.Options": "8.0.2"
        }
      },
      "Microsoft.AspNetCore.Authentication.Cookies": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "w3JPWHreXJ/Uv9CLkQtGCLwTbxZKY+94QPVi1RxcMuBTyRp+C9SdynznHEjnHWnw6QFNEHnBuHmWW3OYrvbpEQ==",
        "dependencies": {
          "Microsoft.AspNetCore.Authentication": "2.3.0"
        }
      },
      "Microsoft.AspNetCore.Authentication.Core": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "gnLnKGawBjqBnU9fEuel3VcYAARkjyONAliaGDfMc8o8HBtfh+HrOPEoR8Xx4b2RnMb7uxdBDOvEAC7sul79ig==",
        "dependencies": {
          "Microsoft.AspNetCore.Authentication.Abstractions": "2.3.0",
          "Microsoft.AspNetCore.Http": "2.3.0",
          "Microsoft.AspNetCore.Http.Extensions": "2.3.0"
        }
      },
      "Microsoft.AspNetCore.Cryptography.Internal": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "buuMMCTxFcVkOkEftb2OafYxrveNGre9KJF4Oi1DkR4rxIj6oLam7Wq3g0Fp9hNVpJteKEPiupsxYnPrD/oUGA=="
      },
      "Microsoft.AspNetCore.Cryptography.KeyDerivation": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "65w93R5wqUUs35R9wjHHDf75GqAbxJsNByKZo5TbQOWSXcUbLWrDUWBQHv78iXIT0PL1pXNqKQz7OHiHMvo0/A==",
        "dependencies": {
          "Microsoft.AspNetCore.Cryptography.Internal": "8.0.0"
        }
      },
      "Microsoft.AspNetCore.DataProtection": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "C+FhGaA8ekrfes0Ujhtkhk74Bpkt6Zt+NrMaGrCWBqW1LFzqw/pXDbMbpcAyI9hbYgZfC6+t01As4LGXbdxG4A==",
        "dependencies": {
          "Microsoft.AspNetCore.Cryptography.Internal": "2.3.0",
          "Microsoft.AspNetCore.DataProtection.Abstractions": "2.3.0",
          "Microsoft.AspNetCore.Hosting.Abstractions": "2.3.0",
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.2",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.2",
          "Microsoft.Extensions.Options": "8.0.2",
          "Microsoft.Win32.Registry": "4.5.0",
          "System.Security.Cryptography.Xml": "8.0.2",
          "System.Security.Principal.Windows": "5.0.0"
        }
      },
      "Microsoft.AspNetCore.DataProtection.Abstractions": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "71GdtUkVDagLsBt+YatfzUItnbT2vIjHxWySNE2MkgIDhqT3g4sNNxOj/0PlPTpc1+mG3ZwfUoZ61jIt1wPw7g=="
      },
      "Microsoft.AspNetCore.Hosting.Abstractions": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "4ivq53W2k6Nj4eez9wc81ytfGj6HR1NaZJCpOrvghJo9zHuQF57PLhPoQH5ItyCpHXnrN/y7yJDUm+TGYzrx0w==",
        "dependencies": {
          "Microsoft.AspNetCore.Hosting.Server.Abstractions": "2.3.0",
          "Microsoft.AspNetCore.Http.Abstractions": "2.3.0",
          "Microsoft.Extensions.Hosting.Abstractions": "8.0.1"
        }
      },
      "Microsoft.AspNetCore.Hosting.Server.Abstractions": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "F5iHx7odAbFKBV1DNPDkFFcVmD5Tk7rk+tYm3LMQxHEFFdjlg5QcYb5XhHAefl5YaaPeG6ad+/ck8kSG3/D6kw==",
        "dependencies": {
          "Microsoft.AspNetCore.Http.Features": "2.3.0",
          "Microsoft.Extensions.Configuration.Abstractions": "8.0.0"
        }
      },
      "Microsoft.AspNetCore.Http": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "I9azEG2tZ4DDHAFgv+N38e6Yhttvf+QjE2j2UYyCACE7Swm5/0uoihCMWZ87oOZYeqiEFSxbsfpT71OYHe2tpw==",
        "dependencies": {
          "Microsoft.AspNetCore.Http.Abstractions": "2.3.0",
          "Microsoft.AspNetCore.WebUtilities": "2.3.0",
          "Microsoft.Extensions.ObjectPool": "8.0.11",
          "Microsoft.Extensions.Options": "8.0.2",
          "Microsoft.Net.Http.Headers": "2.3.0"
        }
      },
      "Microsoft.AspNetCore.Http.Abstractions": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "39r9PPrjA6s0blyFv5qarckjNkaHRA5B+3b53ybuGGNTXEj1/DStQJ4NWjFL6QTRQpL9zt7nDyKxZdJOlcnq+Q==",
        "dependencies": {
          "Microsoft.AspNetCore.Http.Features": "2.3.0",
          "System.Text.Encodings.Web": "8.0.0"
        }
      },
      "Microsoft.AspNetCore.Http.Extensions": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "EY2u/wFF5jsYwGXXswfQWrSsFPmiXsniAlUWo3rv/MGYf99ZFsENDnZcQP6W3c/+xQmQXq0NauzQ7jyy+o1LDQ==",
        "dependencies": {
          "Microsoft.AspNetCore.Http.Abstractions": "2.3.0",
          "Microsoft.Extensions.FileProviders.Abstractions": "8.0.0",
          "Microsoft.Net.Http.Headers": "2.3.0",
          "System.Buffers": "4.6.0"
        }
      },
      "Microsoft.AspNetCore.Http.Features": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "f10WUgcsKqrkmnz6gt8HeZ7kyKjYN30PO7cSic1lPtH7paPtnQqXPOveul/SIPI43PhRD4trttg4ywnrEmmJpA==",
        "dependencies": {
          "Microsoft.Extensions.Primitives": "8.0.0"
        }
      },
      "Microsoft.AspNetCore.WebUtilities": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "trbXdWzoAEUVd0PE2yTopkz4kjZaAIA7xUWekd5uBw+7xE8Do/YOVTeb9d9koPTlbtZT539aESJjSLSqD8eYrQ==",
        "dependencies": {
          "Microsoft.Net.Http.Headers": "2.3.0",
          "System.Text.Encodings.Web": "8.0.0"
        }
      },
      "Microsoft.Bcl.AsyncInterfaces": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "UcSjPsst+DfAdJGVDsu346FX0ci0ah+lw3WRtn18NUwEqRt70HaOQ7lI72vy3+1LxtqI3T5GWwV39rQSrCzAeg=="
      },
      "Microsoft.CodeAnalysis.Analyzers": {
        "type": "Transitive",
        "resolved": "3.3.3",
        "contentHash": "j/rOZtLMVJjrfLRlAMckJLPW/1rze9MT1yfWqSIbUPGRu1m1P0fuo9PmqapwsmePfGB5PJrudQLvmUOAMF0DqQ=="
      },
      "Microsoft.CodeAnalysis.Common": {
        "type": "Transitive",
        "resolved": "4.5.0",
        "contentHash": "lwAbIZNdnY0SUNoDmZHkVUwLO8UyNnyyh1t/4XsbFxi4Ounb3xszIYZaWhyj5ZjyfcwqwmtMbE7fUTVCqQEIdQ==",
        "dependencies": {
          "Microsoft.CodeAnalysis.Analyzers": "3.3.3",
          "System.Collections.Immutable": "6.0.0",
          "System.Reflection.Metadata": "6.0.1",
          "System.Runtime.CompilerServices.Unsafe": "6.0.0",
          "System.Text.Encoding.CodePages": "6.0.0"
        }
      },
      "Microsoft.CodeAnalysis.CSharp": {
        "type": "Transitive",
        "resolved": "4.5.0",
        "contentHash": "cM59oMKAOxvdv76bdmaKPy5hfj+oR+zxikWoueEB7CwTko7mt9sVKZI8Qxlov0C/LuKEG+WQwifepqL3vuTiBQ==",
        "dependencies": {
          "Microsoft.CodeAnalysis.Common": "[4.5.0]"
        }
      },
      "Microsoft.CodeAnalysis.CSharp.Workspaces": {
        "type": "Transitive",
        "resolved": "4.5.0",
        "contentHash": "h74wTpmGOp4yS4hj+EvNzEiPgg/KVs2wmSfTZ81upJZOtPkJsVkgfsgtxxqmAeapjT/vLKfmYV0bS8n5MNVP+g==",
        "dependencies": {
          "Humanizer.Core": "2.14.1",
          "Microsoft.CodeAnalysis.CSharp": "[4.5.0]",
          "Microsoft.CodeAnalysis.Common": "[4.5.0]",
          "Microsoft.CodeAnalysis.Workspaces.Common": "[4.5.0]"
        }
      },
      "Microsoft.CodeAnalysis.Workspaces.Common": {
        "type": "Transitive",
        "resolved": "4.5.0",
        "contentHash": "l4dDRmGELXG72XZaonnOeORyD/T5RpEu5LGHOUIhnv+MmUWDY/m1kWXGwtcgQ5CJ5ynkFiRnIYzTKXYjUs7rbw==",
        "dependencies": {
          "Humanizer.Core": "2.14.1",
          "Microsoft.Bcl.AsyncInterfaces": "6.0.0",
          "Microsoft.CodeAnalysis.Common": "[4.5.0]",
          "System.Composition": "6.0.0",
          "System.IO.Pipelines": "6.0.3",
          "System.Threading.Channels": "6.0.0"
        }
      },
      "Microsoft.EntityFrameworkCore.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "VR22s3+zoqlVI7xauFKn1znSIFHO8xuILT+noSwS8bZCKcHz0ydkTDQMuaxSa5WBaQrZmwtTz9rmRvJ7X8mSPQ=="
      },
      "Microsoft.EntityFrameworkCore.Analyzers": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "ZXxEeLs2zoZ1TA+QoMMcw4f3Tirf8PzgdDax8RoWo0dxI2KmqiEGWYjhm2B/XyWfglc6+mNRyB8rZiQSmxCpeg=="
      },
      "Microsoft.EntityFrameworkCore.Relational": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "fFKkr24cYc7Zw5T6DC4tEyOEPgPbq23BBmym1r9kn4ET9F3HKaetpOeQtV2RryYyUxEeNkJuxgfiZHTisqZc+A==",
        "dependencies": {
          "Microsoft.EntityFrameworkCore": "8.0.0",
          "Microsoft.Extensions.Configuration.Abstractions": "8.0.0"
        }
      },
      "Microsoft.Extensions.Caching.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "3KuSxeHoNYdxVYfg2IRZCThcrlJ1XJqIXkAWikCsbm5C/bCjv7G0WoKDyuR98Q+T607QT2Zl5GsbGRkENcV2yQ==",
        "dependencies": {
          "Microsoft.Extensions.Primitives": "8.0.0"
        }
      },
      "Microsoft.Extensions.Configuration": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "0J/9YNXTMWSZP2p2+nvl8p71zpSwokZXZuJW+VjdErkegAnFdO1XlqtA62SJtgVYHdKu3uPxJHcMR/r35HwFBA==",
        "dependencies": {
          "Microsoft.Extensions.Configuration.Abstractions": "8.0.0",
          "Microsoft.Extensions.Primitives": "8.0.0"
        }
      },
      "Microsoft.Extensions.Configuration.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "3lE/iLSutpgX1CC0NOW70FJoGARRHbyKmG7dc0klnUZ9Dd9hS6N/POPWhKhMLCEuNN5nXEY5agmlFtH562vqhQ==",
        "dependencies": {
          "Microsoft.Extensions.Primitives": "8.0.0"
        }
      },
      "Microsoft.Extensions.DependencyInjection": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "V8S3bsm50ig6JSyrbcJJ8bW2b9QLGouz+G1miK3UTaOWmMtFwNNNzUf4AleyDWUmTrWMLNnFSLEQtxmxgNQnNQ==",
        "dependencies": {
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.0"
        }
      },
      "Microsoft.Extensions.DependencyInjection.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.2",
        "contentHash": "3iE7UF7MQkCv1cxzCahz+Y/guQbTqieyxyaWKhrRO91itI9cOKO76OHeQDahqG4MmW5umr3CcCvGmK92lWNlbg=="
      },
      "Microsoft.Extensions.DependencyModel": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "NSmDw3K0ozNDgShSIpsZcbFIzBX4w28nDag+TfaQujkXGazBm+lid5onlWoCBy4VsLxqnnKjEBbGSJVWJMf43g==",
        "dependencies": {
          "System.Text.Encodings.Web": "8.0.0",
          "System.Text.Json": "8.0.0"
        }
      },
      "Microsoft.Extensions.Diagnostics": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "3PZp/YSkIXrF7QK7PfC1bkyRYwqOHpWFad8Qx+4wkuumAeXo1NHaxpS9LboNA9OvNSAu+QOVlXbMyoY+pHSqcw==",
        "dependencies": {
          "Microsoft.Extensions.Configuration": "8.0.0",
          "Microsoft.Extensions.Diagnostics.Abstractions": "8.0.0",
          "Microsoft.Extensions.Options.ConfigurationExtensions": "8.0.0"
        }
      },
      "Microsoft.Extensions.Diagnostics.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.1",
        "contentHash": "elH2vmwNmsXuKmUeMQ4YW9ldXiF+gSGDgg1vORksob5POnpaI6caj1Hu8zaYbEuibhqCoWg0YRWDazBY3zjBfg==",
        "dependencies": {
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.2",
          "Microsoft.Extensions.Options": "8.0.2"
        }
      },
      "Microsoft.Extensions.FileProviders.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "ZbaMlhJlpisjuWbvXr4LdAst/1XxH3vZ6A0BsgTphZ2L4PGuxRLz7Jr/S7mkAAnOn78Vu0fKhEgNF5JO3zfjqQ==",
        "dependencies": {
          "Microsoft.Extensions.Primitives": "8.0.0"
        }
      },
      "Microsoft.Extensions.Hosting.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.1",
        "contentHash": "nHwq9aPBdBPYXPti6wYEEfgXddfBrYC+CQLn+qISiwQq5tpfaqDZSKOJNxoe9rfQxGf1c+2wC/qWFe1QYJPYqw==",
        "dependencies": {
          "Microsoft.Extensions.Configuration.Abstractions": "8.0.0",
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.2",
          "Microsoft.Extensions.Diagnostics.Abstractions": "8.0.1",
          "Microsoft.Extensions.FileProviders.Abstractions": "8.0.0",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.2"
        }
      },
      "Microsoft.Extensions.Identity.Core": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "hnXHyIQc+uc2uNMcIbr43+oNBAPEhMpW6lE8ux3MOegRz50WBna4AItlZDY7Y+Id1LLBbf73osUqeTw7CQ371w==",
        "dependencies": {
          "Microsoft.AspNetCore.Cryptography.KeyDerivation": "8.0.0",
          "Microsoft.Extensions.Logging": "8.0.0",
          "Microsoft.Extensions.Options": "8.0.0"
        }
      },
      "Microsoft.Extensions.Identity.Stores": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "DmDCpSpngZDBm44wVmxCeYs4HGJr/m32jMItp6pfb7KKtqWYw2vybHRg880j18k/eSFyM4v9uONsnEPgDdi9lg==",
        "dependencies": {
          "Microsoft.Extensions.Caching.Abstractions": "8.0.0",
          "Microsoft.Extensions.Identity.Core": "8.0.0",
          "Microsoft.Extensions.Logging": "8.0.0"
        }
      },
      "Microsoft.Extensions.Logging": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "tvRkov9tAJ3xP51LCv3FJ2zINmv1P8Hi8lhhtcKGqM+ImiTCC84uOPEI4z8Cdq2C3o9e+Aa0Gw0rmrsJD77W+w==",
        "dependencies": {
          "Microsoft.Extensions.DependencyInjection": "8.0.0",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.0",
          "Microsoft.Extensions.Options": "8.0.0"
        }
      },
      "Microsoft.Extensions.Logging.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.2",
        "contentHash": "nroMDjS7hNBPtkZqVBbSiQaQjWRDxITI8Y7XnDs97rqG3EbzVTNLZQf7bIeUJcaHOV8bca47s1Uxq94+2oGdxA==",
        "dependencies": {
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.2"
        }
      },
      "Microsoft.Extensions.ObjectPool": {
        "type": "Transitive",
        "resolved": "8.0.11",
        "contentHash": "6ApKcHNJigXBfZa6XlDQ8feJpq7SG1ogZXg6M4FiNzgd6irs3LUAzo0Pfn4F2ZI9liGnH1XIBR/OtSbZmJAV5w=="
      },
      "Microsoft.Extensions.Options": {
        "type": "Transitive",
        "resolved": "8.0.2",
        "contentHash": "dWGKvhFybsaZpGmzkGCbNNwBD1rVlWzrZKANLW/CcbFJpCEceMCGzT7zZwHOGBCbwM0SzBuceMj5HN1LKV1QqA==",
        "dependencies": {
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.0",
          "Microsoft.Extensions.Primitives": "8.0.0"
        }
      },
      "Microsoft.Extensions.Primitives": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "bXJEZrW9ny8vjMF1JV253WeLhpEVzFo1lyaZu1vQ4ZxWUlVvknZ/+ftFgVheLubb4eZPSwwxBeqS1JkCOjxd8g=="
      },
      "Microsoft.Extensions.WebEncoders": {
        "type": "Transitive",
        "resolved": "8.0.11",
        "contentHash": "EwF+KaQzTa/MoIm8gciABL6xeeiGKowqyam+lPYWukTppwch1P3QeL8CpgtLs8kIWuEowpAAUrVfP1kyZsZgqg==",
        "dependencies": {
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.2",
          "Microsoft.Extensions.Options": "8.0.2"
        }
      },
      "Microsoft.IdentityModel.Abstractions": {
        "type": "Transitive",
        "resolved": "8.0.1",
        "contentHash": "OtlIWcyX01olfdevPKZdIPfBEvbcioDyBiE/Z2lHsopsMD7twcKtlN9kMevHmI5IIPhFpfwCIiR6qHQz1WHUIw=="
      },
      "Microsoft.IdentityModel.JsonWebTokens": {
        "type": "Transitive",
        "resolved": "8.0.1",
        "contentHash": "s6++gF9x0rQApQzOBbSyp4jUaAlwm+DroKfL8gdOHxs83k8SJfUXhuc46rDB3rNXBQ1MVRxqKUrqFhO/M0E97g==",
        "dependencies": {
          "Microsoft.IdentityModel.Tokens": "8.0.1"
        }
      },
      "Microsoft.IdentityModel.Logging": {
        "type": "Transitive",
        "resolved": "8.0.1",
        "contentHash": "UCPF2exZqBXe7v/6sGNiM6zCQOUXXQ9+v5VTb9gPB8ZSUPnX53BxlN78v2jsbIvK9Dq4GovQxo23x8JgWvm/Qg==",
        "dependencies": {
          "Microsoft.IdentityModel.Abstractions": "8.0.1"
        }
      },
      "Microsoft.IdentityModel.Protocols": {
        "type": "Transitive",
        "resolved": "7.0.3",
        "contentHash": "BtwR+tctBYhPNygyZmt1Rnw74GFrJteW+1zcdIgyvBCjkek6cNwPPqRfdhzCv61i+lwyNomRi8+iI4QKd4YCKA==",
        "dependencies": {
          "Microsoft.IdentityModel.Logging": "7.0.3",
          "Microsoft.IdentityModel.Tokens": "7.0.3"
        }
      },
      "Microsoft.IdentityModel.Protocols.OpenIdConnect": {
        "type": "Transitive",
        "resolved": "7.0.3",
        "contentHash": "W97TraHApDNArLwpPcXfD+FZH7njJsfEwZE9y9BoofeXMS8H0LBBobz0VOmYmMK4mLdOKxzN7SFT3Ekg0FWI3Q==",
        "dependencies": {
          "Microsoft.IdentityModel.Protocols": "7.0.3",
          "System.IdentityModel.Tokens.Jwt": "7.0.3"
        }
      },
      "Microsoft.IdentityModel.Tokens": {
        "type": "Transitive",
        "resolved": "8.0.1",
        "contentHash": "kDimB6Dkd3nkW2oZPDkMkVHfQt3IDqO5gL0oa8WVy3OP4uE8Ij+8TXnqg9TOd9ufjsY3IDiGz7pCUbnfL18tjg==",
        "dependencies": {
          "Microsoft.IdentityModel.Logging": "8.0.1"
        }
      },
      "Microsoft.Net.Http.Headers": {
        "type": "Transitive",
        "resolved": "2.3.0",
        "contentHash": "/M0wVg6tJUOHutWD3BMOUVZAioJVXe0tCpFiovzv0T9T12TBf4MnaHP0efO8TCr1a6O9RZgQeZ9Gdark8L9XdA==",
        "dependencies": {
          "Microsoft.Extensions.Primitives": "8.0.0",
          "System.Buffers": "4.6.0"
        }
      },
      "Microsoft.NETCore.Platforms": {
        "type": "Transitive",
        "resolved": "2.0.0",
        "contentHash": "VdLJOCXhZaEMY7Hm2GKiULmn7IEPFE4XC5LPSfBVCUIA8YLZVh846gtfBJalsPQF2PlzdD7ecX7DZEulJ402ZQ=="
      },
      "Microsoft.Win32.Registry": {
        "type": "Transitive",
        "resolved": "4.5.0",
        "contentHash": "+FWlwd//+Tt56316p00hVePBCouXyEzT86Jb3+AuRotTND0IYn0OO3obs1gnQEs/txEnt+rF2JBGLItTG+Be6A==",
        "dependencies": {
          "System.Security.AccessControl": "4.5.0",
          "System.Security.Principal.Windows": "4.5.0"
        }
      },
      "Mono.TextTemplating": {
        "type": "Transitive",
        "resolved": "2.2.1",
        "contentHash": "KZYeKBET/2Z0gY1WlTAK7+RHTl7GSbtvTLDXEZZojUdAPqpQNDL6tHv7VUpqfX5VEOh+uRGKaZXkuD253nEOBQ==",
        "dependencies": {
          "System.CodeDom": "4.4.0"
        }
      },
      "Npgsql": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "Qiz74U+O7Mv4knrsXgKVYGJjgwoziK+aMFZqz7PtKR3vyGIhZA0tnW6HoUnL3X+YqtmVuhmoKkN8LDWEHMxPbw==",
        "dependencies": {
          "Microsoft.Extensions.Logging.Abstractions": "8.0.0"
        }
      },
      "Pipelines.Sockets.Unofficial": {
        "type": "Transitive",
        "resolved": "2.2.8",
        "contentHash": "zG2FApP5zxSx6OcdJQLbZDk2AVlN2BNQD6MorwIfV6gVj0RRxWPEp2LXAxqDGZqeNV1Zp0BNPcNaey/GXmTdvQ==",
        "dependencies": {
          "System.IO.Pipelines": "5.0.1"
        }
      },
      "Serilog": {
        "type": "Transitive",
        "resolved": "3.1.1",
        "contentHash": "P6G4/4Kt9bT635bhuwdXlJ2SCqqn2nhh4gqFqQueCOr9bK/e7W9ll/IoX1Ter948cV2Z/5+5v8pAfJYUISY03A=="
      },
      "Serilog.AspNetCore": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "FAjtKPZ4IzqFQBqZKPv6evcXK/F0ls7RoXI/62Pnx2igkDZ6nZ/jn/C/FxVATqQbEQvtqP+KViWYIe4NZIHa2w==",
        "dependencies": {
          "Microsoft.Extensions.DependencyInjection": "8.0.0",
          "Microsoft.Extensions.Logging": "8.0.0",
          "Serilog": "3.1.1",
          "Serilog.Extensions.Hosting": "8.0.0",
          "Serilog.Extensions.Logging": "8.0.0",
          "Serilog.Formatting.Compact": "2.0.0",
          "Serilog.Settings.Configuration": "8.0.0",
          "Serilog.Sinks.Console": "5.0.0",
          "Serilog.Sinks.Debug": "2.0.0",
          "Serilog.Sinks.File": "5.0.0"
        }
      },
      "Serilog.Extensions.Hosting": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "db0OcbWeSCvYQkHWu6n0v40N4kKaTAXNjlM3BKvcbwvNzYphQFcBR+36eQ/7hMMwOkJvAyLC2a9/jNdUL5NjtQ==",
        "dependencies": {
          "Microsoft.Extensions.DependencyInjection.Abstractions": "8.0.0",
          "Microsoft.Extensions.Hosting.Abstractions": "8.0.0",
          "Microsoft.Extensions.Logging.Abstractions": "8.0.0",
          "Serilog": "3.1.1",
          "Serilog.Extensions.Logging": "8.0.0"
        }
      },
      "Serilog.Extensions.Logging": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "YEAMWu1UnWgf1c1KP85l1SgXGfiVo0Rz6x08pCiPOIBt2Qe18tcZLvdBUuV5o1QHvrs8FAry9wTIhgBRtjIlEg==",
        "dependencies": {
          "Microsoft.Extensions.Logging": "8.0.0",
          "Serilog": "3.1.1"
        }
      },
      "Serilog.Formatting.Compact": {
        "type": "Transitive",
        "resolved": "2.0.0",
        "contentHash": "ob6z3ikzFM3D1xalhFuBIK1IOWf+XrQq+H4KeH4VqBcPpNcmUgZlRQ2h3Q7wvthpdZBBoY86qZOI2LCXNaLlNA==",
        "dependencies": {
          "Serilog": "3.1.0"
        }
      },
      "Serilog.Settings.Configuration": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "nR0iL5HwKj5v6ULo3/zpP8NMcq9E2pxYA6XKTSWCbugVs4YqPyvaqaKOY+OMpPivKp7zMEpax2UKHnDodbRB0Q==",
        "dependencies": {
          "Microsoft.Extensions.Configuration.Binder": "8.0.0",
          "Microsoft.Extensions.DependencyModel": "8.0.0",
          "Serilog": "3.1.1"
        }
      },
      "Serilog.Sinks.Console": {
        "type": "Transitive",
        "resolved": "5.0.0",
        "contentHash": "IZ6bn79k+3SRXOBpwSOClUHikSkp2toGPCZ0teUkscv4dpDg9E2R2xVsNkLmwddE4OpNVO3N0xiYsAH556vN8Q==",
        "dependencies": {
          "Serilog": "3.1.0"
        }
      },
      "Serilog.Sinks.Debug": {
        "type": "Transitive",
        "resolved": "2.0.0",
        "contentHash": "Y6g3OBJ4JzTyyw16fDqtFcQ41qQAydnEvEqmXjhwhgjsnG/FaJ8GUqF5ldsC/bVkK8KYmqrPhDO+tm4dF6xx4A==",
        "dependencies": {
          "Serilog": "2.10.0"
        }
      },
      "Serilog.Sinks.File": {
        "type": "Transitive",
        "resolved": "5.0.0",
        "contentHash": "uwV5hdhWPwUH1szhO8PJpFiahqXmzPzJT/sOijH/kFgUx+cyoDTMM8MHD0adw9+Iem6itoibbUXHYslzXsLEAg==",
        "dependencies": {
          "Serilog": "2.10.0"
        }
      },
      "StackExchange.Redis": {
        "type": "Transitive",
        "resolved": "2.6.122",
        "contentHash": "wp7mvGpFXaevfZ07/SDeh/6YHUJEgwJIGyjbDWKBYbPwKMJQYFz9zFEmBptqtVzqvSgft5nlewwutoaMaG0LPA==",
        "dependencies": {
          "Pipelines.Sockets.Unofficial": "2.2.8"
        }
      },
      "System.Buffers": {
        "type": "Transitive",
        "resolved": "4.6.0",
        "contentHash": "lN6tZi7Q46zFzAbRYXTIvfXcyvQQgxnY7Xm6C6xQ9784dEL1amjM6S6Iw4ZpsvesAKnRVsM4scrDQaDqSClkjA=="
      },
      "System.CodeDom": {
        "type": "Transitive",
        "resolved": "4.4.0",
        "contentHash": "2sCCb7doXEwtYAbqzbF/8UAeDRMNmPaQbU2q50Psg1J9KzumyVVCgKQY8s53WIPTufNT0DpSe9QRvVjOzfDWBA=="
      },
      "System.Collections.Immutable": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "l4zZJ1WU2hqpQQHXz1rvC3etVZN+2DLmQMO79FhOTZHMn8tDRr+WU287sbomD0BETlmKDn0ygUgVy9k5xkkJdA==",
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        }
      },
      "System.Composition": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "d7wMuKQtfsxUa7S13tITC8n1cQzewuhD5iDjZtK2prwFfKVzdYtgrTHgjaV03Zq7feGQ5gkP85tJJntXwInsJA==",
        "dependencies": {
          "System.Composition.AttributedModel": "6.0.0",
          "System.Composition.Convention": "6.0.0",
          "System.Composition.Hosting": "6.0.0",
          "System.Composition.Runtime": "6.0.0",
          "System.Composition.TypedParts": "6.0.0"
        }
      },
      "System.Composition.AttributedModel": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "WK1nSDLByK/4VoC7fkNiFuTVEiperuCN/Hyn+VN30R+W2ijO1d0Z2Qm0ScEl9xkSn1G2MyapJi8xpf4R8WRa/w=="
      },
      "System.Composition.Convention": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "XYi4lPRdu5bM4JVJ3/UIHAiG6V6lWWUlkhB9ab4IOq0FrRsp0F4wTyV4Dj+Ds+efoXJ3qbLqlvaUozDO7OLeXA==",
        "dependencies": {
          "System.Composition.AttributedModel": "6.0.0"
        }
      },
      "System.Composition.Hosting": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "w/wXjj7kvxuHPLdzZ0PAUt++qJl03t7lENmb2Oev0n3zbxyNULbWBlnd5J5WUMMv15kg5o+/TCZFb6lSwfaUUQ==",
        "dependencies": {
          "System.Composition.Runtime": "6.0.0"
        }
      },
      "System.Composition.Runtime": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "qkRH/YBaMPTnzxrS5RDk1juvqed4A6HOD/CwRcDGyPpYps1J27waBddiiq1y93jk2ZZ9wuA/kynM+NO0kb3PKg=="
      },
      "System.Composition.TypedParts": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "iUR1eHrL8Cwd82neQCJ00MpwNIBs4NZgXzrPqx8NJf/k4+mwBO0XCRmHYJT4OLSwDDqh5nBLJWkz5cROnrGhRA==",
        "dependencies": {
          "System.Composition.AttributedModel": "6.0.0",
          "System.Composition.Hosting": "6.0.0",
          "System.Composition.Runtime": "6.0.0"
        }
      },
      "System.IO.Pipelines": {
        "type": "Transitive",
        "resolved": "6.0.3",
        "contentHash": "ryTgF+iFkpGZY1vRQhfCzX0xTdlV3pyaTTqRu2ETbEv+HlV7O6y7hyQURnghNIXvctl5DuZ//Dpks6HdL/Txgw=="
      },
      "System.Memory": {
        "type": "Transitive",
        "resolved": "4.5.5",
        "contentHash": "XIWiDvKPXaTveaB7HVganDlOCRoj03l+jrwNvcge/t8vhGYKvqV+dMv6G4SAX2NoNmN0wZfVPTAlFwZcZvVOUw=="
      },
      "System.Reflection.Metadata": {
        "type": "Transitive",
        "resolved": "6.0.1",
        "contentHash": "III/lNMSn0ZRBuM9m5Cgbiho5j81u0FAEagFX5ta2DKbljZ3T0IpD8j+BIiHQPeKqJppWS9bGEp6JnKnWKze0g==",
        "dependencies": {
          "System.Collections.Immutable": "6.0.0"
        }
      },
      "System.Runtime.CompilerServices.Unsafe": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "/iUeP3tq1S0XdNNoMz5C9twLSrM/TH+qElHkXWaPvuNOt+99G75NrV0OS2EqHx5wMN7popYjpc8oTjC1y16DLg=="
      },
      "System.Security.AccessControl": {
        "type": "Transitive",
        "resolved": "4.5.0",
        "contentHash": "vW8Eoq0TMyz5vAG/6ce483x/CP83fgm4SJe5P8Tb1tZaobcvPrbMEL7rhH1DRdrYbbb6F0vq3OlzmK0Pkwks5A==",
        "dependencies": {
          "Microsoft.NETCore.Platforms": "2.0.0",
          "System.Security.Principal.Windows": "4.5.0"
        }
      },
      "System.Security.Cryptography.Pkcs": {
        "type": "Transitive",
        "resolved": "8.0.1",
        "contentHash": "CoCRHFym33aUSf/NtWSVSZa99dkd0Hm7OCZUxORBjRB16LNhIEOf8THPqzIYlvKM0nNDAPTRBa1FxEECrgaxxA=="
      },
      "System.Security.Cryptography.Xml": {
        "type": "Transitive",
        "resolved": "8.0.2",
        "contentHash": "aDM/wm0ZGEZ6ZYJLzgqjp2FZdHbDHh6/OmpGfb7AdZ105zYmPn/83JRU2xLIbwgoNz9U1SLUTJN0v5th3qmvjA==",
        "dependencies": {
          "System.Security.Cryptography.Pkcs": "8.0.1"
        }
      },
      "System.Security.Principal.Windows": {
        "type": "Transitive",
        "resolved": "5.0.0",
        "contentHash": "t0MGLukB5WAVU9bO3MGzvlGnyJPgUlcwerXn1kzBRjwLKixT96XV0Uza41W49gVd8zEMFu9vQEFlv0IOrytICA=="
      },
      "System.Text.Encoding.CodePages": {
        "type": "Transitive",
        "resolved": "6.0.0",
        "contentHash": "ZFCILZuOvtKPauZ/j/swhvw68ZRi9ATCfvGbk1QfydmcXBkIWecWKn/250UH7rahZ5OoDBaiAudJtPvLwzw85A==",
        "dependencies": {
          "System.Runtime.CompilerServices.Unsafe": "6.0.0"
        }
      },
      "System.Text.Encodings.Web": {
        "type": "Transitive",
        "resolved": "8.0.0",
        "contentHash": "yev/k9GHAEGx2Rg3/tU6MQh4HGBXJs70y7j1LaM1i/ER9po+6nnQ6RRqTJn1E7Xu0fbIFK80Nh5EoODxrbxwBQ=="
      },
      "System.Text.Json": {
        "type": "Transitive",
        "resolved": "8.0.4",
        "contentHash": "bAkhgDJ88XTsqczoxEMliSrpijKZHhbJQldhAmObj/RbrN3sU5dcokuXmWJWsdQAhiMJ9bTayWsL1C9fbbCRhw==",
        "dependencies": {
          "System.Text.Encodings.Web": "8.0.0"
        }
      },
      "System.Threading.Channels": {
        "type": "Transitive",
        "resolved": "7.0.0",
        "contentHash": "qmeeYNROMsONF6ndEZcIQ+VxR4Q/TX/7uIVLJqtwIWL7dDWeh0l1UIqgo4wYyjG//5lUNhwkLDSFl+pAWO6oiA=="
      },
      "authservice.application": {
        "type": "Project",
        "dependencies": {
          "AuthService.Domain": "[1.0.0, )",
          "AuthService.Shared": "[1.0.0, )",
          "ErrorService.Shared": "[1.0.0, )",
          "FluentValidation": "[11.9.0, )",
          "MediatR": "[12.2.0, )",
          "Microsoft.Extensions.Logging.Abstractions": "[8.0.0, )"
        }
      },
      "authservice.domain": {
        "type": "Project",
        "dependencies": {
          "AuthService.Shared": "[1.0.0, )",
          "MediatR.Contracts": "[1.0.1, )",
          "Microsoft.AspNetCore.Identity.EntityFrameworkCore": "[8.0.0, )"
        }
      },
      "authservice.shared": {
        "type": "Project",
        "dependencies": {
          "Microsoft.Extensions.Configuration.Binder": "[8.0.0, )",
          "Microsoft.Extensions.DependencyInjection.Abstractions": "[8.0.0, )",
          "Microsoft.Extensions.Options.ConfigurationExtensions": "[8.0.0, )",
          "System.Text.Json": "[8.0.4, )"
        }
      },
      "errorservice.domain": {
        "type": "Project"
      },
      "errorservice.shared": {
        "type": "Project",
        "dependencies": {
          "ErrorService.Domain": "[1.0.0, )",
          "Microsoft.AspNetCore.Http.Abstractions": "[2.3.0, )",
          "Microsoft.Extensions.DependencyInjection.Abstractions": "[8.0.0, )",
          "RabbitMQ.Client": "[6.8.1, )",
          "Serilog.AspNetCore": "[8.0.0, )"
        }
      }
    }
  }
}

---- File: AuthService.Infrastructure\Extensions\ServiceCollectionExtensions.cs ----
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using AuthService.Domain.Entities;
using AuthService.Infrastructure.External;
using AuthService.Infrastructure.Persistence;
using AuthService.Infrastructure.Persistence.Repositories;
using AuthService.Infrastructure.Services.Identity;
using AuthService.Infrastructure.Services.Notification;
using AuthService.Infrastructure.Services.Security;
using AuthService.Shared;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using System.Text;
using AuthService.Infrastructure.Services.ExternalAuth;
using AuthService.Infrastructure.HealthChecks;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using StackExchange.Redis;
using AuthService.Application.Features.ExternalAuth.Commands.ExternalAuth;

namespace AuthService.Infrastructure.Extensions;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
    {
        // Database Context
        services.AddDbContext<ApplicationDbContext>(options =>
            options.UseNpgsql(configuration.GetConnectionString("DefaultConnection")));

        // Redis Configuration
        var redisConnection = configuration.GetConnectionString("Redis");
        if (!string.IsNullOrEmpty(redisConnection))
        {
            services.AddSingleton<IConnectionMultiplexer>(sp =>
                ConnectionMultiplexer.Connect(redisConnection));
        }

        // Identity Configuration
        services.AddIdentity<ApplicationUser, IdentityRole>(options =>
        {
            // Password settings from configuration
            var passwordPolicy = configuration.GetSection("Security:PasswordPolicy").Get<PasswordPolicySettings>();
            options.Password.RequiredLength = passwordPolicy?.RequiredLength ?? 8;
            options.Password.RequireDigit = passwordPolicy?.RequireDigit ?? true;
            options.Password.RequireLowercase = passwordPolicy?.RequireLowercase ?? true;
            options.Password.RequireUppercase = passwordPolicy?.RequireUppercase ?? true;
            options.Password.RequireNonAlphanumeric = passwordPolicy?.RequireNonAlphanumeric ?? false;

            // Lockout settings from configuration
            var lockoutPolicy = configuration.GetSection("Security:LockoutPolicy").Get<LockoutPolicySettings>();
            options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(lockoutPolicy?.DefaultLockoutMinutes ?? 30);
            options.Lockout.MaxFailedAccessAttempts = lockoutPolicy?.MaxFailedAccessAttempts ?? 5;
            options.Lockout.AllowedForNewUsers = lockoutPolicy?.Enabled ?? true;

            // User settings
            options.User.RequireUniqueEmail = true;
            options.SignIn.RequireConfirmedEmail = true;
        })
        .AddEntityFrameworkStores<ApplicationDbContext>()
        .AddDefaultTokenProviders();

        // JWT Authentication
        var jwtSettings = configuration.GetSection("Jwt").Get<JwtSettings>();
        if (jwtSettings == null)
            throw new InvalidOperationException("JWT settings are not configured.");

        services.AddAuthentication(options =>
        {
            options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
            options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
        })
        .AddJwtBearer(options =>
        {
            options.TokenValidationParameters = new TokenValidationParameters
            {
                ValidateIssuer = true,
                ValidateAudience = true,
                ValidateLifetime = true,
                ValidateIssuerSigningKey = true,
                ValidIssuer = jwtSettings.Issuer,
                ValidAudience = jwtSettings.Audience,
                IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(jwtSettings.Key)),
                ClockSkew = TimeSpan.FromMinutes(jwtSettings.ClockSkewMinutes)
            };

            options.Events = new JwtBearerEvents
            {
                OnAuthenticationFailed = context =>
                {
                    if (context.Exception.GetType() == typeof(SecurityTokenExpiredException))
                    {
                        context.Response.Headers["Token-Expired"] = "true";
                    }
                    return Task.CompletedTask;
                }
            };
        });

        // Authorization Policies
        services.AddAuthorization(options =>
        {
            options.AddPolicy("RequireVerifiedEmail", policy =>
                policy.RequireClaim("email_verified", "true"));
        });

        // Health Checks
        services.AddHealthChecks(configuration);

        // Repositories
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IRefreshTokenRepository, RefreshTokenRepository>();
        services.AddScoped<IVerificationTokenRepository, VerificationTokenRepository>();

        // Services
        services.AddScoped<IPasswordHasher, PasswordHasher>();
        services.AddScoped<IJwtGenerator, JwtGenerator>();
        services.AddScoped<IEmailVerificationService, EmailVerificationService>();
        services.AddScoped<IPasswordResetTokenService, PasswordResetTokenService>();
        services.AddScoped<IAuthNotificationService, AuthNotificationService>();
        services.AddScoped<ITokenService, TokenService>();

        // Servicios 2FA
        services.AddScoped<ITwoFactorService, TwoFactorService>();
        services.AddScoped<IQRCodeService, QRCodeService>();

        // External Services
        services.AddHttpClient<NotificationServiceClient>();
        services.Configure<NotificationServiceSettings>(configuration.GetSection("NotificationService"));

        // External Authentication Services
        services.AddHttpClient<ExternalTokenValidator>();
        services.AddScoped<IExternalTokenValidator, ExternalTokenValidator>();
        services.AddScoped<IExternalAuthService, ExternalAuthService>();

        // Configuration
        services.Configure<JwtSettings>(configuration.GetSection("Jwt"));
        services.Configure<SecuritySettings>(configuration.GetSection("Security"));
        services.Configure<CacheSettings>(configuration.GetSection("Cache"));
        services.Configure<RateLimitSettings>(configuration.GetSection("Security:RateLimit"));

        // Caching
        var cacheSettings = configuration.GetSection("Cache").Get<CacheSettings>();
        if (cacheSettings?.EnableDistributedCache == true && !string.IsNullOrEmpty(redisConnection))
        {
            services.AddStackExchangeRedisCache(options =>
            {
                options.Configuration = redisConnection;
                options.InstanceName = "AuthService_";
            });
        }
        else
        {
            services.AddDistributedMemoryCache();
        }

        // MediatR
        services.AddMediatR(cfg =>
            cfg.RegisterServicesFromAssembly(typeof(ExternalAuthCommandHandler).Assembly));

        return services;
    }

    // NUEVO: Método para configurar Health Checks
    private static IServiceCollection AddHealthChecks(this IServiceCollection services, IConfiguration configuration)
    {
        var healthChecksBuilder = services.AddHealthChecks()
            .AddCheck<ApplicationHealthCheck>("application", HealthStatus.Unhealthy, new[] { "app" });

        // Redis Health Check
        var redisConnection = configuration.GetConnectionString("Redis");
        if (!string.IsNullOrEmpty(redisConnection))
        {
            healthChecksBuilder.AddCheck<RedisHealthCheck>("redis", HealthStatus.Unhealthy, new[] { "cache", "redis" });
        }

        // External Services Health Check
        var errorServiceUrl = configuration["ErrorService:BaseUrl"];
        var notificationServiceUrl = configuration["NotificationService:BaseUrl"];
        if (!string.IsNullOrEmpty(errorServiceUrl) || !string.IsNullOrEmpty(notificationServiceUrl))
        {
            services.AddHttpClient<ExternalServiceHealthCheck>();
            healthChecksBuilder.AddCheck<ExternalServiceHealthCheck>("external-services", HealthStatus.Degraded, new[] { "external" });
        }

        return services;
    }
}

---- File: AuthService.Infrastructure\External\NotificationServiceClient.cs ----
using System.Net.Http.Json;
using System.Text.Json;
using AuthService.Shared;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using ErrorService.Shared.Exceptions;

namespace AuthService.Infrastructure.External;

public class NotificationServiceClient
{
    private readonly HttpClient _httpClient;
    private readonly NotificationServiceSettings _settings;
    private readonly ILogger<NotificationServiceClient> _logger;
    private readonly JsonSerializerOptions _jsonOptions;

    public NotificationServiceClient(
        HttpClient httpClient,
        IOptions<NotificationServiceSettings> settings,
        ILogger<NotificationServiceClient> logger)
    {
        _httpClient = httpClient;
        _settings = settings.Value;
        _logger = logger;

        // Configurar HttpClient base
        _httpClient.BaseAddress = new Uri(_settings.BaseUrl);
        _httpClient.Timeout = TimeSpan.FromSeconds(_settings.TimeoutSeconds);
        _httpClient.DefaultRequestHeaders.Add("User-Agent", "AuthService");

        // Configurar opciones de JSON
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };
    }

    public async Task<bool> SendEmailAsync(string to, string subject, string body, bool isHtml = true, Dictionary<string, object>? metadata = null)
    {
        if (!_settings.EnableNotifications)
        {
            _logger.LogWarning("Notifications are disabled. Email to {To} was not sent.", to);
            return true; // Simular éxito si las notificaciones están deshabilitadas
        }

        try
        {
            // Usar el DTO exacto que espera el NotificationService
            var request = new
            {
                To = to,
                Subject = subject,
                Body = body,
                IsHtml = isHtml,
                Metadata = metadata ?? new Dictionary<string, object>()
            };

            var response = await _httpClient.PostAsJsonAsync("/api/notifications/email", request, _jsonOptions);

            if (response.IsSuccessStatusCode)
            {
                // Leer la respuesta para verificar que se procesó correctamente
                var responseContent = await response.Content.ReadAsStringAsync();
                var emailResponse = JsonSerializer.Deserialize<EmailNotificationResponse>(responseContent, _jsonOptions);

                if (emailResponse != null && emailResponse.Status?.ToLower() == "sent")
                {
                    _logger.LogInformation("Email sent successfully to {To}, NotificationId: {NotificationId}", to, emailResponse.NotificationId);
                    return true;
                }
                else
                {
                    _logger.LogWarning("Email to {To} was accepted but may not have been sent. Response: {Response}", to, responseContent);
                    return false;
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogWarning("Failed to send email to {To}. Status: {StatusCode}, Error: {Error}",
                    to, response.StatusCode, errorContent);
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending email to {To}", to);
            return false;
        }
    }

    public async Task<bool> SendSmsAsync(string to, string message, Dictionary<string, object>? metadata = null)
    {
        if (!_settings.EnableNotifications)
        {
            _logger.LogWarning("Notifications are disabled. SMS to {To} was not sent.", to);
            return true;
        }

        try
        {
            var request = new
            {
                To = to,
                Message = message,
                Metadata = metadata ?? new Dictionary<string, object>()
            };

            var response = await _httpClient.PostAsJsonAsync("/api/notifications/sms", request, _jsonOptions);

            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync();
                var smsResponse = JsonSerializer.Deserialize<SmsNotificationResponse>(responseContent, _jsonOptions);

                if (smsResponse != null && smsResponse.Status?.ToLower() == "sent")
                {
                    _logger.LogInformation("SMS sent successfully to {To}, NotificationId: {NotificationId}", to, smsResponse.NotificationId);
                    return true;
                }
                else
                {
                    _logger.LogWarning("SMS to {To} was accepted but may not have been sent. Response: {Response}", to, responseContent);
                    return false;
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogWarning("Failed to send SMS to {To}. Status: {StatusCode}, Error: {Error}",
                    to, response.StatusCode, errorContent);
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending SMS to {To}", to);
            return false;
        }
    }

    public async Task<bool> SendPushAsync(string deviceToken, string title, string body, object? data = null, Dictionary<string, object>? metadata = null)
    {
        if (!_settings.EnableNotifications)
        {
            _logger.LogWarning("Notifications are disabled. Push to {DeviceToken} was not sent.", deviceToken);
            return true;
        }

        try
        {
            var request = new
            {
                DeviceToken = deviceToken,
                Title = title,
                Body = body,
                Data = data,
                Metadata = metadata ?? new Dictionary<string, object>()
            };

            var response = await _httpClient.PostAsJsonAsync("/api/notifications/push", request, _jsonOptions);

            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync();
                var pushResponse = JsonSerializer.Deserialize<PushNotificationResponse>(responseContent, _jsonOptions);

                if (pushResponse != null && pushResponse.Status?.ToLower() == "sent")
                {
                    _logger.LogInformation("Push notification sent successfully to device {DeviceToken}, NotificationId: {NotificationId}", deviceToken, pushResponse.NotificationId);
                    return true;
                }
                else
                {
                    _logger.LogWarning("Push to {DeviceToken} was accepted but may not have been sent. Response: {Response}", deviceToken, responseContent);
                    return false;
                }
            }
            else
            {
                var errorContent = await response.Content.ReadAsStringAsync();
                _logger.LogWarning("Failed to send push notification to {DeviceToken}. Status: {StatusCode}, Error: {Error}",
                    deviceToken, response.StatusCode, errorContent);
                return false;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending push notification to {DeviceToken}", deviceToken);
            return false;
        }
    }

    public async Task<NotificationStatusResponse?> GetNotificationStatusAsync(Guid notificationId)
    {
        try
        {
            var response = await _httpClient.GetAsync($"/api/notifications/{notificationId}/status");

            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync();
                return JsonSerializer.Deserialize<NotificationStatusResponse>(responseContent, _jsonOptions);
            }
            else
            {
                _logger.LogWarning("Failed to get status for notification {NotificationId}. Status: {StatusCode}", notificationId, response.StatusCode);
                return null;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting status for notification {NotificationId}", notificationId);
            return null;
        }
    }

    public async Task<bool> IsHealthyAsync()
    {
        try
        {
            var response = await _httpClient.GetAsync("/health");
            return response.IsSuccessStatusCode;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Notification service health check failed");
            return false;
        }
    }


}

---- File: AuthService.Infrastructure\External\NotificationServiceResponses.cs ----
namespace AuthService.Infrastructure.External;

public class EmailNotificationResponse
{
    public Guid NotificationId { get; set; }
    public string? Status { get; set; }
    public string? Message { get; set; }
}

public class SmsNotificationResponse
{
    public Guid NotificationId { get; set; }
    public string? Status { get; set; }
    public string? Message { get; set; }
}

public class PushNotificationResponse
{
    public Guid NotificationId { get; set; }
    public string? Status { get; set; }
    public string? Message { get; set; }
}

public class NotificationStatusResponse
{
    public Guid NotificationId { get; set; }
    public string? Status { get; set; }
    public DateTime? SentAt { get; set; }
    public string? ErrorMessage { get; set; }
}

---- File: AuthService.Infrastructure\HealthChecks\ApplicationHealthCheck.cs ----
using Microsoft.Extensions.Diagnostics.HealthChecks;
public class ApplicationHealthCheck : IHealthCheck
{
    public Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            // Verificaciones básicas de la aplicación
            var isHealthy = true;
            var data = new Dictionary<string, object>
            {
                { "timestamp", DateTime.UtcNow },
                { "version", "1.0.0" }
            };

            if (isHealthy)
            {
                return Task.FromResult(HealthCheckResult.Healthy("Application is healthy", data));
            }
            else
            {
                return Task.FromResult(HealthCheckResult.Unhealthy("Application is unhealthy", data: data));
            }
        }
        catch (Exception ex)
        {
            return Task.FromResult(HealthCheckResult.Unhealthy("Application health check failed", ex));
        }
    }
}

---- File: AuthService.Infrastructure\HealthChecks\ExternalServiceHealthCheck.cs ----
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Diagnostics.HealthChecks;

namespace AuthService.Infrastructure.HealthChecks;

public class ExternalServiceHealthCheck : IHealthCheck
{
    private readonly HttpClient _httpClient;
    private readonly IConfiguration _configuration;

    public ExternalServiceHealthCheck(HttpClient httpClient, IConfiguration configuration)
    {
        _httpClient = httpClient;
        _configuration = configuration;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        var checks = new List<(string service, string url, bool isHealthy)>();

        try
        {
            // Check ErrorService
            var errorServiceUrl = _configuration["ErrorService:BaseUrl"];
            if (!string.IsNullOrEmpty(errorServiceUrl))
            {
                var isHealthy = await CheckServiceHealthAsync($"{errorServiceUrl}/health");
                checks.Add(("ErrorService", errorServiceUrl, isHealthy));
            }

            // Check NotificationService
            var notificationServiceUrl = _configuration["NotificationService:BaseUrl"];
            if (!string.IsNullOrEmpty(notificationServiceUrl))
            {
                var isHealthy = await CheckServiceHealthAsync($"{notificationServiceUrl}/health");
                checks.Add(("NotificationService", notificationServiceUrl, isHealthy));
            }

            var unhealthyServices = checks.Where(c => !c.isHealthy).ToList();
            if (unhealthyServices.Any())
            {
                return HealthCheckResult.Degraded(
                    $"Some external services are unhealthy: {string.Join(", ", unhealthyServices.Select(s => s.service))}",
                    data: new Dictionary<string, object>
                    {
                        { "services", checks }
                    });
            }

            return HealthCheckResult.Healthy("All external services are healthy",
                new Dictionary<string, object>
                {
                    { "services", checks }
                });
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("External services health check failed", ex);
        }
    }

    private async Task<bool> CheckServiceHealthAsync(string url)
    {
        try
        {
            var response = await _httpClient.GetAsync(url);
            return response.IsSuccessStatusCode;
        }
        catch
        {
            return false;
        }
    }
}

---- File: AuthService.Infrastructure\HealthChecks\HealthCheckSettings.cs ----
namespace AuthService.Infrastructure.HealthChecks;

public class HealthCheckSettings
{
    public bool Enabled { get; set; } = true;
    public int DatabaseTimeout { get; set; } = 30;
    public int RedisTimeout { get; set; } = 10;
    public int ExternalServicesTimeout { get; set; } = 30;
}

---- File: AuthService.Infrastructure\HealthChecks\RedisHealthCheck.cs ----
using Microsoft.Extensions.Diagnostics.HealthChecks;
using StackExchange.Redis;

namespace AuthService.Infrastructure.HealthChecks;

public class RedisHealthCheck : IHealthCheck
{
    private readonly IConnectionMultiplexer _redis;

    public RedisHealthCheck(IConnectionMultiplexer redis)
    {
        _redis = redis;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            var db = _redis.GetDatabase();
            var result = await db.PingAsync();

            if (result < TimeSpan.FromMilliseconds(100))
            {
                return HealthCheckResult.Healthy("Redis is healthy");
            }
            else
            {
                return HealthCheckResult.Degraded("Redis is slow");
            }
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy("Redis is unavailable", ex);
        }
    }
}

---- File: AuthService.Infrastructure\Middleware\ErrorHandlingMiddleware.cs ----
using AuthService.Shared.ErrorMessages;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using System.Text.Json;
using ErrorService.Shared.Exceptions;
using AuthService.Infrastructure.Services.Messaging;

namespace AuthService.Infrastructure.Middleware;

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;
    private readonly IErrorEventProducer _errorEventProducer;

    public ErrorHandlingMiddleware(
        RequestDelegate next,
        ILogger<ErrorHandlingMiddleware> logger,
        IErrorEventProducer errorEventProducer)
    {
        _next = next;
        _logger = logger;
        _errorEventProducer = errorEventProducer;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var errorCode = GetErrorCode(exception);
        var statusCode = GetStatusCode(exception);

        // Extraer información del contexto
        var userId = context.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier)?.Value;
        var endpoint = context.Request.Path;
        var httpMethod = context.Request.Method;

        // Crear evento de error
        var errorEvent = new RabbitMQErrorEvent
        {
            ErrorCode = errorCode,
            ErrorMessage = exception.Message,
            StackTrace = exception.StackTrace,
            UserId = userId,
            Endpoint = endpoint.ToString(),
            HttpMethod = httpMethod,
            StatusCode = statusCode,
            Metadata = new Dictionary<string, object>
            {
                ["RequestId"] = context.TraceIdentifier,
                ["UserAgent"] = context.Request.Headers.UserAgent.ToString(),
                ["ClientIp"] = context.Connection.RemoteIpAddress?.ToString() ?? "unknown",
                ["ExceptionType"] = exception.GetType().Name
            }
        };

        // Publicar error asíncronamente (no esperar)
        _ = _errorEventProducer.PublishErrorAsync(errorEvent);

        // Log local
        _logger.LogError(exception, "Error occurred: {ErrorCode} at {Endpoint}", errorCode, endpoint);

        // Responder al cliente
        context.Response.StatusCode = statusCode;
        context.Response.ContentType = "application/json";

        var response = new
        {
            success = false,
            error = exception is AppException ? exception.Message : "An error occurred",
            errorCode = errorCode,
            traceId = context.TraceIdentifier
        };

        await context.Response.WriteAsJsonAsync(response);
    }

    private static string GetErrorCode(Exception exception)
    {
        return exception switch
        {
            AppException appEx => appEx.GetType().Name.Replace("Exception", ""),
            _ => "INTERNAL_ERROR"
        };
    }

    private static int GetStatusCode(Exception exception)
    {
        return exception switch
        {
            UnauthorizedException => StatusCodes.Status401Unauthorized,
            ForbiddenException => StatusCodes.Status403Forbidden,
            NotFoundException => StatusCodes.Status404NotFound,
            BadRequestException => StatusCodes.Status400BadRequest,
            ConflictException => StatusCodes.Status409Conflict,
            ValidationException => StatusCodes.Status422UnprocessableEntity,
            _ => StatusCodes.Status500InternalServerError
        };
    }
}

---- File: AuthService.Infrastructure\Migrations\20250618160312_InitAuthService.cs ----
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace AuthService.Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class InitAuthService : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Users",
                columns: table => new
                {
                    Id = table.Column<string>(type: "text", nullable: false),
                    UserName = table.Column<string>(type: "text", nullable: true),
                    NormalizedUserName = table.Column<string>(type: "text", nullable: true),
                    Email = table.Column<string>(type: "text", nullable: true),
                    NormalizedEmail = table.Column<string>(type: "text", nullable: true),
                    EmailConfirmed = table.Column<bool>(type: "boolean", nullable: false),
                    PasswordHash = table.Column<string>(type: "text", nullable: true),
                    SecurityStamp = table.Column<string>(type: "text", nullable: true),
                    ConcurrencyStamp = table.Column<string>(type: "text", nullable: true),
                    PhoneNumber = table.Column<string>(type: "text", nullable: true),
                    PhoneNumberConfirmed = table.Column<bool>(type: "boolean", nullable: false),
                    TwoFactorEnabled = table.Column<bool>(type: "boolean", nullable: false),
                    LockoutEnd = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: true),
                    LockoutEnabled = table.Column<bool>(type: "boolean", nullable: false),
                    AccessFailedCount = table.Column<int>(type: "integer", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Users", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "RefreshTokens",
                columns: table => new
                {
                    Token = table.Column<string>(type: "text", nullable: false),
                    UserId = table.Column<string>(type: "text", nullable: false),
                    ExpiresAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    IsRevoked = table.Column<bool>(type: "boolean", nullable: false),
                    RevokedReason = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_RefreshTokens", x => x.Token);
                    table.ForeignKey(
                        name: "FK_RefreshTokens_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "VerificationTokens",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Token = table.Column<string>(type: "text", nullable: false),
                    UserId = table.Column<string>(type: "text", nullable: false),
                    Type = table.Column<int>(type: "integer", nullable: false),
                    ExpiresAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    Used = table.Column<bool>(type: "boolean", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_VerificationTokens", x => x.Id);
                    table.ForeignKey(
                        name: "FK_VerificationTokens_Users_UserId",
                        column: x => x.UserId,
                        principalTable: "Users",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_RefreshTokens_UserId",
                table: "RefreshTokens",
                column: "UserId");

            migrationBuilder.CreateIndex(
                name: "IX_Users_Email",
                table: "Users",
                column: "Email",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_VerificationTokens_Token",
                table: "VerificationTokens",
                column: "Token",
                unique: true);

            migrationBuilder.CreateIndex(
                name: "IX_VerificationTokens_UserId",
                table: "VerificationTokens",
                column: "UserId");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "RefreshTokens");

            migrationBuilder.DropTable(
                name: "VerificationTokens");

            migrationBuilder.DropTable(
                name: "Users");
        }
    }
}

---- File: AuthService.Infrastructure\Migrations\20250618160312_InitAuthService.Designer.cs ----
// <auto-generated />
using System;
using AuthService.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace AuthService.Infrastructure.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20250618160312_InitAuthService")]
    partial class InitAuthService
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("AuthService.Domain.Entities.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("text");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("integer");

                    b.Property<string>("ConcurrencyStamp")
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .HasColumnType("text");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("boolean");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("NormalizedEmail")
                        .HasColumnType("text");

                    b.Property<string>("NormalizedUserName")
                        .HasColumnType("text");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("text");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("boolean");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("text");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("boolean");

                    b.Property<string>("UserName")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("AuthService.Domain.Entities.RefreshToken", b =>
                {
                    b.Property<string>("Token")
                        .HasColumnType("text");

                    b.Property<DateTime>("ExpiresAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsRevoked")
                        .HasColumnType("boolean");

                    b.Property<string>("RevokedReason")
                        .HasColumnType("text");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Token");

                    b.HasIndex("UserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("AuthService.Domain.Entities.VerificationToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime>("ExpiresAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("Type")
                        .HasColumnType("integer");

                    b.Property<bool>("Used")
                        .HasColumnType("boolean");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Token")
                        .IsUnique();

                    b.HasIndex("UserId");

                    b.ToTable("VerificationTokens");
                });

            modelBuilder.Entity("AuthService.Domain.Entities.RefreshToken", b =>
                {
                    b.HasOne("AuthService.Domain.Entities.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("AuthService.Domain.Entities.VerificationToken", b =>
                {
                    b.HasOne("AuthService.Domain.Entities.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });
#pragma warning restore 612, 618
        }
    }
}

---- File: AuthService.Infrastructure\Migrations\ApplicationDbContextModelSnapshot.cs ----
// <auto-generated />
using System;
using AuthService.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace AuthService.Infrastructure.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    partial class ApplicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("AuthService.Domain.Entities.ApplicationUser", b =>
                {
                    b.Property<string>("Id")
                        .HasColumnType("text");

                    b.Property<int>("AccessFailedCount")
                        .HasColumnType("integer");

                    b.Property<string>("ConcurrencyStamp")
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .HasColumnType("text");

                    b.Property<bool>("EmailConfirmed")
                        .HasColumnType("boolean");

                    b.Property<bool>("LockoutEnabled")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("LockoutEnd")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("NormalizedEmail")
                        .HasColumnType("text");

                    b.Property<string>("NormalizedUserName")
                        .HasColumnType("text");

                    b.Property<string>("PasswordHash")
                        .HasColumnType("text");

                    b.Property<string>("PhoneNumber")
                        .HasColumnType("text");

                    b.Property<bool>("PhoneNumberConfirmed")
                        .HasColumnType("boolean");

                    b.Property<string>("SecurityStamp")
                        .HasColumnType("text");

                    b.Property<bool>("TwoFactorEnabled")
                        .HasColumnType("boolean");

                    b.Property<string>("UserName")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Email")
                        .IsUnique();

                    b.ToTable("Users");
                });

            modelBuilder.Entity("AuthService.Domain.Entities.RefreshToken", b =>
                {
                    b.Property<string>("Token")
                        .HasColumnType("text");

                    b.Property<DateTime>("ExpiresAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsRevoked")
                        .HasColumnType("boolean");

                    b.Property<string>("RevokedReason")
                        .HasColumnType("text");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Token");

                    b.HasIndex("UserId");

                    b.ToTable("RefreshTokens");
                });

            modelBuilder.Entity("AuthService.Domain.Entities.VerificationToken", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTime>("ExpiresAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Token")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("Type")
                        .HasColumnType("integer");

                    b.Property<bool>("Used")
                        .HasColumnType("boolean");

                    b.Property<string>("UserId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Token")
                        .IsUnique();

                    b.HasIndex("UserId");

                    b.ToTable("VerificationTokens");
                });

            modelBuilder.Entity("AuthService.Domain.Entities.RefreshToken", b =>
                {
                    b.HasOne("AuthService.Domain.Entities.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });

            modelBuilder.Entity("AuthService.Domain.Entities.VerificationToken", b =>
                {
                    b.HasOne("AuthService.Domain.Entities.ApplicationUser", null)
                        .WithMany()
                        .HasForeignKey("UserId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();
                });
#pragma warning restore 612, 618
        }
    }
}

---- File: AuthService.Infrastructure\Persistence\ApplicationDbContext.cs ----
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using AuthService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using AuthService.Infrastructure.Persistence.EntityConfigurations;

namespace AuthService.Infrastructure.Persistence;

public class ApplicationDbContext : IdentityDbContext<ApplicationUser, IdentityRole, string>
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }

    public DbSet<RefreshToken> RefreshTokens { get; set; } = null!;
    public DbSet<VerificationToken> VerificationTokens { get; set; } = null!;
    public DbSet<TwoFactorAuth> TwoFactorAuths { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder builder)
    {
        base.OnModelCreating(builder);

        builder.ApplyConfiguration(new ApplicationUserConfiguration());
        builder.ApplyConfiguration(new RefreshTokenConfiguration());
        builder.ApplyConfiguration(new VerificationTokenConfiguration());
        builder.ApplyConfiguration(new TwoFactorAuthConfiguration());
    }

    public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        UpdateTimestamps();
        return await base.SaveChangesAsync(cancellationToken);
    }

    private void UpdateTimestamps()
    {
        var entries = ChangeTracker.Entries()
            .Where(e => e.Entity is ApplicationUser && (e.State == EntityState.Added || e.State == EntityState.Modified));

        foreach (var entityEntry in entries)
        {
            var user = (ApplicationUser)entityEntry.Entity;
            user.MarkAsUpdated();
        }
    }
}

---- File: AuthService.Infrastructure\Persistence\EntityConfigurations\ApplicationUserConfiguration.cs ----
using AuthService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace AuthService.Infrastructure.Persistence.EntityConfigurations;

public class ApplicationUserConfiguration : IEntityTypeConfiguration<ApplicationUser>
{
    public void Configure(EntityTypeBuilder<ApplicationUser> builder)
    {
        builder.ToTable("Users");

        // Configurar propiedades
        builder.Property(u => u.Id).IsRequired().HasMaxLength(450);
        builder.Property(u => u.UserName).IsRequired().HasMaxLength(256);
        builder.Property(u => u.NormalizedUserName).HasMaxLength(256);
        builder.Property(u => u.Email).IsRequired().HasMaxLength(256);
        builder.Property(u => u.NormalizedEmail).HasMaxLength(256);
        builder.Property(u => u.PasswordHash).IsRequired().HasMaxLength(1024);
        builder.Property(u => u.SecurityStamp).HasMaxLength(1024);
        builder.Property(u => u.ConcurrencyStamp).HasMaxLength(1024);
        builder.Property(u => u.PhoneNumber).HasMaxLength(20);
        builder.Property(u => u.CreatedAt).IsRequired();
        builder.Property(u => u.UpdatedAt);
        builder.Property(u => u.AccessFailedCount).HasDefaultValue(0);
        builder.Property(u => u.LockoutEnabled).HasDefaultValue(true);

        // Configurar relaciones
        builder.HasMany(u => u.RefreshTokens)
            .WithOne(rt => rt.User)
            .HasForeignKey(rt => rt.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        builder.HasMany(u => u.VerificationTokens)
            .WithOne()
            .HasForeignKey(vt => vt.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        // Relación 1:1 con TwoFactorAuth
        builder.HasOne(u => u.TwoFactorAuth)
            .WithOne(t => t.User)
            .HasForeignKey<TwoFactorAuth>(t => t.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        // Índices
        builder.HasIndex(u => u.NormalizedEmail).HasDatabaseName("EmailIndex");
        builder.HasIndex(u => u.NormalizedUserName).IsUnique().HasDatabaseName("UserNameIndex");
        builder.HasIndex(u => u.Email).IsUnique();
        builder.HasIndex(u => u.CreatedAt);
    }
}

---- File: AuthService.Infrastructure\Persistence\EntityConfigurations\RefreshTokenConfiguration.cs ----
using AuthService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace AuthService.Infrastructure.Persistence.EntityConfigurations;

public class RefreshTokenConfiguration : IEntityTypeConfiguration<RefreshToken>
{
    public void Configure(EntityTypeBuilder<RefreshToken> builder)
    {
        builder.ToTable("RefreshTokens");

        builder.HasKey(rt => rt.Id);

        builder.Property(rt => rt.Id)
            .IsRequired()
            .HasMaxLength(450);

        builder.Property(rt => rt.Token)
            .IsRequired()
            .HasMaxLength(500);

        builder.Property(rt => rt.UserId)
            .IsRequired()
            .HasMaxLength(450);

        builder.Property(rt => rt.ExpiresAt)
            .IsRequired();

        builder.Property(rt => rt.CreatedByIp)
            .IsRequired()
            .HasMaxLength(45); // IPv6 max length

        builder.Property(rt => rt.RevokedByIp)
            .HasMaxLength(45);

        builder.Property(rt => rt.RevokedReason)
            .HasMaxLength(100);

        builder.Property(rt => rt.ReplacedByToken)
            .HasMaxLength(500);

        builder.Property(rt => rt.CreatedAt)
            .IsRequired();

        builder.Property(rt => rt.UpdatedAt);

        // Relación con User
        builder.HasOne(rt => rt.User)
            .WithMany(u => u.RefreshTokens)
            .HasForeignKey(rt => rt.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        // Índices
        builder.HasIndex(rt => rt.Token)
            .IsUnique();

        builder.HasIndex(rt => rt.UserId);

        builder.HasIndex(rt => rt.ExpiresAt);

        builder.HasIndex(rt => new { rt.UserId, rt.ExpiresAt });

        // Configurar propiedades computadas si es necesario
        builder.Ignore(rt => rt.IsExpired);
        builder.Ignore(rt => rt.IsRevoked);
        builder.Ignore(rt => rt.IsActive);
    }
}

---- File: AuthService.Infrastructure\Persistence\EntityConfigurations\TwoFactorAuthConfiguration.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using System.Text.Json;

namespace AuthService.Infrastructure.Persistence.EntityConfigurations;

public class TwoFactorAuthConfiguration : IEntityTypeConfiguration<TwoFactorAuth>
{
    public void Configure(EntityTypeBuilder<TwoFactorAuth> builder)
    {
        builder.ToTable("TwoFactorAuths");
        builder.HasKey(t => t.Id);

        // Relación 1:1 con ApplicationUser
        builder.HasOne(t => t.User)
            .WithOne(u => u.TwoFactorAuth)
            .HasForeignKey<TwoFactorAuth>(t => t.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        // Configurar propiedades
        builder.Property(t => t.Secret).IsRequired().HasMaxLength(255);
        builder.Property(t => t.PhoneNumber).HasMaxLength(20);
        builder.Property(t => t.Status).IsRequired().HasConversion<string>().HasMaxLength(50);
        builder.Property(t => t.PrimaryMethod).IsRequired().HasConversion<string>().HasMaxLength(50);

        // Configurar listas como JSON
        builder.Property(t => t.RecoveryCodes)
            .HasConversion(
                v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
                v => JsonSerializer.Deserialize<List<string>>(v, (JsonSerializerOptions?)null) ?? new List<string>()
            ).HasColumnType("text");

        builder.Property(t => t.EnabledMethods)
            .HasConversion(
                v => JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
                v => JsonSerializer.Deserialize<List<TwoFactorAuthType>>(v, (JsonSerializerOptions?)null) ?? new List<TwoFactorAuthType>()
            ).HasColumnType("text");

        builder.Property(t => t.EnabledAt).IsRequired(false);
        builder.Property(t => t.LastUsedAt).IsRequired(false);
        builder.Property(t => t.CreatedAt).IsRequired();
        builder.Property(t => t.UpdatedAt).IsRequired(false);
        builder.Property(t => t.FailedAttempts).HasDefaultValue(0);

        // Índices
        builder.HasIndex(t => t.UserId).IsUnique();
        builder.HasIndex(t => t.Status);
        builder.HasIndex(t => t.PrimaryMethod);
    }
}

---- File: AuthService.Infrastructure\Persistence\EntityConfigurations\VerificationTokenConfiguration.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using System.Text.Json;

namespace AuthService.Infrastructure.Persistence.EntityConfigurations;

public class VerificationTokenConfiguration : IEntityTypeConfiguration<VerificationToken>
{
    public void Configure(EntityTypeBuilder<VerificationToken> builder)
    {
        builder.ToTable("VerificationTokens");

        builder.HasKey(vt => vt.Id);

        builder.Property(vt => vt.Id)
            .ValueGeneratedOnAdd();

        builder.Property(vt => vt.Token)
            .IsRequired()
            .HasMaxLength(500);

        builder.Property(vt => vt.Email)
            .IsRequired()
            .HasMaxLength(256);

        builder.Property(vt => vt.Type)
            .IsRequired()
            .HasConversion<string>()
            .HasMaxLength(50);

        builder.Property(vt => vt.ExpiresAt)
            .IsRequired();

        builder.Property(vt => vt.CreatedAt)
            .IsRequired();

        builder.Property(vt => vt.UsedAt);

        builder.Property(vt => vt.IsUsed)
            .HasDefaultValue(false);

        builder.Property(vt => vt.UserId)
            .IsRequired()
            .HasMaxLength(450);

        // Relación con User
        builder.HasOne<ApplicationUser>()
            .WithMany(u => u.VerificationTokens)
            .HasForeignKey(vt => vt.UserId)
            .OnDelete(DeleteBehavior.Cascade);

        // Índices
        builder.HasIndex(vt => vt.Token)
            .IsUnique();

        builder.HasIndex(vt => vt.Email);

        builder.HasIndex(vt => vt.Type);

        builder.HasIndex(vt => vt.ExpiresAt);

        builder.HasIndex(vt => vt.CreatedAt);

        builder.HasIndex(vt => new { vt.Email, vt.Type, vt.IsUsed });

        // Ignorar propiedades computadas
        builder.Ignore(vt => vt.IsValid());
    }
}

---- File: AuthService.Infrastructure\Persistence\Repositories\RefreshTokenRepository.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using Microsoft.EntityFrameworkCore;

namespace AuthService.Infrastructure.Persistence.Repositories;

public class RefreshTokenRepository : IRefreshTokenRepository
{
    private readonly ApplicationDbContext _context;

    public RefreshTokenRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<RefreshToken?> GetByTokenAsync(string token, CancellationToken cancellationToken = default)
    {
        return await _context.RefreshTokens
            .Include(rt => rt.User)
            .FirstOrDefaultAsync(rt => rt.Token == token, cancellationToken);
    }

    public async Task<IEnumerable<RefreshToken>> GetByUserIdAsync(string userId, CancellationToken cancellationToken = default)
    {
        return await _context.RefreshTokens
            .Where(rt => rt.UserId == userId && !rt.IsRevoked && !rt.IsExpired)
            .OrderByDescending(rt => rt.CreatedAt)
            .ToListAsync(cancellationToken);
    }

    public async Task AddAsync(RefreshToken refreshToken, CancellationToken cancellationToken = default)
    {
        await _context.RefreshTokens.AddAsync(refreshToken, cancellationToken);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task UpdateAsync(RefreshToken refreshToken, CancellationToken cancellationToken = default)
    {
        _context.RefreshTokens.Update(refreshToken);
        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task RevokeAllForUserAsync(string userId, string reason, CancellationToken cancellationToken = default)
    {
        var activeTokens = await _context.RefreshTokens
            .Where(rt => rt.UserId == userId && !rt.IsRevoked)
            .ToListAsync(cancellationToken);

        foreach (var token in activeTokens)
        {
            token.Revoke("system", reason);
        }

        await _context.SaveChangesAsync(cancellationToken);
    }

    public async Task CleanupExpiredTokensAsync(CancellationToken cancellationToken = default)
    {
        var expiredTokens = await _context.RefreshTokens
            .Where(rt => rt.IsExpired || rt.IsRevoked)
            .ToListAsync(cancellationToken);

        _context.RefreshTokens.RemoveRange(expiredTokens);
        await _context.SaveChangesAsync(cancellationToken);
    }
}

---- File: AuthService.Infrastructure\Persistence\Repositories\UserRepository.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Exceptions;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using ErrorService.Shared.Exceptions;
using AuthService.Domain.Enums;


namespace AuthService.Infrastructure.Persistence.Repositories;

public class UserRepository : IUserRepository
{
    private readonly UserManager<ApplicationUser> _userManager;
    private readonly ApplicationDbContext _context;

    public UserRepository(
        UserManager<ApplicationUser> userManager,
        ApplicationDbContext context)
    {
        _userManager = userManager;
        _context = context;
    }

    public async Task<ApplicationUser?> GetByIdAsync(string id, CancellationToken cancellationToken = default)
    {
        return await _userManager.FindByIdAsync(id);
    }

    public async Task<ApplicationUser?> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
    {
        return await _userManager.FindByEmailAsync(email);
    }

    public async Task<ApplicationUser?> GetByNormalizedEmailAsync(string normalizedEmail, CancellationToken cancellationToken = default)
    {
        return await _userManager.Users
            .FirstOrDefaultAsync(u => u.NormalizedEmail == normalizedEmail, cancellationToken);
    }

    public async Task<bool> ExistsAsync(string email, CancellationToken cancellationToken = default)
    {
        return await _userManager.Users
            .AnyAsync(u => u.Email == email, cancellationToken);
    }

    public async Task AddAsync(ApplicationUser user, CancellationToken cancellationToken = default)
    {
        var result = await _userManager.CreateAsync(user);
        if (!result.Succeeded)
        {
            throw new DomainException($"Failed to create user: {string.Join(", ", result.Errors.Select(e => e.Description))}");
        }
    }

    public async Task UpdateAsync(ApplicationUser user, CancellationToken cancellationToken = default)
    {
        var result = await _userManager.UpdateAsync(user);
        if (!result.Succeeded)
        {
            throw new DomainException($"Failed to update user: {string.Join(", ", result.Errors.Select(e => e.Description))}");
        }
    }

    public async Task DeleteAsync(ApplicationUser user, CancellationToken cancellationToken = default)
    {
        var result = await _userManager.DeleteAsync(user);
        if (!result.Succeeded)
        {
            throw new DomainException($"Failed to delete user: {string.Join(", ", result.Errors.Select(e => e.Description))}");
        }
    }

    public async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        return await _context.SaveChangesAsync(cancellationToken);
    }

    // Métodos adicionales específicos de Identity
    public async Task<bool> CheckPasswordAsync(ApplicationUser user, string password)
    {
        return await _userManager.CheckPasswordAsync(user, password);
    }

    public async Task<IdentityResult> ChangePasswordAsync(ApplicationUser user, string currentPassword, string newPassword)
    {
        return await _userManager.ChangePasswordAsync(user, currentPassword, newPassword);
    }

    public async Task<string> GeneratePasswordResetTokenAsync(ApplicationUser user)
    {
        return await _userManager.GeneratePasswordResetTokenAsync(user);
    }

    public async Task<IdentityResult> ResetPasswordAsync(ApplicationUser user, string token, string newPassword)
    {
        return await _userManager.ResetPasswordAsync(user, token, newPassword);
    }

    public async Task<string> GenerateEmailConfirmationTokenAsync(ApplicationUser user)
    {
        return await _userManager.GenerateEmailConfirmationTokenAsync(user);
    }

    public async Task<IdentityResult> ConfirmEmailAsync(ApplicationUser user, string token)
    {
        return await _userManager.ConfirmEmailAsync(user, token);
    }

    public async Task<IdentityResult> SetLockoutEnabledAsync(ApplicationUser user, bool enabled)
    {
        return await _userManager.SetLockoutEnabledAsync(user, enabled);
    }

    public async Task<IdentityResult> ResetAccessFailedCountAsync(ApplicationUser user)
    {
        return await _userManager.ResetAccessFailedCountAsync(user);
    }

    public async Task<IdentityResult> AccessFailedAsync(ApplicationUser user)
    {
        return await _userManager.AccessFailedAsync(user);
    }


    public async Task<TwoFactorAuth?> GetTwoFactorAuthAsync(string userId)
    {
        return await _context.TwoFactorAuths
            .FirstOrDefaultAsync(tfa => tfa.UserId == userId);
    }

    public async Task AddOrUpdateTwoFactorAuthAsync(TwoFactorAuth twoFactorAuth)
    {
        var existing = await _context.TwoFactorAuths
            .FirstOrDefaultAsync(tfa => tfa.UserId == twoFactorAuth.UserId);

        if (existing != null)
        {
            // Actualizar existente
            _context.Entry(existing).CurrentValues.SetValues(twoFactorAuth);
            existing.GetType().GetProperty("UpdatedAt")?.SetValue(existing, DateTime.UtcNow);
            _context.TwoFactorAuths.Update(existing);
        }
        else
        {
            // Agregar nuevo
            await _context.TwoFactorAuths.AddAsync(twoFactorAuth);
        }

        await _context.SaveChangesAsync();
    }

    public async Task RemoveTwoFactorAuthAsync(string userId)
    {
        var twoFactorAuth = await GetTwoFactorAuthAsync(userId);
        if (twoFactorAuth != null)
        {
            _context.TwoFactorAuths.Remove(twoFactorAuth);
            await _context.SaveChangesAsync();
        }
    }

    public async Task<ApplicationUser?> GetByExternalIdAsync(ExternalAuthProvider provider, string externalUserId)
    {
        return await _userManager.Users
            .FirstOrDefaultAsync(u => u.ExternalAuthProvider == provider && u.ExternalUserId == externalUserId);
    }

    public async Task<List<ApplicationUser>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        return await _userManager.Users.ToListAsync(cancellationToken);
    }

}

---- File: AuthService.Infrastructure\Persistence\Repositories\VerificationTokenRepository.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Repositories;
using Microsoft.EntityFrameworkCore;

namespace AuthService.Infrastructure.Persistence.Repositories;

public class VerificationTokenRepository : IVerificationTokenRepository
{
    private readonly ApplicationDbContext _context;

    public VerificationTokenRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<VerificationToken?> GetByTokenAsync(string token)
    {
        return await _context.VerificationTokens
            .FirstOrDefaultAsync(vt => vt.Token == token);
    }

    public async Task<VerificationToken?> GetByTokenAndTypeAsync(string token, VerificationTokenType type)
    {
        return await _context.VerificationTokens
            .FirstOrDefaultAsync(vt => vt.Token == token && vt.Type == type);
    }

    public async Task<IEnumerable<VerificationToken>> GetByEmailAsync(string email)
    {
        return await _context.VerificationTokens
            .Where(vt => vt.Email == email)
            .OrderByDescending(vt => vt.CreatedAt)
            .ToListAsync();
    }

    public async Task<VerificationToken?> GetValidByEmailAndTypeAsync(string email, VerificationTokenType type)
    {
        return await _context.VerificationTokens
            .Where(vt => vt.Email == email &&
                        vt.Type == type &&
                        vt.IsValid() &&
                        !vt.IsUsed)
            .OrderByDescending(vt => vt.CreatedAt)
            .FirstOrDefaultAsync();
    }

    public async Task AddAsync(VerificationToken token)
    {
        await _context.VerificationTokens.AddAsync(token);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateAsync(VerificationToken token)
    {
        _context.VerificationTokens.Update(token);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteAsync(Guid id)
    {
        var token = await _context.VerificationTokens.FindAsync(id);
        if (token != null)
        {
            _context.VerificationTokens.Remove(token);
            await _context.SaveChangesAsync();
        }
    }

    public async Task DeleteExpiredTokensAsync()
    {
        var expiredTokens = await _context.VerificationTokens
            .Where(vt => vt.IsExpired())
            .ToListAsync();

        _context.VerificationTokens.RemoveRange(expiredTokens);
        await _context.SaveChangesAsync();
    }

    public async Task<bool> ExistsValidTokenAsync(string email, VerificationTokenType type)
    {
        return await _context.VerificationTokens
            .AnyAsync(vt => vt.Email == email &&
                           vt.Type == type &&
                           vt.IsValid() &&
                           !vt.IsUsed);
    }
}

---- File: AuthService.Infrastructure\Services\ExternalAuth\ExternalAuthService.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Services;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.ValueObjects;
using Microsoft.Extensions.Logging;
using ErrorService.Shared.Exceptions;
using System.Text.Json;

namespace AuthService.Infrastructure.Services.ExternalAuth;

public class ExternalAuthService : IExternalAuthService
{
    private readonly IExternalTokenValidator _tokenValidator;
    private readonly IUserRepository _userRepository;
    private readonly ILogger<ExternalAuthService> _logger;

    public ExternalAuthService(
        IExternalTokenValidator tokenValidator,
        IUserRepository userRepository,
        ILogger<ExternalAuthService> logger)
    {
        _tokenValidator = tokenValidator;
        _userRepository = userRepository;
        _logger = logger;
    }

    public async Task<(ApplicationUser user, bool isNewUser)> AuthenticateAsync(ExternalAuthProvider provider, string idToken)
    {
        try
        {
            // Validar token
            var validationResult = await ValidateTokenAndGetUserInfo(provider, idToken);
            if (!validationResult.isValid)
                throw new UnauthorizedException("Invalid external token");

            // Buscar usuario existente por external ID
            var existingUser = await FindUserByExternalIdAsync(provider, validationResult.userId);
            if (existingUser != null)
            {
                _logger.LogInformation("External user found for {Email} with provider {Provider}",
                    validationResult.email, provider);
                return (existingUser, false);
            }

            // Buscar usuario por email
            existingUser = await _userRepository.GetByEmailAsync(validationResult.email);
            if (existingUser != null)
            {
                // Vincular cuenta externa a usuario existente
                if (!existingUser.IsExternalUser)
                {
                    existingUser.LinkExternalAccount(provider, validationResult.userId);
                    await _userRepository.UpdateAsync(existingUser);
                    _logger.LogInformation("Linked external account to existing user {Email}", validationResult.email);
                }
                return (existingUser, false);
            }

            // Crear nuevo usuario
            var userName = GenerateUserName(validationResult.name, validationResult.email);
            var newUser = ApplicationUser.CreateExternalUser(
                userName,
                validationResult.email,
                provider,
                validationResult.userId
            );

            await _userRepository.AddAsync(newUser);
            _logger.LogInformation("Created new external user for {Email} with provider {Provider}",
                validationResult.email, provider);

            return (newUser, true);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during external authentication with provider {Provider}", provider);
            throw;
        }
    }

    public async Task<ApplicationUser?> FindUserByExternalIdAsync(ExternalAuthProvider provider, string externalUserId)
    {
        return await _userRepository.GetByExternalIdAsync(provider, externalUserId);
    }

    public async Task<bool> ValidateTokenAsync(ExternalAuthProvider provider, string idToken)
    {
        var result = await ValidateTokenAndGetUserInfo(provider, idToken);
        return result.isValid;
    }

    public async Task<string> GetUserInfoAsync(ExternalAuthProvider provider, string accessToken)
    {
        try
        {
            _logger.LogInformation("Getting user info for provider: {Provider}", provider);

            var userInfo = provider switch
            {
                ExternalAuthProvider.Google => await GetGoogleUserInfoAsync(accessToken),
                ExternalAuthProvider.Microsoft => await GetMicrosoftUserInfoAsync(accessToken),
                _ => throw new ArgumentOutOfRangeException(nameof(provider), $"Unsupported provider: {provider}")
            };

            return userInfo;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting user info for provider {Provider}", provider);
            throw new InvalidOperationException($"Failed to get user info from {provider}", ex);
        }
    }

    public async Task<ExternalUserInfo> GetUserInfoTypedAsync(ExternalAuthProvider provider, string accessToken)
    {
        var userInfoJson = await GetUserInfoAsync(provider, accessToken);

        return provider switch
        {
            ExternalAuthProvider.Google => ParseGoogleUserInfo(userInfoJson),
            ExternalAuthProvider.Microsoft => ParseMicrosoftUserInfo(userInfoJson),
            _ => throw new ArgumentOutOfRangeException(nameof(provider), $"Unsupported provider: {provider}")
        };
    }

    private async Task<(bool isValid, string email, string userId, string name)> ValidateTokenAndGetUserInfo(
        ExternalAuthProvider provider, string idToken)
    {
        return provider switch
        {
            ExternalAuthProvider.Google => await _tokenValidator.ValidateGoogleTokenAsync(idToken),
            ExternalAuthProvider.Microsoft => await _tokenValidator.ValidateMicrosoftTokenAsync(idToken),
            _ => throw new ArgumentOutOfRangeException(nameof(provider), $"Unsupported provider: {provider}")
        };
    }

    private async Task<string> GetGoogleUserInfoAsync(string accessToken)
    {
        using var httpClient = new HttpClient();
        httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", accessToken);

        var response = await httpClient.GetAsync("https://www.googleapis.com/oauth2/v3/userinfo");

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            throw new HttpRequestException($"Google API returned {response.StatusCode}: {errorContent}");
        }

        var content = await response.Content.ReadAsStringAsync();

        // Parse and enrich the response
        var userInfo = JsonSerializer.Deserialize<GoogleUserInfo>(content);
        var enrichedInfo = new
        {
            userInfo?.sub,
            userInfo?.name,
            userInfo?.given_name,
            userInfo?.family_name,
            userInfo?.picture,
            userInfo?.email,
            userInfo?.email_verified,
            userInfo?.locale,
            Provider = "Google",
            RetrievedAt = DateTime.UtcNow
        };

        return JsonSerializer.Serialize(enrichedInfo, new JsonSerializerOptions { WriteIndented = true });
    }

    private async Task<string> GetMicrosoftUserInfoAsync(string accessToken)
    {
        using var httpClient = new HttpClient();
        httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", accessToken);

        var response = await httpClient.GetAsync("https://graph.microsoft.com/v1.0/me");

        if (!response.IsSuccessStatusCode)
        {
            var errorContent = await response.Content.ReadAsStringAsync();
            throw new HttpRequestException($"Microsoft Graph API returned {response.StatusCode}: {errorContent}");
        }

        var content = await response.Content.ReadAsStringAsync();

        // Parse and enrich the response
        var userInfo = JsonSerializer.Deserialize<MicrosoftUserInfo>(content);
        var enrichedInfo = new
        {
            userInfo?.id,
            userInfo?.displayName,
            userInfo?.givenName,
            userInfo?.surname,
            userInfo?.mail,
            userInfo?.userPrincipalName,
            userInfo?.mobilePhone,
            userInfo?.jobTitle,
            userInfo?.officeLocation,
            Provider = "Microsoft",
            RetrievedAt = DateTime.UtcNow
        };

        return JsonSerializer.Serialize(enrichedInfo, new JsonSerializerOptions { WriteIndented = true });
    }

    private ExternalUserInfo ParseGoogleUserInfo(string userInfoJson)
    {
        var userInfo = JsonSerializer.Deserialize<GoogleUserInfo>(userInfoJson);

        if (userInfo == null)
            throw new InvalidOperationException("Failed to parse Google user info");

        var additionalData = new Dictionary<string, object>
        {
            ["email_verified"] = userInfo.email_verified,
            ["locale"] = userInfo.locale,
            ["picture"] = userInfo.picture
        };

        return new ExternalUserInfo(
            UserId: userInfo.sub,
            Email: userInfo.email,
            Name: userInfo.name,
            FirstName: userInfo.given_name,
            LastName: userInfo.family_name,
            PictureUrl: userInfo.picture,
            Provider: "Google",
            AdditionalData: additionalData
        );
    }

    private ExternalUserInfo ParseMicrosoftUserInfo(string userInfoJson)
    {
        var userInfo = JsonSerializer.Deserialize<MicrosoftUserInfo>(userInfoJson);

        if (userInfo == null)
            throw new InvalidOperationException("Failed to parse Microsoft user info");

        var additionalData = new Dictionary<string, object>();

        if (!string.IsNullOrEmpty(userInfo.mobilePhone))
            additionalData["mobile_phone"] = userInfo.mobilePhone;
        if (!string.IsNullOrEmpty(userInfo.jobTitle))
            additionalData["job_title"] = userInfo.jobTitle;
        if (!string.IsNullOrEmpty(userInfo.officeLocation))
            additionalData["office_location"] = userInfo.officeLocation;

        return new ExternalUserInfo(
            UserId: userInfo.id,
            Email: userInfo.mail ?? userInfo.userPrincipalName,
            Name: userInfo.displayName,
            FirstName: userInfo.givenName,
            LastName: userInfo.surname,
            PictureUrl: null,
            Provider: "Microsoft",
            AdditionalData: additionalData
        );
    }

    private string GenerateUserName(string? name, string email)
    {
        if (!string.IsNullOrWhiteSpace(name))
        {
            // Limpiar el nombre para usarlo como username
            var cleanName = new string(name.Where(c => char.IsLetterOrDigit(c) || c == '.' || c == '_').ToArray());
            if (!string.IsNullOrWhiteSpace(cleanName))
                return cleanName;
        }

        // Usar la parte del email antes del @ como username
        return email.Split('@')[0];
    }

    // Clases internas privadas para deserialización
    private class GoogleUserInfo
    {
        public string sub { get; set; } = string.Empty;
        public string name { get; set; } = string.Empty;
        public string given_name { get; set; } = string.Empty;
        public string family_name { get; set; } = string.Empty;
        public string picture { get; set; } = string.Empty;
        public string email { get; set; } = string.Empty;
        public bool email_verified { get; set; }
        public string locale { get; set; } = string.Empty;
    }

    private class MicrosoftUserInfo
    {
        public string id { get; set; } = string.Empty;
        public string displayName { get; set; } = string.Empty;
        public string givenName { get; set; } = string.Empty;
        public string surname { get; set; } = string.Empty;
        public string mail { get; set; } = string.Empty;
        public string userPrincipalName { get; set; } = string.Empty;
        public string mobilePhone { get; set; } = string.Empty;
        public string jobTitle { get; set; } = string.Empty;
        public string officeLocation { get; set; } = string.Empty;
    }
}

---- File: AuthService.Infrastructure\Services\ExternalAuth\ExternalTokenValidator.cs ----
using System.Text.Json;
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Services;
using Microsoft.Extensions.Logging;

namespace AuthService.Infrastructure.Services.ExternalAuth;

public class ExternalTokenValidator : IExternalTokenValidator
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<ExternalTokenValidator> _logger;

    public ExternalTokenValidator(HttpClient httpClient, ILogger<ExternalTokenValidator> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<(bool isValid, string email, string userId, string name)> ValidateGoogleTokenAsync(string idToken)
    {
        try
        {
            var response = await _httpClient.GetAsync($"https://oauth2.googleapis.com/tokeninfo?id_token={idToken}");

            if (!response.IsSuccessStatusCode)
                return (false, string.Empty, string.Empty, string.Empty);

            var content = await response.Content.ReadAsStringAsync();
            var tokenInfo = JsonSerializer.Deserialize<GoogleTokenInfo>(content);

            if (tokenInfo == null || string.IsNullOrEmpty(tokenInfo.email))
                return (false, string.Empty, string.Empty, string.Empty);

            return (true, tokenInfo.email, tokenInfo.sub, tokenInfo.name ?? string.Empty);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error validating Google token");
            return (false, string.Empty, string.Empty, string.Empty);
        }
    }

    public async Task<(bool isValid, string email, string userId, string name)> ValidateMicrosoftTokenAsync(string idToken)
    {
        try
        {
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Add("Authorization", $"Bearer {idToken}");

            var response = await _httpClient.GetAsync("https://graph.microsoft.com/v1.0/me");

            if (!response.IsSuccessStatusCode)
                return (false, string.Empty, string.Empty, string.Empty);

            var content = await response.Content.ReadAsStringAsync();
            var userInfo = JsonSerializer.Deserialize<MicrosoftUserInfo>(content);

            if (userInfo == null || string.IsNullOrEmpty(userInfo.mail))
                return (false, string.Empty, string.Empty, string.Empty);

            return (true, userInfo.mail, userInfo.id, userInfo.displayName ?? string.Empty);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error validating Microsoft token");
            return (false, string.Empty, string.Empty, string.Empty);
        }
    }

    private class GoogleTokenInfo
    {
        public string email { get; set; } = string.Empty;
        public string sub { get; set; } = string.Empty;
        public string name { get; set; } = string.Empty;
        public bool email_verified { get; set; }
    }

    private class MicrosoftUserInfo
    {
        public string id { get; set; } = string.Empty;
        public string mail { get; set; } = string.Empty;
        public string displayName { get; set; } = string.Empty;
        public string userPrincipalName { get; set; } = string.Empty;
    }
}

---- File: AuthService.Infrastructure\Services\Identity\EmailVerificationService.cs ----
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using AuthService.Domain.Enums;
using Microsoft.AspNetCore.Identity;
using ErrorService.Shared.Exceptions;

namespace AuthService.Infrastructure.Services.Identity;

public class EmailVerificationService : IEmailVerificationService
{
    private readonly IUserRepository _userRepository;
    private readonly IVerificationTokenRepository _verificationTokenRepository;
    private readonly UserManager<ApplicationUser> _userManager;

    public EmailVerificationService(
        IUserRepository userRepository,
        IVerificationTokenRepository verificationTokenRepository,
        UserManager<ApplicationUser> userManager)
    {
        _userRepository = userRepository;
        _verificationTokenRepository = verificationTokenRepository;
        _userManager = userManager;
    }

    public async Task SendVerificationEmailAsync(ApplicationUser user)
    {
        // Generar token usando Identity
        var token = await _userManager.GenerateEmailConfirmationTokenAsync(user);

        // Crear y guardar el token de verificación
        var verificationToken = new VerificationToken(
            user.Id,
            VerificationTokenType.EmailVerification,
            TimeSpan.FromHours(24))
        {
            Token = token,
            Email = user.Email ?? throw new InvalidOperationException("User email is null") // Manejo de null
        };

        await _verificationTokenRepository.AddAsync(verificationToken);
    }
    public async Task<bool> VerifyAsync(string token)
    {
        var verificationToken = await _verificationTokenRepository.GetByTokenAndTypeAsync(
            token, VerificationTokenType.EmailVerification);

        if (verificationToken == null || !verificationToken.IsValid())
            return false;

        var user = await _userRepository.GetByIdAsync(verificationToken.UserId);
        if (user == null)
            return false;

        // Verificar el token usando Identity
        var result = await _userManager.ConfirmEmailAsync(user, token);

        if (result.Succeeded)
        {
            // Marcar el token como usado
            verificationToken.MarkAsUsed();
            await _verificationTokenRepository.UpdateAsync(verificationToken);

            // Confirmar el email en la entidad de usuario
            user.ConfirmEmail();
            await _userRepository.UpdateAsync(user);

            return true;
        }

        return false;
    }
}

---- File: AuthService.Infrastructure\Services\Identity\JwtGenerator.cs ----
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using AuthService.Domain.Entities;
using AuthService.Domain.Interfaces.Services;
using AuthService.Shared;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;

namespace AuthService.Infrastructure.Services.Identity;

public class JwtGenerator : IJwtGenerator
{
    private readonly JwtSettings _jwtSettings;

    public JwtGenerator(IOptions<JwtSettings> jwtSettings)
    {
        _jwtSettings = jwtSettings.Value;
    }

    public string GenerateToken(ApplicationUser user)
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id),
            new Claim(ClaimTypes.Email, user.Email ?? ""),
            new Claim(ClaimTypes.Name, user.UserName ?? ""),
            new Claim("email_verified", user.EmailConfirmed.ToString().ToLower()),
            new Claim("security_stamp", user.SecurityStamp ?? ""),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.Key));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var token = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_jwtSettings.ExpiresMinutes),
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    public string GenerateRefreshToken()
    {
        return Guid.NewGuid().ToString("N") + Guid.NewGuid().ToString("N");
    }

    public (string userId, string email)? ValidateToken(string token)
    {
        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.Key));

            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = key,
                ValidateIssuer = true,
                ValidIssuer = _jwtSettings.Issuer,
                ValidateAudience = true,
                ValidAudience = _jwtSettings.Audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.FromMinutes(_jwtSettings.ClockSkewMinutes)
            };

            var principal = tokenHandler.ValidateToken(token, validationParameters, out _);

            var userId = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var email = principal.FindFirst(ClaimTypes.Email)?.Value;

            if (string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(email))
                return null;

            return (userId, email);
        }
        catch
        {
            return null;
        }
    }

    // NUEVO: Método para generar token temporal para 2FA
    public string GenerateTempToken(string userId)
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, userId),
            new Claim("temp_token", "true"),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };

        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.Key));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);

        var token = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(5), // Corta expiración para 2FA
            signingCredentials: credentials
        );

        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    // NUEVO: Método para validar token temporal para 2FA
    public (string userId, string email)? ValidateTempToken(string token)
    {
        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.Key));

            var validationParameters = new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = key,
                ValidateIssuer = true,
                ValidIssuer = _jwtSettings.Issuer,
                ValidateAudience = true,
                ValidAudience = _jwtSettings.Audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.FromMinutes(_jwtSettings.ClockSkewMinutes)
            };

            var principal = tokenHandler.ValidateToken(token, validationParameters, out _);

            var userId = principal.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            var isTemp = principal.FindFirst("temp_token")?.Value;

            if (string.IsNullOrEmpty(userId) || isTemp != "true")
                return null;

            return (userId, ""); // Email no es necesario para token temporal
        }
        catch
        {
            return null;
        }
    }
}

---- File: AuthService.Infrastructure\Services\Identity\PasswordHasher.cs ----
using AuthService.Domain.Interfaces.Services;
using Microsoft.AspNetCore.Identity;

namespace AuthService.Infrastructure.Services.Identity;

public class PasswordHasher : IPasswordHasher
{
    private readonly IPasswordHasher<object> _passwordHasher;

    public PasswordHasher(IPasswordHasher<object> passwordHasher)
    {
        _passwordHasher = passwordHasher;
    }

    public string Hash(string password)
    {
        if (string.IsNullOrWhiteSpace(password))
            throw new ArgumentException("Password cannot be null or empty", nameof(password));

        return _passwordHasher.HashPassword(null!, password);
    }

    public bool Verify(string providedPassword, string hashedPassword)
    {
        if (string.IsNullOrWhiteSpace(providedPassword))
            return false;

        if (string.IsNullOrWhiteSpace(hashedPassword))
            return false;

        var result = _passwordHasher.VerifyHashedPassword(null!, hashedPassword, providedPassword);
        return result == PasswordVerificationResult.Success ||
               result == PasswordVerificationResult.SuccessRehashNeeded;
    }
}

---- File: AuthService.Infrastructure\Services\Identity\PasswordResetTokenService.cs ----
using AuthService.Domain.Interfaces.Services;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Enums;
using AuthService.Domain.Entities;
using Microsoft.AspNetCore.Identity;
using ErrorService.Shared.Exceptions;

namespace AuthService.Infrastructure.Services.Identity;

public class PasswordResetTokenService : IPasswordResetTokenService
{
    private readonly IVerificationTokenRepository _verificationTokenRepository;
    private readonly IUserRepository _userRepository;
    private readonly UserManager<ApplicationUser> _userManager;

    public PasswordResetTokenService(
        IVerificationTokenRepository verificationTokenRepository,
        IUserRepository userRepository,
        UserManager<ApplicationUser> userManager)
    {
        _verificationTokenRepository = verificationTokenRepository;
        _userRepository = userRepository;
        _userManager = userManager;
    }

    public string GenerateResetToken(string email)
    {
        // Este método ahora solo genera el formato del token
        // La generación real del token se hará en el use case usando UserManager
        return Guid.NewGuid().ToString("N");
    }

    public bool ValidateResetToken(string token, out string email)
    {
        email = string.Empty; // Inicializa con string.Empty en lugar de null

        var verificationToken = _verificationTokenRepository.GetByTokenAndTypeAsync(
            token, VerificationTokenType.PasswordReset).Result;

        if (verificationToken == null || !verificationToken.IsValid())
            return false;

        email = verificationToken.Email;
        return true;
    }

    public async Task<bool> IsTokenValidAsync(string email, string token)
    {
        var verificationToken = await _verificationTokenRepository.GetByTokenAndTypeAsync(
            token, VerificationTokenType.PasswordReset);

        return verificationToken != null &&
               verificationToken.Email == email &&
               verificationToken.IsValid() &&
               !verificationToken.IsUsed;
    }

    public async Task InvalidateTokenAsync(string email)
    {
        var tokens = await _verificationTokenRepository.GetByEmailAsync(email);
        var resetTokens = tokens.Where(t =>
            t.Type == VerificationTokenType.PasswordReset &&
            t.IsValid() &&
            !t.IsUsed);

        foreach (var token in resetTokens)
        {
            token.MarkAsUsed();
            await _verificationTokenRepository.UpdateAsync(token);
        }
    }

    public async Task<string> GenerateIdentityResetTokenAsync(ApplicationUser user)
    {
        return await _userManager.GeneratePasswordResetTokenAsync(user);
    }

    public async Task<bool> ResetPasswordWithTokenAsync(ApplicationUser user, string token, string newPassword)
    {
        var result = await _userManager.ResetPasswordAsync(user, token, newPassword);
        return result.Succeeded;
    }
}

---- File: AuthService.Infrastructure\Services\Identity\QRCodeService.cs ----
using AuthService.Domain.Interfaces.Services;
using QRCoder;

namespace AuthService.Infrastructure.Services.Identity;

public class QRCodeService : IQRCodeService
{
    public string GenerateQRCode(string text, int size = 300)
    {
        using var qrGenerator = new QRCodeGenerator();
        using var qrCodeData = qrGenerator.CreateQrCode(text, QRCodeGenerator.ECCLevel.Q);
        using var qrCode = new PngByteQRCode(qrCodeData);
        var qrCodeImage = qrCode.GetGraphic(20);
        return Convert.ToBase64String(qrCodeImage);
    }
}

---- File: AuthService.Infrastructure\Services\Identity\TwoFactorService.cs ----
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Interfaces.Services;
using Microsoft.Extensions.Caching.Distributed;
using OtpNet;
using System.Text.Json;

namespace AuthService.Infrastructure.Services.Identity;

public class TwoFactorService : ITwoFactorService
{
    private readonly IQRCodeService _qrCodeService;
    private readonly IDistributedCache _cache;
    private readonly IAuthNotificationService _notificationService;
    private readonly IUserRepository _userRepository; // NECESARIO: Agregar esta dependencia

    public TwoFactorService(
        IQRCodeService qrCodeService,
        IDistributedCache cache,
        IAuthNotificationService notificationService,
        IUserRepository userRepository) // Agregar UserRepository
    {
        _qrCodeService = qrCodeService;
        _cache = cache;
        _notificationService = notificationService;
        _userRepository = userRepository; // Inicializar
    }

    public async Task<(string secret, string qrCodeUri)> GenerateAuthenticatorKeyAsync(string userId, string email)
    {
        var key = KeyGeneration.GenerateRandomKey(20);
        var base32Secret = Base32Encoding.ToString(key);

        var issuer = "YourApp";
        var qrCodeUri = $"otpauth://totp/{issuer}:{email}?secret={base32Secret}&issuer={issuer}&digits=6";
        var qrCodeImage = _qrCodeService.GenerateQRCode(qrCodeUri);

        await _cache.SetStringAsync($"2fa_setup_{userId}", base32Secret, new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(10)
        });

        return (base32Secret, qrCodeImage);
    }

    public bool VerifyAuthenticatorCode(string secret, string code)
    {
        var totp = new Totp(Base32Encoding.ToBytes(secret));
        return totp.VerifyTotp(code, out _);
    }

    public async Task<string> GenerateSmsCodeAsync(string userId)
    {
        var code = GenerateRandomCode(6);
        await _cache.SetStringAsync($"2fa_sms_{userId}", code, new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)
        });
        return code;
    }

    public async Task<string> GenerateEmailCodeAsync(string userId)
    {
        var code = GenerateRandomCode(6);
        await _cache.SetStringAsync($"2fa_email_{userId}", code, new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(5)
        });
        return code;
    }

    public async Task<bool> VerifyCodeAsync(string userId, string code, TwoFactorAuthType type)
    {
        var cacheKey = type switch
        {
            TwoFactorAuthType.Authenticator => $"2fa_setup_{userId}",
            TwoFactorAuthType.SMS => $"2fa_sms_{userId}",
            TwoFactorAuthType.Email => $"2fa_email_{userId}",
            _ => throw new ArgumentOutOfRangeException(nameof(type))
        };

        var storedCode = await _cache.GetStringAsync(cacheKey);
        if (storedCode == code)
        {
            await _cache.RemoveAsync(cacheKey);
            return true;
        }

        return false;
    }

    public async Task<List<string>> GenerateRecoveryCodesAsync(string userId)
    {
        var recoveryCodes = new List<string>();
        for (int i = 0; i < 10; i++)
            recoveryCodes.Add(GenerateRandomCode(8));

        await _cache.SetStringAsync($"recovery_codes_{userId}",
            JsonSerializer.Serialize(recoveryCodes),
            new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(7) });

        return recoveryCodes;
    }

    public async Task<bool> VerifyRecoveryCodeAsync(string userId, string code)
    {
        var storedCodesJson = await _cache.GetStringAsync($"recovery_codes_{userId}");
        if (storedCodesJson == null) return false;

        var storedCodes = JsonSerializer.Deserialize<List<string>>(storedCodesJson);
        if (storedCodes?.Contains(code) == true)
        {
            storedCodes.Remove(code);
            await _cache.SetStringAsync($"recovery_codes_{userId}",
                JsonSerializer.Serialize(storedCodes),
                new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(7) });
            return true;
        }

        return false;
    }

    public async Task<bool> IsTwoFactorEnabledAsync(string userId)
    {
        var enabled = await _cache.GetStringAsync($"2fa_enabled_{userId}");
        return enabled == "true";
    }

    // CORRECCIÓN: Este método ahora SI envía códigos realmente
    public async Task<bool> SendTwoFactorCodeAsync(string userId, TwoFactorAuthType type)
    {
        try
        {
            var user = await _userRepository.GetByIdAsync(userId);
            if (user == null) return false;

            string code;
            string destination;

            switch (type)
            {
                case TwoFactorAuthType.SMS:
                    if (string.IsNullOrEmpty(user.PhoneNumber))
                        return false;

                    code = await GenerateSmsCodeAsync(userId);
                    destination = user.PhoneNumber;
                    await _notificationService.SendTwoFactorCodeAsync(destination, code, TwoFactorAuthType.SMS);
                    break;

                case TwoFactorAuthType.Email:
                    code = await GenerateEmailCodeAsync(userId);
                    destination = user.Email!;
                    await _notificationService.SendTwoFactorCodeAsync(destination, code, TwoFactorAuthType.Email);
                    break;

                default:
                    return false;
            }

            return true;
        }
        catch (Exception)
        {
            // Log the exception
            return false;
        }
    }

    // NUEVO MÉTODO: Enviar código a un destino específico
    public async Task<bool> SendTwoFactorCodeToDestinationAsync(string userId, TwoFactorAuthType type, string destination)
    {
        try
        {
            string code;

            switch (type)
            {
                case TwoFactorAuthType.SMS:
                    code = await GenerateSmsCodeAsync(userId);
                    await _notificationService.SendTwoFactorCodeAsync(destination, code, TwoFactorAuthType.SMS);
                    break;

                case TwoFactorAuthType.Email:
                    code = await GenerateEmailCodeAsync(userId);
                    await _notificationService.SendTwoFactorCodeAsync(destination, code, TwoFactorAuthType.Email);
                    break;

                default:
                    return false;
            }

            return true;
        }
        catch (Exception)
        {
            // Log the exception
            return false;
        }
    }

    private string GenerateRandomCode(int length)
    {
        const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        var random = new Random();
        return new string(Enumerable.Repeat(chars, length)
            .Select(s => s[random.Next(s.Length)]).ToArray());
    }
}

---- File: AuthService.Infrastructure\Services\Messaging\ErrorServiceRabbitMQSettings.cs ----

namespace AuthService.Infrastructure.Services.Messaging;

public class ErrorServiceRabbitMQSettings
{
    public bool EnableRabbitMQ { get; set; } = true;
    public string QueueName { get; set; } = "error-queue";
    public string ExchangeName { get; set; } = "error-exchange";
    public string RoutingKey { get; set; } = "error.routing.key";
}

---- File: AuthService.Infrastructure\Services\Messaging\NotificationEventProducer.cs ----
// AuthService.Infrastructure/Services/Messaging/NotificationEventProducer.cs
using AuthService.Infrastructure.Services.Messaging;
using AuthService.Shared.NotificationMessages;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using System.Text.Json;
using System.Text;
using AuthService.Domain.Interfaces.Services;

namespace AuthService.Infrastructure.Services.Messaging;

public class RabbitMQNotificationProducer : INotificationEventProducer, IDisposable
{
    private readonly IConnection _connection;
    private readonly IModel _channel;
    private readonly NotificationServiceRabbitMQSettings _settings;
    private readonly ILogger<RabbitMQNotificationProducer> _logger;
    private readonly JsonSerializerOptions _jsonOptions;

    public RabbitMQNotificationProducer(
        IOptions<RabbitMQSettings> rabbitMqSettings,
        IOptions<NotificationServiceRabbitMQSettings> notificationSettings,
        ILogger<RabbitMQNotificationProducer> logger)
    {
        _settings = notificationSettings.Value;
        _logger = logger;

        var factory = new ConnectionFactory
        {
            HostName = rabbitMqSettings.Value.Host,
            Port = rabbitMqSettings.Value.Port,
            UserName = rabbitMqSettings.Value.Username,
            Password = rabbitMqSettings.Value.Password,
            VirtualHost = rabbitMqSettings.Value.VirtualHost,
            DispatchConsumersAsync = true
        };

        _connection = factory.CreateConnection();
        _channel = _connection.CreateModel();

        // Declarar exchange para notificaciones
        _channel.ExchangeDeclare(
            exchange: _settings.ExchangeName,
            type: ExchangeType.Direct,
            durable: true,
            autoDelete: false);

        // Declarar cola principal de notificaciones
        _channel.QueueDeclare(
            queue: _settings.QueueName,
            durable: true,
            exclusive: false,
            autoDelete: false,
            arguments: null);

        _channel.QueueBind(
            queue: _settings.QueueName,
            exchange: _settings.ExchangeName,
            routingKey: _settings.RoutingKey);

        // Cola de retry para fallos
        _channel.QueueDeclare(
            queue: $"{_settings.QueueName}-retry",
            durable: true,
            exclusive: false,
            autoDelete: false,
            arguments: new Dictionary<string, object>
            {
                ["x-dead-letter-exchange"] = _settings.ExchangeName,
                ["x-dead-letter-routing-key"] = _settings.RoutingKey,
                ["x-message-ttl"] = 60000 // 1 minuto
            });

        _logger.LogInformation("RabbitMQ Notification Producer initialized");
    }

    public async Task PublishNotificationAsync(NotificationEvent notification)
    {
        try
        {
            var message = JsonSerializer.Serialize(notification, _jsonOptions);
            var body = Encoding.UTF8.GetBytes(message);

            var properties = _channel.CreateBasicProperties();
            properties.Persistent = true;
            properties.ContentType = "application/json";
            properties.MessageId = notification.Id;
            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());
            properties.Headers = new Dictionary<string, object>
            {
                ["type"] = notification.Type,
                ["template"] = notification.TemplateName
            };

            _channel.BasicPublish(
                exchange: _settings.ExchangeName,
                routingKey: _settings.RoutingKey,
                basicProperties: properties,
                body: body);

            _logger.LogInformation("Notification event published: {Type} to {To}", notification.Type, notification.To);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to publish notification event: {Type}", notification.Type);
            throw;
        }
    }

    public async Task PublishEmailAsync(string to, string subject, string body, Dictionary<string, object>? data = null)
    {
        var notification = new EmailNotificationEvent
        {
            To = to,
            Subject = subject,
            Body = body,
            Data = data ?? new Dictionary<string, object>(),
            TemplateName = "CustomEmail"
        };

        await PublishNotificationAsync(notification);
    }

    public async Task PublishSmsAsync(string to, string message, Dictionary<string, object>? data = null)
    {
        var notification = new SmsNotificationEvent
        {
            To = to,
            Body = message,
            Data = data ?? new Dictionary<string, object>(),
            TemplateName = "CustomSMS"
        };

        await PublishNotificationAsync(notification);
    }

    public void Dispose()
    {
        _channel?.Close();
        _channel?.Dispose();
        _connection?.Close();
        _connection?.Dispose();
    }
}

---- File: AuthService.Infrastructure\Services\Messaging\NotificationServiceRabbitMQSettings.cs ----

namespace AuthService.Infrastructure.Services.Messaging;

public class NotificationServiceRabbitMQSettings
{
    public bool EnableRabbitMQ { get; set; } = true;
    public string QueueName { get; set; } = "notification-queue";
    public string ExchangeName { get; set; } = "notification-exchange";
    public string RoutingKey { get; set; } = "notification.auth";

    // Opcional: Configuraciones específicas para tipos de notificación
    public string EmailQueueName { get; set; } = "notification-email-queue";
    public string SmsQueueName { get; set; } = "notification-sms-queue";
    public string PushQueueName { get; set; } = "notification-push-queue";

    public int RetryDelayMs { get; set; } = 60000; // 1 minuto para retry
    public int MaxRetryAttempts { get; set; } = 3;
}

---- File: AuthService.Infrastructure\Services\Messaging\RabbitMQErrorProducer.cs ----
using AuthService.Shared.ErrorMessages;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
// Agregar estos alias para evitar conflictos
using RabbitMQConnection = RabbitMQ.Client.IConnection;
using RabbitMQChannel = RabbitMQ.Client.IModel;
using System.Text;
using System.Text.Json;

namespace AuthService.Infrastructure.Services.Messaging;


public interface IErrorEventProducer
{
    Task PublishErrorAsync(RabbitMQErrorEvent errorEvent);
    Task PublishErrorAsync(string errorCode, string errorMessage, string? stackTrace = null, string? userId = null, Dictionary<string, object>? metadata = null);
}

public class RabbitMQErrorProducer : IErrorEventProducer, IDisposable
{
    private readonly RabbitMQConnection _connection;
    private readonly RabbitMQChannel _channel;
    private readonly ErrorServiceRabbitMQSettings _settings;
    private readonly ILogger<RabbitMQErrorProducer> _logger;
    private readonly JsonSerializerOptions _jsonOptions;

    public RabbitMQErrorProducer(
        IOptions<RabbitMQSettings> rabbitMqSettings,
        IOptions<ErrorServiceRabbitMQSettings> errorServiceSettings,
        ILogger<RabbitMQErrorProducer> logger)
    {
        _settings = errorServiceSettings.Value;
        _logger = logger;

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };

        try
        {
            var factory = new ConnectionFactory
            {
                HostName = rabbitMqSettings.Value.Host,
                Port = rabbitMqSettings.Value.Port,
                UserName = rabbitMqSettings.Value.Username,
                Password = rabbitMqSettings.Value.Password,
                VirtualHost = rabbitMqSettings.Value.VirtualHost,
                DispatchConsumersAsync = true
            };

            _connection = factory.CreateConnection();
            _channel = _connection.CreateModel();

            // Declarar exchange y queue
            _channel.ExchangeDeclare(
                exchange: _settings.ExchangeName,
                type: ExchangeType.Direct,
                durable: true,
                autoDelete: false);

            _channel.QueueDeclare(
                queue: _settings.QueueName,
                durable: true,
                exclusive: false,
                autoDelete: false,
                arguments: null);

            _channel.QueueBind(
                queue: _settings.QueueName,
                exchange: _settings.ExchangeName,
                routingKey: _settings.RoutingKey);

            _logger.LogInformation("RabbitMQ Error Producer initialized successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize RabbitMQ Error Producer");
            throw;
        }
    }

    public async Task PublishErrorAsync(RabbitMQErrorEvent errorEvent)
    {
        if (!_settings.EnableRabbitMQ)
        {
            _logger.LogWarning("RabbitMQ error publishing is disabled");
            return;
        }

        try
        {
            var message = JsonSerializer.Serialize(errorEvent, _jsonOptions);
            var body = Encoding.UTF8.GetBytes(message);

            var properties = _channel.CreateBasicProperties();
            properties.Persistent = true;
            properties.ContentType = "application/json";
            properties.MessageId = errorEvent.Id;
            properties.Timestamp = new AmqpTimestamp(DateTimeOffset.UtcNow.ToUnixTimeSeconds());

            _channel.BasicPublish(
                exchange: _settings.ExchangeName,
                routingKey: _settings.RoutingKey,
                basicProperties: properties,
                body: body);

            _logger.LogInformation("Error event published to RabbitMQ: {ErrorCode}", errorEvent.ErrorCode);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to publish error event to RabbitMQ: {ErrorCode}", errorEvent.ErrorCode);
            // No throw - we don't want to break the main flow if error reporting fails
        }
    }

    public async Task PublishErrorAsync(string errorCode, string errorMessage, string? stackTrace = null, string? userId = null, Dictionary<string, object>? metadata = null)
    {
        var errorEvent = new RabbitMQErrorEvent(errorCode, errorMessage, stackTrace, userId)
        {
            Metadata = metadata ?? new Dictionary<string, object>()
        };

        await PublishErrorAsync(errorEvent);
    }

    public void Dispose()
    {
        _channel?.Close();
        _channel?.Dispose();
        _connection?.Close();
        _connection?.Dispose();
    }
}

---- File: AuthService.Infrastructure\Services\Messaging\RabbitMQSettings.cs ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AuthService.Infrastructure.Services.Messaging;

public class RabbitMQSettings
{
    public string Host { get; set; } = "localhost";
    public int Port { get; set; } = 5672;
    public string Username { get; set; } = "guest";
    public string Password { get; set; } = "guest";
    public string VirtualHost { get; set; } = "/";
}

---- File: AuthService.Infrastructure\Services\Notification\AuthNotificationService.cs ----
using AuthService.Domain.Enums;
using AuthService.Domain.Interfaces.Services;
using AuthService.Infrastructure.External;
using AuthService.Infrastructure.Services.Messaging;
using AuthService.Shared;
using AuthService.Shared.NotificationMessages;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace AuthService.Infrastructure.Services.Notification;

public class AuthNotificationService : IAuthNotificationService
{
    private readonly NotificationServiceClient _notificationServiceClient;
    private readonly INotificationEventProducer _notificationProducer;
    private readonly NotificationServiceSettings _settings;
    private readonly NotificationServiceRabbitMQSettings _rabbitMqSettings;
    private readonly ILogger<AuthNotificationService> _logger;

    public AuthNotificationService(
        NotificationServiceClient notificationServiceClient,
        INotificationEventProducer notificationProducer,
        IOptions<NotificationServiceSettings> settings,
        IOptions<NotificationServiceRabbitMQSettings> rabbitMqSettings,
        ILogger<AuthNotificationService> logger)
    {
        _notificationServiceClient = notificationServiceClient;
        _notificationProducer = notificationProducer;
        _settings = settings.Value;
        _rabbitMqSettings = rabbitMqSettings.Value; // .Value para obtener la instancia
        _logger = logger;
    }

    public async Task SendPasswordResetEmailAsync(string email, string resetToken)
    {
        var resetUrl = $"{_settings.FrontendBaseUrl}/reset-password?token={resetToken}";

        if (_rabbitMqSettings.EnableRabbitMQ && _notificationProducer != null)
        {
            await SendPasswordResetViaRabbitMQ(email, resetToken, resetUrl);
        }
        else
        {
            await SendPasswordResetViaHttp(email, resetToken, resetUrl);
        }
    }

    public async Task SendWelcomeEmailAsync(string email, string username)
    {
        if (_rabbitMqSettings.EnableRabbitMQ && _notificationProducer != null)
        {
            await SendWelcomeViaRabbitMQ(email, username);
        }
        else
        {
            await SendWelcomeViaHttp(email, username);
        }
    }

    public async Task SendEmailConfirmationAsync(string email, string confirmationToken)
    {
        var confirmUrl = $"{_settings.FrontendBaseUrl}/confirm-email?token={confirmationToken}";

        if (_rabbitMqSettings.EnableRabbitMQ && _notificationProducer != null)
        {
            await SendEmailConfirmationViaRabbitMQ(email, confirmationToken, confirmUrl);
        }
        else
        {
            await SendEmailConfirmationViaHttp(email, confirmationToken, confirmUrl);
        }
    }

    public async Task SendTwoFactorCodeAsync(string destination, string code, TwoFactorAuthType method)
    {
        if (_rabbitMqSettings.EnableRabbitMQ && _notificationProducer != null)
        {
            await SendTwoFactorCodeViaRabbitMQ(destination, code, method);
        }
        else
        {
            await SendTwoFactorCodeViaHttp(destination, code, method);
        }
    }

    public async Task SendTwoFactorBackupCodesAsync(string email, List<string> backupCodes)
    {
        if (_rabbitMqSettings.EnableRabbitMQ && _notificationProducer != null)
        {
            await SendTwoFactorBackupCodesViaRabbitMQ(email, backupCodes);
        }
        else
        {
            await SendTwoFactorBackupCodesViaHttp(email, backupCodes);
        }
    }

    #region RabbitMQ Methods

    private async Task SendPasswordResetViaRabbitMQ(string email, string resetToken, string resetUrl)
    {
        try
        {
            var notification = new EmailNotificationEvent
            {
                To = email,
                Subject = "Password Reset Request",
                TemplateName = "PasswordReset",
                Body = GeneratePasswordResetEmailBody(resetUrl),
                Data = new Dictionary<string, object>
                {
                    ["resetUrl"] = resetUrl,
                    ["expiryHours"] = 1,
                    ["token"] = resetToken
                },
                IsHtml = true
            };

            await _notificationProducer.PublishNotificationAsync(notification);
            _logger.LogInformation("Password reset notification sent via RabbitMQ to {Email}", email);
        }
        catch (System.Exception ex)
        {
            _logger.LogError(ex, "Failed to send password reset via RabbitMQ to {Email}. Falling back to HTTP.", email);
            await SendPasswordResetViaHttp(email, resetToken, resetUrl);
        }
    }

    private async Task SendWelcomeViaRabbitMQ(string email, string username)
    {
        try
        {
            var notification = new EmailNotificationEvent
            {
                To = email,
                Subject = "Welcome to Our Platform!",
                TemplateName = "Welcome",
                Body = GenerateWelcomeEmailBody(username),
                Data = new Dictionary<string, object>
                {
                    ["username"] = username,
                    ["loginUrl"] = $"{_settings.FrontendBaseUrl}/login",
                    ["supportEmail"] = "support@example.com"
                },
                IsHtml = true
            };

            await _notificationProducer.PublishNotificationAsync(notification);
            _logger.LogInformation("Welcome email sent via RabbitMQ to {Email}", email);
        }
        catch (System.Exception ex)
        {
            _logger.LogError(ex, "Failed to send welcome email via RabbitMQ to {Email}. Falling back to HTTP.", email);
            await SendWelcomeViaHttp(email, username);
        }
    }

    private async Task SendEmailConfirmationViaRabbitMQ(string email, string confirmationToken, string confirmUrl)
    {
        try
        {
            var notification = new EmailNotificationEvent
            {
                To = email,
                Subject = "Confirm Your Email Address",
                TemplateName = "EmailConfirmation",
                Body = GenerateEmailConfirmationBody(confirmUrl),
                Data = new Dictionary<string, object>
                {
                    ["confirmationUrl"] = confirmUrl,
                    ["expiryHours"] = 24,
                    ["token"] = confirmationToken
                },
                IsHtml = true
            };

            await _notificationProducer.PublishNotificationAsync(notification);
            _logger.LogInformation("Email confirmation sent via RabbitMQ to {Email}", email);
        }
        catch (System.Exception ex)
        {
            _logger.LogError(ex, "Failed to send email confirmation via RabbitMQ to {Email}. Falling back to HTTP.", email);
            await SendEmailConfirmationViaHttp(email, confirmationToken, confirmUrl);
        }
    }

    private async Task SendTwoFactorCodeViaRabbitMQ(string destination, string code, TwoFactorAuthType method)
    {
        try
        {
            NotificationEvent notification = method switch
            {
                TwoFactorAuthType.SMS => new SmsNotificationEvent
                {
                    To = destination,
                    Body = $"Your verification code is: {code}. This code will expire in 5 minutes.",
                    TemplateName = "TwoFactorSMS",
                    Data = new Dictionary<string, object>
                    {
                        ["code"] = code,
                        ["expiryMinutes"] = 5
                    }
                },
                TwoFactorAuthType.Email => new EmailNotificationEvent
                {
                    To = destination,
                    Subject = "Your Verification Code",
                    Body = GenerateTwoFactorEmailBody(code),
                    TemplateName = "TwoFactorEmail",
                    Data = new Dictionary<string, object>
                    {
                        ["code"] = code,
                        ["expiryMinutes"] = 5
                    },
                    IsHtml = true
                },
                _ => throw new System.ArgumentException($"Unsupported 2FA method: {method}")
            };

            await _notificationProducer.PublishNotificationAsync(notification);
            _logger.LogInformation("2FA code sent via RabbitMQ to {Destination} using {Method}", destination, method);
        }
        catch (System.Exception ex)
        {
            _logger.LogError(ex, "Failed to send 2FA code via RabbitMQ to {Destination}. Falling back to HTTP.", destination);
            await SendTwoFactorCodeViaHttp(destination, code, method);
        }
    }

    private async Task SendTwoFactorBackupCodesViaRabbitMQ(string email, List<string> backupCodes)
    {
        try
        {
            var notification = new EmailNotificationEvent
            {
                To = email,
                Subject = "Your Two-Factor Authentication Backup Codes",
                TemplateName = "TwoFactorBackupCodes",
                Body = GenerateBackupCodesEmailBody(backupCodes),
                Data = new Dictionary<string, object>
                {
                    ["backupCodes"] = backupCodes,
                    ["generatedAt"] = System.DateTime.UtcNow
                },
                IsHtml = true
            };

            await _notificationProducer.PublishNotificationAsync(notification);
            _logger.LogInformation("2FA backup codes sent via RabbitMQ to {Email}", email);
        }
        catch (System.Exception ex)
        {
            _logger.LogError(ex, "Failed to send 2FA backup codes via RabbitMQ to {Email}. Falling back to HTTP.", email);
            await SendTwoFactorBackupCodesViaHttp(email, backupCodes);
        }
    }

    #endregion

    #region HTTP Fallback Methods

    private async Task SendPasswordResetViaHttp(string email, string resetToken, string resetUrl)
    {
        var subject = "Password Reset Request";
        var body = GeneratePasswordResetEmailBody(resetUrl);

        var success = await _notificationServiceClient.SendEmailAsync(email, subject, body, true);

        if (success)
        {
            _logger.LogInformation("Password reset email sent via HTTP to {Email}", email);
        }
        else
        {
            _logger.LogError("Failed to send password reset email via HTTP to {Email}", email);
        }
    }

    private async Task SendWelcomeViaHttp(string email, string username)
    {
        var subject = "Welcome to Our Platform!";
        var body = GenerateWelcomeEmailBody(username);

        var success = await _notificationServiceClient.SendEmailAsync(email, subject, body, true);

        if (success)
        {
            _logger.LogInformation("Welcome email sent via HTTP to {Email}", email);
        }
        else
        {
            _logger.LogError("Failed to send welcome email via HTTP to {Email}", email);
        }
    }

    private async Task SendEmailConfirmationViaHttp(string email, string confirmationToken, string confirmUrl)
    {
        var subject = "Confirm Your Email Address";
        var body = GenerateEmailConfirmationBody(confirmUrl);

        var success = await _notificationServiceClient.SendEmailAsync(email, subject, body, true);

        if (success)
        {
            _logger.LogInformation("Email confirmation sent via HTTP to {Email}", email);
        }
        else
        {
            _logger.LogError("Failed to send email confirmation via HTTP to {Email}", email);
        }
    }

    private async Task SendTwoFactorCodeViaHttp(string destination, string code, TwoFactorAuthType method)
    {
        bool success = false;

        if (method == TwoFactorAuthType.SMS)
        {
            var message = $"Your verification code is: {code}. This code will expire in 5 minutes.";
            success = await _notificationServiceClient.SendSmsAsync(destination, message);
        }
        else if (method == TwoFactorAuthType.Email)
        {
            var subject = "Your Verification Code";
            var body = GenerateTwoFactorEmailBody(code);
            success = await _notificationServiceClient.SendEmailAsync(destination, subject, body, true);
        }

        if (success)
        {
            _logger.LogInformation("2FA code sent via HTTP to {Destination} using {Method}", destination, method);
        }
        else
        {
            _logger.LogError("Failed to send 2FA code via HTTP to {Destination} using {Method}", destination, method);
        }
    }

    private async Task SendTwoFactorBackupCodesViaHttp(string email, List<string> backupCodes)
    {
        var subject = "Your Two-Factor Authentication Backup Codes";
        var body = GenerateBackupCodesEmailBody(backupCodes);

        var success = await _notificationServiceClient.SendEmailAsync(email, subject, body, true);

        if (success)
        {
            _logger.LogInformation("2FA backup codes sent via HTTP to {Email}", email);
        }
        else
        {
            _logger.LogError("Failed to send 2FA backup codes via HTTP to {Email}", email);
        }
    }

    #endregion

    #region Email Body Generators

    private string GeneratePasswordResetEmailBody(string resetUrl)
    {
        return $@"
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                    .button {{ display: inline-block; padding: 12px 24px; background-color: #007bff; color: white; text-decoration: none; border-radius: 4px; }}
                    .footer {{ margin-top: 20px; font-size: 12px; color: #666; }}
                </style>
            </head>
            <body>
                <div class='container'>
                    <h2>Password Reset Request</h2>
                    <p>You have requested to reset your password.</p>
                    <p>Please click the button below to reset your password:</p>
                    <p><a href='{resetUrl}' class='button'>Reset Password</a></p>
                    <p>This link will expire in 1 hour.</p>
                    <p>If you did not request this reset, please ignore this email.</p>
                    <div class='footer'>
                        <p>If you're having trouble with the button, copy and paste this link into your browser:</p>
                        <p>{resetUrl}</p>
                    </div>
                </div>
            </body>
            </html>";
    }

    private string GenerateWelcomeEmailBody(string username)
    {
        return $@"
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                    .welcome {{ color: #28a745; }}
                </style>
            </head>
            <body>
                <div class='container'>
                    <h2 class='welcome'>Welcome, {username}!</h2>
                    <p>Thank you for joining our platform. We're excited to have you on board!</p>
                    <p>Your account has been successfully created and you can now start using all our features.</p>
                    <p>If you have any questions, feel free to contact our support team.</p>
                    <p>Best regards,<br/>The Team</p>
                </div>
            </body>
            </html>";
    }

    private string GenerateEmailConfirmationBody(string confirmUrl)
    {
        return $@"
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                    .button {{ display: inline-block; padding: 12px 24px; background-color: #28a745; color: white; text-decoration: none; border-radius: 4px; }}
                </style>
            </head>
            <body>
                <div class='container'>
                    <h2>Email Confirmation</h2>
                    <p>Thank you for registering with us!</p>
                    <p>Please confirm your email address by clicking the button below:</p>
                    <p><a href='{confirmUrl}' class='button'>Confirm Email Address</a></p>
                    <p>This link will expire in 24 hours.</p>
                    <p>If you did not create an account, please ignore this email.</p>
                </div>
            </body>
            </html>";
    }

    private string GenerateTwoFactorEmailBody(string code)
    {
        return $@"
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                    .code {{ font-size: 24px; font-weight: bold; color: #007bff; letter-spacing: 4px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; text-align: center; }}
                </style>
            </head>
            <body>
                <div class='container'>
                    <h2>Your Verification Code</h2>
                    <p>Your verification code is:</p>
                    <div class='code'>{code}</div>
                    <p>This code will expire in 5 minutes.</p>
                    <p>If you didn't request this code, please ignore this message.</p>
                </div>
            </body>
            </html>";
    }

    private string GenerateBackupCodesEmailBody(List<string> backupCodes)
    {
        var codesHtml = string.Join("<br/>", backupCodes);

        return $@"
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body {{ font-family: Arial, sans-serif; line-height: 1.6; color: #333; }}
                    .container {{ max-width: 600px; margin: 0 auto; padding: 20px; }}
                    .codes {{ font-family: monospace; background-color: #f8f9fa; padding: 15px; border-radius: 4px; }}
                    .warning {{ color: #856404; background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 10px; border-radius: 4px; }}
                </style>
            </head>
            <body>
                <div class='container'>
                    <h2>Backup Codes</h2>
                    <p>Here are your two-factor authentication backup codes:</p>
                    <div class='codes'>{codesHtml}</div>
                    <div class='warning'>
                        <p><strong>Important:</strong> Save these codes in a safe place. Each code can only be used once.</p>
                        <p>If you lose your authenticator app and don't have backup codes, you may lose access to your account.</p>
                    </div>
                </div>
            </body>
            </html>";
    }

    #endregion
}

---- File: AuthService.Infrastructure\Services\Security\TokenService.cs ----
using AuthService.Domain.Interfaces.Services;
using AuthService.Domain.Interfaces.Repositories;
using AuthService.Domain.Entities;
using Microsoft.Extensions.Caching.Distributed;
using System.Text.Json;

namespace AuthService.Infrastructure.Services.Security;

public class TokenService : ITokenService
{
    private readonly IJwtGenerator _jwtGenerator;
    private readonly IRefreshTokenRepository _refreshTokenRepository;
    private readonly IDistributedCache _cache;
    private readonly TimeSpan _refreshTokenExpiration = TimeSpan.FromDays(7);

    public TokenService(
        IJwtGenerator jwtGenerator,
        IRefreshTokenRepository refreshTokenRepository,
        IDistributedCache cache)
    {
        _jwtGenerator = jwtGenerator;
        _refreshTokenRepository = refreshTokenRepository;
        _cache = cache;
    }

    public async Task<(string accessToken, string refreshToken)> GenerateTokensAsync(ApplicationUser user, string ipAddress)
    {
        var accessToken = _jwtGenerator.GenerateToken(user);
        var refreshTokenValue = _jwtGenerator.GenerateRefreshToken();

        var refreshToken = new RefreshToken(
            user.Id,
            refreshTokenValue,
            DateTime.UtcNow.Add(_refreshTokenExpiration),
            ipAddress
        );

        await _refreshTokenRepository.AddAsync(refreshToken);

        // Cache del token de acceso para validación rápida
        await CacheAccessTokenAsync(accessToken, user.Id);

        return (accessToken, refreshTokenValue);
    }

    public async Task<bool> RevokeRefreshTokenAsync(string refreshToken, string ipAddress, string reason = "revoked")
    {
        var storedToken = await _refreshTokenRepository.GetByTokenAsync(refreshToken);

        if (storedToken == null || storedToken.IsRevoked)
            return false;

        storedToken.Revoke(ipAddress, reason);
        await _refreshTokenRepository.UpdateAsync(storedToken);

        // Invalidar cache del token de acceso asociado
        await InvalidateAccessTokenCacheAsync(storedToken.UserId);

        return true;
    }

    public async Task<bool> IsAccessTokenValidAsync(string accessToken, string userId)
    {
        var cachedToken = await _cache.GetStringAsync($"access_token_{userId}");
        return cachedToken == accessToken;
    }

    private async Task CacheAccessTokenAsync(string accessToken, string userId)
    {
        var options = new DistributedCacheEntryOptions
        {
            AbsoluteExpirationRelativeToNow = TimeSpan.FromMinutes(60) // Mismo tiempo que expira el JWT
        };

        await _cache.SetStringAsync($"access_token_{userId}", accessToken, options);
    }

    private async Task InvalidateAccessTokenCacheAsync(string userId)
    {
        await _cache.RemoveAsync($"access_token_{userId}");
    }

    public async Task CleanupExpiredTokensAsync()
    {
        await _refreshTokenRepository.CleanupExpiredTokensAsync();
    }
}

---- File: AuthService.Shared\ApiResponse.cs ----
namespace AuthService.Shared;

/// <summary>
/// Generic wrapper for API responses
/// </summary>
/// <typeparam name="T">Type of the data payload</typeparam>
public class ApiResponse<T>
{
  /// <summary>Indicates if the operation was successful</summary>
  public bool Success { get; set; }

  /// <summary>Data returned when Success is true</summary>
  public T? Data { get; set; }

  /// <summary>Error message when Success is false</summary>
  public string? Error { get; set; }

  /// <summary>Additional metadata about the response</summary>
  public Dictionary<string, object>? Metadata { get; set; }

  /// <summary>Timestamp when the response was generated</summary>
  public DateTime Timestamp { get; set; } = DateTime.UtcNow;

  /// <summary>Creates a successful response with the provided data</summary>
  public static ApiResponse<T> Ok(T data, Dictionary<string, object>? metadata = null) =>
      new()
      {
        Success = true,
        Data = data,
        Metadata = metadata
      };

  /// <summary>Creates a failed response with the provided error message</summary>
  public static ApiResponse<T> Fail(string errorMessage, Dictionary<string, object>? metadata = null) =>
      new()
      {
        Success = false,
        Error = errorMessage,
        Metadata = metadata
      };

  /// <summary>Creates a failed response with validation errors</summary>
  public static ApiResponse<T> ValidationFail(Dictionary<string, string[]> errors) =>
      new()
      {
        Success = false,
        Error = "Validation failed",
        Metadata = new Dictionary<string, object> { ["validationErrors"] = errors }
      };
}

/// <summary>
/// Non-generic API response for void operations
/// </summary>
public class ApiResponse
{
  /// <summary>Indicates if the operation was successful</summary>
  public bool Success { get; set; }

  /// <summary>Error message when Success is false</summary>
  public string? Error { get; set; }

  /// <summary>Additional metadata about the response</summary>
  public Dictionary<string, object>? Metadata { get; set; }

  /// <summary>Timestamp when the response was generated</summary>
  public DateTime Timestamp { get; set; } = DateTime.UtcNow;

  /// <summary>Creates a successful response</summary>
  public static ApiResponse Ok(Dictionary<string, object>? metadata = null) =>
      new()
      {
        Success = true,
        Metadata = metadata
      };

  /// <summary>Creates a failed response with the provided error message</summary>
  public static ApiResponse Fail(string errorMessage, Dictionary<string, object>? metadata = null) =>
      new()
      {
        Success = false,
        Error = errorMessage,
        Metadata = metadata
      };
}

---- File: AuthService.Shared\AuthService.Shared.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
    <PackageReference Include="System.Text.Json" Version="8.0.4" />
  </ItemGroup>

</Project>

---- File: AuthService.Shared\CacheSettings.cs ----
namespace AuthService.Shared;

/// <summary>
/// Cache configuration settings
/// </summary>
public class CacheSettings
{
    /// <summary>Redis connection string</summary>
    public string RedisConnectionString { get; set; } = "localhost:6379";

    /// <summary>Default cache expiration in minutes</summary>
    public int DefaultExpirationMinutes { get; set; } = 30;

    /// <summary>User cache expiration in minutes</summary>
    public int UserCacheExpirationMinutes { get; set; } = 15;

    /// <summary>Token cache expiration in minutes</summary>
    public int TokenCacheExpirationMinutes { get; set; } = 5;

    /// <summary>Whether to enable distributed caching</summary>
    public bool EnableDistributedCache { get; set; } = true;
}

---- File: AuthService.Shared\Constants.cs ----
namespace AuthService.Shared;

/// <summary>
/// Application constants
/// </summary>
public static class Constants
{
    /// <summary>
    /// Cache key patterns
    /// </summary>
    public static class CacheKeys
    {
        public const string UserById = "user_{0}";
        public const string UserByEmail = "user_email_{0}";
        public const string RefreshToken = "refresh_token_{0}";
        public const string VerificationToken = "verification_token_{0}";
        public const string RateLimit = "rate_limit_{0}";
    }

    /// <summary>
    /// Policy names for authorization
    /// </summary>
    public static class Policies
    {
        public const string RequireAdminRole = "RequireAdminRole";
        public const string RequireVerifiedEmail = "RequireVerifiedEmail";
        public const string AllowAnonymous = "AllowAnonymous";
    }

    /// <summary>
    /// Role names
    /// </summary>
    public static class Roles
    {
        public const string Administrator = "Administrator";
        public const string User = "User";
        public const string Moderator = "Moderator";
    }

    /// <summary>
    /// Claim types
    /// </summary>
    public static class ClaimTypes
    {
        public const string UserId = "sub";
        public const string Email = "email";
        public const string Name = "name";
        public const string Role = "role";
        public const string EmailVerified = "email_verified";
    }

    /// <summary>
    /// HTTP header names
    /// </summary>
    public static class Headers
    {
        public const string ApiKey = "X-API-Key";
        public const string CorrelationId = "X-Correlation-ID";
        public const string UserAgent = "User-Agent";
        public const string ForwardedFor = "X-Forwarded-For";
    }

    /// <summary>
    /// Token expiration times
    /// </summary>
    public static class TokenExpiration
    {
        public static readonly TimeSpan AccessToken = TimeSpan.FromMinutes(60);
        public static readonly TimeSpan RefreshToken = TimeSpan.FromDays(7);
        public static readonly TimeSpan EmailVerification = TimeSpan.FromHours(24);
        public static readonly TimeSpan PasswordReset = TimeSpan.FromHours(1);
    }

    /// <summary>
    /// Rate limit periods
    /// </summary>
    public static class RateLimitPeriods
    {
        public const int LoginPerMinute = 5;
        public const int LoginPerHour = 20;
        public const int RegistrationPerHour = 10;
        public const int PasswordResetPerHour = 5;
    }
}

---- File: AuthService.Shared\DatabaseSettings.cs ----
namespace AuthService.Shared;

/// <summary>
/// Database configuration settings
/// </summary>
public class DatabaseSettings
{
    /// <summary>Database connection string</summary>
    public string ConnectionString { get; set; } = null!;

    /// <summary>Database provider (PostgreSQL, SQLServer, etc.)</summary>
    public string Provider { get; set; } = "PostgreSQL";

    /// <summary>Whether to enable sensitive data logging</summary>
    public bool EnableSensitiveDataLogging { get; set; } = false;

    /// <summary>Whether to enable detailed errors</summary>
    public bool EnableDetailedErrors { get; set; } = false;

    /// <summary>Command timeout in seconds</summary>
    public int CommandTimeout { get; set; } = 30;

    /// <summary>Maximum number of retry attempts</summary>
    public int MaxRetryCount { get; set; } = 3;
}

---- File: AuthService.Shared\EmailSettings.cs ----
namespace AuthService.Shared;

/// <summary>
/// Email service configuration settings
/// </summary>
public class EmailSettings
{
    /// <summary>SMTP server host</summary>
    public string Host { get; set; } = "localhost";

    /// <summary>SMTP server port</summary>
    public int Port { get; set; } = 25;

    /// <summary>Whether to use SSL/TLS</summary>
    public bool UseSsl { get; set; }

    /// <summary>SMTP username</summary>
    public string Username { get; set; } = string.Empty;

    /// <summary>SMTP password</summary>
    public string Password { get; set; } = string.Empty;

    /// <summary>Sender email address</summary>
    public string From { get; set; } = "noreply@example.com";

    /// <summary>Sender display name</summary>
    public string FromName { get; set; } = "Auth Service";

    /// <summary>Email template directory path</summary>
    public string TemplatePath { get; set; } = "EmailTemplates";

    /// <summary>Whether to enable email sending</summary>
    public bool EnableEmailSending { get; set; } = true;
}

---- File: AuthService.Shared\Enums.cs ----
namespace AuthService.Shared;

/// <summary>
/// Application enums
/// </summary>
public static class Enums
{
    /// <summary>
    /// Token types for verification
    /// </summary>
    public enum TokenType
    {
        EmailVerification = 1,
        PasswordReset = 2,
        PhoneVerification = 3,
        TwoFactor = 4
    }

    /// <summary>
    /// User status
    /// </summary>
    public enum UserStatus
    {
        Active = 1,
        Inactive = 2,
        Suspended = 3,
        Locked = 4
    }

    /// <summary>
    /// Authentication providers
    /// </summary>
    public enum AuthProvider
    {
        Internal = 1,
        Google = 2,
        Facebook = 3,
        Microsoft = 4
    }

    /// <summary>
    /// Log levels
    /// </summary>
    public enum LogLevel
    {
        Debug = 1,
        Information = 2,
        Warning = 3,
        Error = 4,
        Critical = 5
    }
}

---- File: AuthService.Shared\ErrorServiceSettings.cs ----
namespace AuthService.Shared;

/// <summary>
/// Error Service configuration for centralized error logging
/// </summary>
public class ErrorServiceSettings
{
    /// <summary>Base URL of the Error Service</summary>
    public string BaseUrl { get; set; } = "http://errorservice:80";

    /// <summary>Request timeout in seconds</summary>
    public int TimeoutSeconds { get; set; } = 30;

    /// <summary>Whether to enable error logging to the service</summary>
    public bool EnableErrorLogging { get; set; } = true;

    /// <summary>Service name to identify the source of errors</summary>
    public string ServiceName { get; set; } = "AuthService";

    /// <summary>Environment name (Development, Staging, Production)</summary>
    public string Environment { get; set; } = "Development";
}

---- File: AuthService.Shared\HealthCheckResponse.cs ----
namespace AuthService.Shared;

/// <summary>
/// Health check response model
/// </summary>
public class HealthCheckResponse
{
    /// <summary>Overall status of the service</summary>
    public string Status { get; set; } = "Healthy";

    /// <summary>Service name</summary>
    public string Service { get; set; } = "AuthService";

    /// <summary>Timestamp of the health check</summary>
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    /// <summary>Service version</summary>
    public string Version { get; set; } = "1.0.0";

    /// <summary>Environment name</summary>
    public string Environment { get; set; } = "Development";

    /// <summary>Detailed health checks for dependencies</summary>
    public Dictionary<string, string> Checks { get; set; } = new();

    /// <summary>Uptime of the service</summary>
    public TimeSpan Uptime { get; set; }

    /// <summary>Memory usage information</summary>
    public MemoryUsage Memory { get; set; } = new();
}

/// <summary>
/// Memory usage information
/// </summary>
public class MemoryUsage
{
    /// <summary>Total allocated memory in MB</summary>
    public double Allocated { get; set; }

    /// <summary>Working set in MB</summary>
    public double WorkingSet { get; set; }

    /// <summary>GC collections count</summary>
    public long GarbageCollections { get; set; }
}

---- File: AuthService.Shared\HealthCheckSettings.cs ----
/// <summary>
/// HealthCheck settings
/// </summary>
public class HealthCheckSettings
{
    public bool Enabled { get; set; } = true;
    public int DatabaseTimeout { get; set; } = 30;
    public int RedisTimeout { get; set; } = 10;
    public int ExternalServicesTimeout { get; set; } = 30;
}

---- File: AuthService.Shared\JwtSettings.cs ----
namespace AuthService.Shared;

/// <summary>
/// JWT configuration settings read from appsettings.json
/// </summary>
public class JwtSettings
{
    /// <summary>Secret key used to sign the token</summary>
    public string Key { get; set; } = null!;

    /// <summary>Token issuer (iss)</summary>
    public string Issuer { get; set; } = null!;

    /// <summary>Token audience (aud)</summary>
    public string Audience { get; set; } = null!;

    /// <summary>Expiration time in minutes</summary>
    public int ExpiresMinutes { get; set; } = 60;

    /// <summary>Refresh token expiration in days</summary>
    public int RefreshTokenExpiresDays { get; set; } = 7;

    /// <summary>Clock skew allowed in token validation</summary>
    public int ClockSkewMinutes { get; set; } = 5;
}

---- File: AuthService.Shared\NotificationServiceSettings.cs ----
namespace AuthService.Shared;

public class NotificationServiceSettings
{
    /// <summary>Base URL of the Notification Service</summary>
    public string BaseUrl { get; set; } = "http://notificationservice:80"; // Valor por defecto

    /// <summary>Request timeout in seconds</summary>
    public int TimeoutSeconds { get; set; } = 30; // Valor por defecto

    /// <summary>Base URL of the Frontend application (used for links in emails)</summary>
    public string FrontendBaseUrl { get; set; } = "http://localhost:3000"; // Valor por defecto, AJUSTAR

    /// <summary>Whether to enable notifications via the service</summary>
    public bool EnableNotifications { get; set; } = true; // Valor por defecto
}

---- File: AuthService.Shared\SecuritySettings.cs ----
namespace AuthService.Shared;

/// <summary>
/// Security-related configuration settings
/// </summary>
public class SecuritySettings
{
    /// <summary>Password policy configuration</summary>
    public PasswordPolicySettings PasswordPolicy { get; set; } = new();

    /// <summary>Lockout policy configuration</summary>
    public LockoutPolicySettings LockoutPolicy { get; set; } = new();

    /// <summary>Two-factor authentication settings</summary>
    public TwoFactorSettings TwoFactor { get; set; } = new();

    /// <summary>Rate limiting settings</summary>
    public RateLimitSettings RateLimit { get; set; } = new();
}

/// <summary>
/// Password policy configuration
/// </summary>
public class PasswordPolicySettings
{
    /// <summary>Minimum password length</summary>
    public int RequiredLength { get; set; } = 8;

    /// <summary>Whether to require uppercase characters</summary>
    public bool RequireUppercase { get; set; } = true;

    /// <summary>Whether to require lowercase characters</summary>
    public bool RequireLowercase { get; set; } = true;

    /// <summary>Whether to require digits</summary>
    public bool RequireDigit { get; set; } = true;

    /// <summary>Whether to require non-alphanumeric characters</summary>
    public bool RequireNonAlphanumeric { get; set; } = false;

    /// <summary>Maximum number of failed password attempts before lockout</summary>
    public int MaxFailedAttempts { get; set; } = 5;
}

/// <summary>
/// Account lockout policy configuration
/// </summary>
public class LockoutPolicySettings
{
    /// <summary>Whether lockout is enabled</summary>
    public bool Enabled { get; set; } = true;

    /// <summary>Lockout duration in minutes</summary>
    public int DefaultLockoutMinutes { get; set; } = 30;

    /// <summary>Maximum number of failed attempts before lockout</summary>
    public int MaxFailedAccessAttempts { get; set; } = 5;
}

/// <summary>
/// Two-factor authentication settings
/// </summary>
public class TwoFactorSettings
{
    /// <summary>Whether two-factor authentication is enabled</summary>
    public bool Enabled { get; set; } = false;

    /// <summary>Two-factor authentication providers</summary>
    public string[] Providers { get; set; } = ["Email", "SMS"];

    /// <summary>Remember browser duration in days</summary>
    public int RememberBrowserDays { get; set; } = 14;
}

/// <summary>
/// Rate limiting settings
/// </summary>
public class RateLimitSettings
{
    /// <summary>Whether rate limiting is enabled</summary>
    public bool Enabled { get; set; } = true;

    /// <summary>Maximum requests per minute</summary>
    public int RequestsPerMinute { get; set; } = 60;

    /// <summary>Maximum login attempts per hour</summary>
    public int LoginAttemptsPerHour { get; set; } = 10;

    /// <summary>Maximum password reset attempts per hour</summary>
    public int PasswordResetAttemptsPerHour { get; set; } = 5;
}

---- File: AuthService.Shared\ServiceConfigurations.cs ----
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace AuthService.Shared;

/// <summary>
/// Extension methods for configuring services
/// </summary>
public static class ServiceConfigurations
{
    /// <summary>
    /// Registers all configuration settings from appsettings.json
    /// </summary>
    public static IServiceCollection AddSharedConfiguration(this IServiceCollection services, IConfiguration configuration)
    {
        // Register JWT settings
        services.Configure<JwtSettings>(configuration.GetSection("Jwt"));

        // Register email settings
        services.Configure<EmailSettings>(configuration.GetSection("Email"));

        // Register error service settings
        services.Configure<ErrorServiceSettings>(configuration.GetSection("ErrorService"));

        // Register cache settings
        services.Configure<CacheSettings>(configuration.GetSection("Cache"));

        // Register database settings
        services.Configure<DatabaseSettings>(configuration.GetSection("Database"));

        // Register security settings
        services.Configure<SecuritySettings>(configuration.GetSection("Security"));

        return services;
    }

    /// <summary>
    /// Validates that all required configuration settings are present
    /// </summary>
    public static void ValidateConfiguration(this IConfiguration configuration)
    {
        var jwtSettings = configuration.GetSection("Jwt").Get<JwtSettings>();
        if (string.IsNullOrEmpty(jwtSettings?.Key) || jwtSettings.Key.Length < 32)
        {
            throw new InvalidOperationException(
                "JWT Key is missing or too short. It must be at least 32 characters long.");
        }

        var dbSettings = configuration.GetSection("Database").Get<DatabaseSettings>();
        if (string.IsNullOrEmpty(dbSettings?.ConnectionString))
        {
            throw new InvalidOperationException("Database connection string is required.");
        }
    }
}

---- File: AuthService.Shared\ValidationPatterns.cs ----
using System.Text.RegularExpressions;

namespace AuthService.Shared;

/// <summary>
/// Regular expression patterns for validation
/// </summary>
public static class ValidationPatterns
{
    /// <summary>Pattern for email validation</summary>
    public const string Email = @"^[^@\s]+@[^@\s]+\.[^@\s]+$";

    /// <summary>Pattern for password validation (at least 8 chars, 1 uppercase, 1 lowercase, 1 number)</summary>
    public const string Password = @"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$";

    /// <summary>Pattern for username validation (alphanumeric, underscores, hyphens, 3-20 chars)</summary>
    public const string Username = @"^[a-zA-Z0-9_-]{3,20}$";

    /// <summary>Pattern for phone number validation (international format)</summary>
    public const string PhoneNumber = @"^\+?[1-9]\d{1,14}$";

    /// <summary>Pattern for JWT token validation</summary>
    public const string JwtToken = @"^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$";

    /// <summary>
    /// Validates an email address
    /// </summary>
    public static bool IsValidEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
            return false;

        return Regex.IsMatch(email, Email, RegexOptions.IgnoreCase);
    }

    /// <summary>
    /// Validates a password against complexity requirements
    /// </summary>
    public static bool IsValidPassword(string password)
    {
        if (string.IsNullOrWhiteSpace(password))
            return false;

        return Regex.IsMatch(password, Password);
    }

    /// <summary>
    /// Validates a username
    /// </summary>
    public static bool IsValidUsername(string username)
    {
        if (string.IsNullOrWhiteSpace(username))
            return false;

        return Regex.IsMatch(username, Username);
    }
}

---- File: AuthService.Shared\ErrorMessages\RabbitMQErrorEvent.cs ----

using System.Text.Json.Serialization;

namespace AuthService.Shared.ErrorMessages;

public class RabbitMQErrorEvent
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = Guid.NewGuid().ToString();

    [JsonPropertyName("serviceName")]
    public string ServiceName { get; set; } = "AuthService";

    [JsonPropertyName("errorCode")]
    public string ErrorCode { get; set; } = string.Empty;

    [JsonPropertyName("errorMessage")]
    public string ErrorMessage { get; set; } = string.Empty;

    [JsonPropertyName("stackTrace")]
    public string? StackTrace { get; set; }

    [JsonPropertyName("timestamp")]
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    [JsonPropertyName("userId")]
    public string? UserId { get; set; }

    [JsonPropertyName("endpoint")]
    public string? Endpoint { get; set; }

    [JsonPropertyName("httpMethod")]
    public string? HttpMethod { get; set; }

    [JsonPropertyName("statusCode")]
    public int? StatusCode { get; set; }

    [JsonPropertyName("metadata")]
    public Dictionary<string, object> Metadata { get; set; } = new();

    [JsonPropertyName("environment")]
    public string Environment { get; set; } = "Development";

    public RabbitMQErrorEvent() { }

    public RabbitMQErrorEvent(string errorCode, string errorMessage, string? stackTrace = null, string? userId = null)
    {
        ErrorCode = errorCode;
        ErrorMessage = errorMessage;
        StackTrace = stackTrace;
        UserId = userId;
    }
}

---- File: AuthService.Shared\NotificationMessages\EmailNotificationEvent.cs ----

namespace AuthService.Shared.NotificationMessages;


public class EmailNotificationEvent : NotificationEvent
{
    public EmailNotificationEvent()
    {
        Type = "Email";
    }

    public bool IsHtml { get; set; } = true;
    public List<string> CC { get; set; } = new();
    public List<string> BCC { get; set; } = new();
}

---- File: AuthService.Shared\NotificationMessages\NotificationEvent.cs ----

namespace AuthService.Shared.NotificationMessages;

public class NotificationEvent
{
    public string Id { get; set; } = Guid.NewGuid().ToString();
    public string Type { get; set; } // "Email", "SMS", "Push"
    public string TemplateName { get; set; } // "Welcome", "PasswordReset", "EmailVerification"
    public string To { get; set; } = string.Empty;
    public string Subject { get; set; } = string.Empty;
    public string Body { get; set; } = string.Empty;
    public Dictionary<string, object> Data { get; set; } = new();
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public string? UserId { get; set; }
    public int Priority { get; set; } = 1; // 1=Low, 2=Medium, 3=High
}

---- File: AuthService.Shared\NotificationMessages\PushNotificationEvent.cs ----

namespace AuthService.Shared.NotificationMessages;

public class PushNotificationEvent : NotificationEvent
{
    public PushNotificationEvent()
    {
        Type = "Push";
    }

    public string DeviceToken { get; set; } = string.Empty;
    public string Title { get; set; } = string.Empty;
    public Dictionary<string, string> CustomData { get; set; } = new();
}

---- File: AuthService.Shared\NotificationMessages\SmsNotificationEvent.cs ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AuthService.Shared.NotificationMessages;

public class SmsNotificationEvent : NotificationEvent
{
    public SmsNotificationEvent()
    {
        Type = "SMS";
    }
}

