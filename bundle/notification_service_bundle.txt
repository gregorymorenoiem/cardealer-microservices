## Code Bundle - Aggregated Files
## Microservicio: backend\NotificationService
## Generado: 10/30/2025 05:47:21
## Carpetas excluidas: bin, obj, Properties

---- File: NotificationService.sln ----

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NotificationService.Api", "NotificationService.Api\NotificationService.Api.csproj", "{33A72E0F-31B6-44EE-BE8A-9918C579A03A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NotificationService.Application", "NotificationService.Application\NotificationService.Application.csproj", "{BD386408-39B4-461D-84F4-FFB5710662E2}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NotificationService.Domain", "NotificationService.Domain\NotificationService.Domain.csproj", "{119CBFFB-51F2-427B-B33A-38B75F4F959E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NotificationService.Infrastructure", "NotificationService.Infrastructure\NotificationService.Infrastructure.csproj", "{591A2444-7A5F-48DB-90C1-FB73D44A87C3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "NotificationService.Shared", "NotificationService.Shared\NotificationService.Shared.csproj", "{E5B0E1D0-AF59-4955-8C27-541D12DB02A9}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{33A72E0F-31B6-44EE-BE8A-9918C579A03A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{33A72E0F-31B6-44EE-BE8A-9918C579A03A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{33A72E0F-31B6-44EE-BE8A-9918C579A03A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{33A72E0F-31B6-44EE-BE8A-9918C579A03A}.Release|Any CPU.Build.0 = Release|Any CPU
		{BD386408-39B4-461D-84F4-FFB5710662E2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{BD386408-39B4-461D-84F4-FFB5710662E2}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{BD386408-39B4-461D-84F4-FFB5710662E2}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{BD386408-39B4-461D-84F4-FFB5710662E2}.Release|Any CPU.Build.0 = Release|Any CPU
		{119CBFFB-51F2-427B-B33A-38B75F4F959E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{119CBFFB-51F2-427B-B33A-38B75F4F959E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{119CBFFB-51F2-427B-B33A-38B75F4F959E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{119CBFFB-51F2-427B-B33A-38B75F4F959E}.Release|Any CPU.Build.0 = Release|Any CPU
		{591A2444-7A5F-48DB-90C1-FB73D44A87C3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{591A2444-7A5F-48DB-90C1-FB73D44A87C3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{591A2444-7A5F-48DB-90C1-FB73D44A87C3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{591A2444-7A5F-48DB-90C1-FB73D44A87C3}.Release|Any CPU.Build.0 = Release|Any CPU
		{E5B0E1D0-AF59-4955-8C27-541D12DB02A9}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{E5B0E1D0-AF59-4955-8C27-541D12DB02A9}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{E5B0E1D0-AF59-4955-8C27-541D12DB02A9}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{E5B0E1D0-AF59-4955-8C27-541D12DB02A9}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal

---- File: NotificationService.Api\appsettings.Development.json ----
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=25433;Database=notificationservice;Username=postgres;Password=password"
  },
  "RabbitMQ": {
    "HostName": "localhost",
    "UserName": "guest",
    "Password": "guest"
  },
  "NotificationSettings": {
    "SendGrid": {
      "ApiKey": "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",
      "FromEmail": "notificaciones@shiftwaysolutions.com.do",
      "FromName": "CarDealer Dev"
    },
    "Twilio": {
      "AccountSid": "AC19fec9dd3df70a34f6252c9ef649a532",
      "AuthToken": "2221beebc69b7251062f2b10d7ed75e6",
      "FromNumber": "+13476622382"
    },
    "Firebase": {
      "ServiceAccountKeyPath": "/app/firebase-service-account.json",
      "ProjectId": "cargurus-dev"
    },
    "TemplatesPath": "/app/Templates"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning"
    }
  },
  "AllowedHosts": "*"
}

---- File: NotificationService.Api\appsettings.json ----
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=25433;Database=notificationservice;Username=postgres;Password=password",
    "ErrorServiceConnection": "Host=errorservice-db;Database=errorservice;Username=postgres;Password=password"
  },
  "RabbitMQ": {
    "Host": "rabbitmq",
    "Port": 5672,
    "Username": "guest",
    "Password": "guest",
    "VirtualHost": "/"
  },

  "NotificationService": {
    // Configuración RabbitMQ (debe coincidir con AuthService)
    "EnableRabbitMQ": true,
    "QueueName": "notification-queue",
    "ExchangeName": "notification-exchange",
    "RoutingKey": "notification.auth",
    "EmailQueueName": "notification-email-queue",
    "SmsQueueName": "notification-sms-queue",
    "PushQueueName": "notification-push-queue",
    "RetryDelayMs": 60000,
    "MaxRetryAttempts": 3,
    "PrefetchCount": 10,
    "ConnectionTimeoutMs": 30000,
    "RequestedHeartbeatMs": 60,
    "GlobalQos": false
  },
  "NotificationSettings": {
    "SendGrid": {
      "ApiKey": "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",
      "FromEmail": "notificaciones@shiftwaysolutions.com.do",
      "FromName": "CarDealer Dev"
    },
    "Twilio": {
      "AccountSid": "AC19fec9dd3df70a34f6252c9ef649a532",
      "AuthToken": "2221beebc69b7251062f2b10d7ed75e6",
      "FromNumber": "+13476622382"
    },
    "Firebase": {
      "ServiceAccountKeyPath": "/app/firebase-service-account.json",
      "ProjectId": "cargurus-dev"
    },
    "TemplatesPath": "/app/Templates"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning"
    }
  },
  "AllowedHosts": "*"
}

---- File: NotificationService.Api\appsettings.Production.json ----
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=25433;Database=notificationservice;Username=postgres;Password=password"
  },
  "RabbitMQ": {
    "HostName": "localhost",
    "UserName": "guest",
    "Password": "guest"
  },
  "NotificationSettings": {
    "SendGrid": {
      "ApiKey": "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",
      "FromEmail": "notificaciones@shiftwaysolutions.com.do",
      "FromName": "CarDealer Dev"
    },
    "Twilio": {
      "AccountSid": "AC19fec9dd3df70a34f6252c9ef649a532",
      "AuthToken": "2221beebc69b7251062f2b10d7ed75e6",
      "FromNumber": "+13476622382"
    },
    "Firebase": {
      "ServiceAccountKeyPath": "/app/firebase-service-account.json",
      "ProjectId": "cargurus-dev"
    },
    "TemplatesPath": "/app/Templates"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Warning"
    }
  },
  "AllowedHosts": "*"
}

---- File: NotificationService.Api\Dockerfile.dev ----
FROM mcr.microsoft.com/dotnet/sdk:8.0

# Install debugger with automatic license acceptance
RUN apt-get update \
    && apt-get install -y --no-install-recommends unzip curl procps \
    && curl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l /vsdbg -s

WORKDIR /app

# Copy project files
COPY NotificationService/NotificationService.Api/*.csproj ./NotificationService/NotificationService.Api/
COPY NotificationService/NotificationService.Application/*.csproj ./NotificationService/NotificationService.Application/
COPY NotificationService/NotificationService.Domain/*.csproj ./NotificationService/NotificationService.Domain/
COPY NotificationService/NotificationService.Infrastructure/*.csproj ./NotificationService/NotificationService.Infrastructure/
COPY NotificationService/NotificationService.Shared/*.csproj ./NotificationService/NotificationService.Shared/

# Restore packages
RUN dotnet restore "NotificationService/NotificationService.Api/NotificationService.Api.csproj"

# Copy source code
COPY NotificationService/ ./NotificationService/

# Debug environment
ENV ASPNETCORE_ENVIRONMENT=Development \
    ASPNETCORE_URLS="http://+:80" \
    DOTNET_USE_POLLING_FILE_WATCHER=true

EXPOSE 80
EXPOSE 4022

ENTRYPOINT ["dotnet", "watch", "run", "--project", "NotificationService/NotificationService.Api/NotificationService.Api.csproj", "--urls", "http://0.0.0.0:80"]

---- File: NotificationService.Api\Dockerfile.prod ----

---- File: NotificationService.Api\NotificationService.Api.csproj ----
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <RootNamespace>NotificationService.Api</RootNamespace>
    <AssemblyName>NotificationService.Api</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.11" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.8" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.4.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.0" />
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\AuthService\AuthService.Shared\AuthService.Shared.csproj" />
    <ProjectReference Include="..\NotificationService.Application\NotificationService.Application.csproj" />
    <ProjectReference Include="..\NotificationService.Infrastructure\NotificationService.Infrastructure.csproj" />
    <ProjectReference Include="..\NotificationService.Shared\NotificationService.Shared.csproj" />
    <ProjectReference Include="..\..\ErrorService\ErrorService.Shared\ErrorService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: NotificationService.Api\NotificationService.Api.http ----
@NotificationService_HostAddress = http://localhost:5084

### Health Check
GET {{NotificationService_HostAddress}}/health

### Send Email
POST {{NotificationService_HostAddress}}/api/notifications/email
Content-Type: application/json

{
  "to": "test@example.com",
  "subject": "Test Email",
  "body": "This is a test email from NotificationService",
  "isHtml": true
}

### Send SMS
POST {{NotificationService_HostAddress}}/api/notifications/sms
Content-Type: application/json

{
  "to": "+1234567890",
  "message": "This is a test SMS from NotificationService"
}

### Send Push Notification
POST {{NotificationService_HostAddress}}/api/notifications/push
Content-Type: application/json

{
  "deviceToken": "test-device-token",
  "title": "Test Push",
  "body": "This is a test push notification from NotificationService"
}

### Get Notification Status
GET {{NotificationService_HostAddress}}/api/notifications/{notificationId}/status

---- File: NotificationService.Api\Program.cs ----
using Microsoft.EntityFrameworkCore;
using NotificationService.Infrastructure.Extensions;
using NotificationService.Infrastructure.Persistence;
using Serilog;
using System.Reflection;
using FluentValidation;
using NotificationService.Shared;
using ErrorService.Shared.Extensions;

var builder = WebApplication.CreateBuilder(args);

// Configurar Serilog
Log.Logger = new LoggerConfiguration()
    .Enrich.FromLogContext()
    .WriteTo.Console()
    .CreateLogger();
builder.Host.UseSerilog();

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

builder.Services.AddLogging();

// Simple Health Check
builder.Services.AddHealthChecks();

// ✅ USAR DEPENDENCY INJECTION DE INFRASTRUCTURE (INCLUYE RABBITMQ)
builder.Services.AddInfrastructure(builder.Configuration);

// 1) DbContext del NotificationService
var notificationConn = builder.Configuration.GetConnectionString("DefaultConnection");
Console.WriteLine($"[DEBUG] NotificationService Connection = '{notificationConn}'");
if (string.IsNullOrWhiteSpace(notificationConn))
{
    throw new InvalidOperationException("La cadena DefaultConnection no está configurada.");
}

builder.Services.AddDbContext<ApplicationDbContext>(opts =>
    opts.UseNpgsql(notificationConn)
        .UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking)
);

// 2) Configurar ErrorHandling para NotificationService (SOLO MIDDLEWARE)
builder.Services.AddErrorHandling("NotificationService");

// MediatR - Cargar assemblies de Application
builder.Services.AddMediatR(cfg =>
    cfg.RegisterServicesFromAssembly(Assembly.Load("NotificationService.Application")));

// FluentValidation - Validators
builder.Services.AddValidatorsFromAssembly(Assembly.Load("NotificationService.Application"));

// Configure settings
builder.Services.Configure<NotificationSettings>(
    builder.Configuration.GetSection("NotificationSettings"));

var app = builder.Build();

// **Aplicar migraciones para NotificationService**
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;
    try
    {
        // Migraciones del NotificationService
        var notificationContext = services.GetRequiredService<ApplicationDbContext>();
        notificationContext.Database.Migrate();
        Log.Information("NotificationService database migrations applied successfully.");
    }
    catch (Exception ex)
    {
        var logger = services.GetRequiredService<ILogger<Program>>();
        logger.LogError(ex, "An error occurred while migrating the database.");
    }
}

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

// ✅ SOLO MIDDLEWARE DE ERROR SERVICE - NO INYECCIÓN DIRECTA
app.UseMiddleware<ErrorService.Shared.Middleware.ResponseCaptureMiddleware>();
app.UseErrorHandling();

app.UseAuthorization();

// Health check endpoint
app.MapGet("/health", () => Results.Ok("NotificationService is healthy"));

app.MapControllers();

Log.Information("NotificationService starting up with ErrorService middleware and RabbitMQ Consumer...");
app.Run();

---- File: NotificationService.Api\Controllers\NotificationsController.cs ----
// NotificationService.Api\Controllers\NotificationsController.cs
using MediatR;
using Microsoft.AspNetCore.Mvc;
using NotificationService.Application.DTOs;
using NotificationService.Application.UseCases.SendEmailNotification;
using NotificationService.Application.UseCases.SendSmsNotification;
using NotificationService.Application.UseCases.SendPushNotification;
using NotificationService.Application.UseCases.GetNotificationStatus;

namespace NotificationService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class NotificationsController : ControllerBase
{
    private readonly IMediator _mediator;

    public NotificationsController(IMediator mediator)
    {
        _mediator = mediator;
    }

    [HttpPost("email")]
    public async Task<ActionResult<SendEmailNotificationResponse>> SendEmail([FromBody] SendEmailNotificationRequest request)
    {
        var command = new SendEmailNotificationCommand(request);
        var result = await _mediator.Send(command);
        return Ok(result);
    }

    [HttpPost("sms")]
    public async Task<ActionResult<SendSmsNotificationResponse>> SendSms([FromBody] SendSmsNotificationRequest request)
    {
        var command = new SendSmsNotificationCommand(request);
        var result = await _mediator.Send(command);
        return Ok(result);
    }

    [HttpPost("push")]
    public async Task<ActionResult<SendPushNotificationResponse>> SendPush([FromBody] SendPushNotificationRequest request)
    {
        var command = new SendPushNotificationCommand(request);
        var result = await _mediator.Send(command);
        return Ok(result);
    }

    [HttpGet("{id:guid}/status")]
    public async Task<ActionResult<GetNotificationStatusResponse>> GetStatus(Guid id)
    {
        // ✅ Usar el namespace completo para evitar ambigüedad
        var query = new Application.UseCases.GetNotificationStatus.GetNotificationStatusQuery(id);
        var result = await _mediator.Send(query);
        return Ok(result);
    }
}

---- File: NotificationService.Api\Controllers\WebhooksController.cs ----

// WebhooksController.cs
using Microsoft.AspNetCore.Mvc;

namespace NotificationService.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class WebhooksController : ControllerBase
{
    [HttpPost("sendgrid")]
    public IActionResult SendGridWebhook()
    {
        // Process SendGrid webhook for email events
        return Ok();
    }

    [HttpPost("twilio")]
    public IActionResult TwilioWebhook()
    {
        // Process Twilio webhook for SMS events
        return Ok();
    }
}

---- File: NotificationService.Application\NotificationService.Application.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <RootNamespace>NotificationService.Application</RootNamespace>
    <AssemblyName>NotificationService.Application</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="FluentValidation" Version="11.9.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.2" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\NotificationService.Domain\NotificationService.Domain.csproj" />
    <ProjectReference Include="..\..\ErrorService\ErrorService.Shared\ErrorService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: NotificationService.Application\DTOs\GetNotificationsRequest.cs ----
namespace NotificationService.Application.DTOs;


public record GetNotificationsRequest(
    string? Recipient = null,
    string? Type = null,
    string? Status = null,
    DateTime? From = null,
    DateTime? To = null,
    int Page = 1,
    int PageSize = 50
);

---- File: NotificationService.Application\DTOs\GetNotificationsResponse.cs ----
using System.Collections.Generic;

namespace NotificationService.Application.DTOs;

public record GetNotificationsResponse(
    List<NotificationItemDto> Notifications,
    int TotalCount,
    int Page,
    int PageSize
);

public record NotificationItemDto(
    Guid Id,
    string Type,
    string Recipient,
    string Subject,
    string Status,
    DateTime CreatedAt,
    DateTime? SentAt,
    string? ErrorMessage
);

---- File: NotificationService.Application\DTOs\GetNotificationStatsRequest.cs ----
namespace NotificationService.Application.DTOs;

public record GetNotificationStatsRequest(
    DateTime? From = null,
    DateTime? To = null
);

---- File: NotificationService.Application\DTOs\GetNotificationStatsResponse.cs ----
using System.Collections.Generic;

namespace NotificationService.Application.DTOs;

public record GetNotificationStatsResponse(
    int TotalNotifications,
    int SentLast24Hours,
    int SentLast7Days,
    Dictionary<string, int> NotificationsByType,
    Dictionary<string, int> NotificationsByStatus
);

---- File: NotificationService.Application\DTOs\GetNotificationStatusRequest.cs ----
using MediatR;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.DTOs;

public record GetNotificationStatusRequest(Guid NotificationId);

public record GetNotificationStatusQuery(Guid NotificationId) 
    : IRequest<GetNotificationStatusResponse>;

---- File: NotificationService.Application\DTOs\GetNotificationStatusResponse.cs ----
namespace NotificationService.Application.DTOs;

public record GetNotificationStatusResponse(
    Guid NotificationId,
    string Status,
    DateTime? SentAt,
    string? ErrorMessage
);

---- File: NotificationService.Application\DTOs\SendEmailNotificationRequest.cs ----
using System.Collections.Generic;

namespace NotificationService.Application.DTOs;

public record SendEmailNotificationRequest(
    string To,
    string Subject,
    string Body,
    bool IsHtml = true,
    Dictionary<string, object>? Metadata = null
);

---- File: NotificationService.Application\DTOs\SendEmailNotificationResponse.cs ----
namespace NotificationService.Application.DTOs;

public record SendEmailNotificationResponse(
    Guid NotificationId,
    string Status,
    string Message
);

---- File: NotificationService.Application\DTOs\SendPushNotificationRequest.cs ----
using System.Collections.Generic;

namespace NotificationService.Application.DTOs;

public record SendPushNotificationRequest(
    string DeviceToken,
    string Title,
    string Body,
    object? Data = null,
    Dictionary<string, object>? Metadata = null
);

---- File: NotificationService.Application\DTOs\SendPushNotificationResponse.cs ----
namespace NotificationService.Application.DTOs;

public record SendPushNotificationResponse(
    Guid NotificationId,
    string Status,
    string Message
);

---- File: NotificationService.Application\DTOs\SendSmsNotificationRequest.cs ----
using System.Collections.Generic;

namespace NotificationService.Application.DTOs;

public record SendSmsNotificationRequest(
    string To,
    string Message,
    Dictionary<string, object>? Metadata = null
);

---- File: NotificationService.Application\DTOs\SendSmsNotificationResponse.cs ----
namespace NotificationService.Application.DTOs;

public record SendSmsNotificationResponse(
    Guid NotificationId,
    string Status,
    string Message
);

---- File: NotificationService.Application\UseCases\GetNotifications\GetNotificationsQuery.cs ----
using MediatR;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.GetNotifications;

public record GetNotificationsQuery(GetNotificationsRequest Request) 
    : IRequest<GetNotificationsResponse>;

---- File: NotificationService.Application\UseCases\GetNotifications\GetNotificationsQueryHandler.cs ----
using MediatR;
using NotificationService.Domain.Interfaces.Repositories;
using NotificationService.Domain.Enums;
using ErrorService.Shared.Exceptions;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.GetNotifications;

public class GetNotificationsQueryHandler
    : IRequestHandler<GetNotificationsQuery, GetNotificationsResponse>
{
    private readonly INotificationRepository _notificationRepository;

    public GetNotificationsQueryHandler(INotificationRepository notificationRepository)
    {
        _notificationRepository = notificationRepository;
    }

    public async Task<GetNotificationsResponse> Handle(
        GetNotificationsQuery query,
        CancellationToken cancellationToken)
    {
        var request = query.Request;

        try
        {
            // Obtener notificaciones paginadas
            var notifications = await _notificationRepository.GetNotificationsWithPaginationAsync(
                request.Page,
                request.PageSize
            );

            // Aplicar filtros
            var filteredNotifications = notifications
                .Where(n => string.IsNullOrEmpty(request.Recipient) || n.Recipient.Contains(request.Recipient))
                .Where(n => string.IsNullOrEmpty(request.Type) || n.Type.ToString() == request.Type)
                .Where(n => string.IsNullOrEmpty(request.Status) || n.Status.ToString() == request.Status)
                .Where(n => !request.From.HasValue || n.CreatedAt >= request.From.Value)
                .Where(n => !request.To.HasValue || n.CreatedAt <= request.To.Value)
                .ToList();

            var notificationDtos = filteredNotifications.Select(n => new NotificationItemDto(
                n.Id,
                n.Type.ToString(),
                n.Recipient,
                n.Subject,
                n.Status.ToString(),
                n.CreatedAt,
                n.SentAt,
                n.ErrorMessage
            )).ToList();

            return new GetNotificationsResponse(
                notificationDtos,
                notificationDtos.Count,
                request.Page,
                request.PageSize
            );
        }
        catch (Exception)
        {
            throw new ServiceUnavailableException("An error occurred while retrieving notifications");
        }
    }
}

---- File: NotificationService.Application\UseCases\GetNotifications\GetNotificationsQueryValidator.cs ----
using FluentValidation;
using NotificationService.Application.UseCases.GetNotifications;

namespace NotificationService.Application.UseCases.GetNotifications;

public class GetNotificationsQueryValidator : AbstractValidator<GetNotificationsQuery>
{
    public GetNotificationsQueryValidator()
    {
        RuleFor(x => x.Request.Page)
            .GreaterThan(0).WithMessage("Page number must be greater than 0");

        RuleFor(x => x.Request.PageSize)
            .InclusiveBetween(1, 100).WithMessage("Page size must be between 1 and 100");

        RuleFor(x => x.Request)
            .Must(x => !x.From.HasValue || !x.To.HasValue || x.From <= x.To)
            .WithMessage("From date cannot be after To date");
    }
}

---- File: NotificationService.Application\UseCases\GetNotificationStats\GetNotificationStatsQuery.cs ----
using MediatR;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.GetNotificationStats;

public record GetNotificationStatsQuery(GetNotificationStatsRequest Request) 
    : IRequest<GetNotificationStatsResponse>;

---- File: NotificationService.Application\UseCases\GetNotificationStats\GetNotificationStatsQueryHandler.cs ----
using MediatR;
using NotificationService.Domain.Interfaces.Repositories;
using NotificationService.Domain.Enums;
using ErrorService.Shared.Exceptions;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.GetNotificationStats;

public class GetNotificationStatsQueryHandler
    : IRequestHandler<GetNotificationStatsQuery, GetNotificationStatsResponse>
{
    private readonly INotificationRepository _notificationRepository;

    public GetNotificationStatsQueryHandler(INotificationRepository notificationRepository)
    {
        _notificationRepository = notificationRepository;
    }

    public async Task<GetNotificationStatsResponse> Handle(
        GetNotificationStatsQuery query,
        CancellationToken cancellationToken)
    {
        var request = query.Request;

        try
        {
            // Obtener estadísticas del repositorio
            var totalNotifications = await _notificationRepository.GetTotalCountAsync();

            var last24Hours = await _notificationRepository.GetByDateRangeAsync(
                DateTime.UtcNow.AddHours(-24),
                DateTime.UtcNow
            );
            var sentLast24Hours = last24Hours.Count(n => n.Status == NotificationStatus.Sent);

            var last7Days = await _notificationRepository.GetByDateRangeAsync(
                DateTime.UtcNow.AddDays(-7),
                DateTime.UtcNow
            );
            var sentLast7Days = last7Days.Count(n => n.Status == NotificationStatus.Sent);

            // Obtener distribución por tipo y estado
            var allNotifications = await _notificationRepository.GetRecentNotificationsAsync(1000);

            var byType = allNotifications
                .GroupBy(n => n.Type)
                .ToDictionary(g => g.Key.ToString(), g => g.Count());

            var byStatus = allNotifications
                .GroupBy(n => n.Status)
                .ToDictionary(g => g.Key.ToString(), g => g.Count());

            return new GetNotificationStatsResponse(
                totalNotifications,
                sentLast24Hours,
                sentLast7Days,
                byType,
                byStatus
            );
        }
        catch (Exception)
        {
            throw new ServiceUnavailableException("An error occurred while retrieving notification statistics");
        }
    }
}

---- File: NotificationService.Application\UseCases\GetNotificationStatus\GetNotificationStatusQuery.cs ----
using MediatR;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.GetNotificationStatus;

public record GetNotificationStatusQuery(Guid NotificationId) 
    : IRequest<GetNotificationStatusResponse>;

---- File: NotificationService.Application\UseCases\GetNotificationStatus\GetNotificationStatusQueryHandler.cs ----
using MediatR;
using NotificationService.Domain.Interfaces.Repositories;
using ErrorService.Shared.Exceptions;
using NotificationService.Application.DTOs; // ✅ Agregar este using

namespace NotificationService.Application.UseCases.GetNotificationStatus;

public class GetNotificationStatusQueryHandler
    : IRequestHandler<GetNotificationStatusQuery, GetNotificationStatusResponse>
{
    private readonly INotificationRepository _notificationRepository;

    public GetNotificationStatusQueryHandler(INotificationRepository notificationRepository)
    {
        _notificationRepository = notificationRepository;
    }

    public async Task<GetNotificationStatusResponse> Handle(
        GetNotificationStatusQuery query,
        CancellationToken cancellationToken)
    {
        var notification = await _notificationRepository.GetByIdAsync(query.NotificationId);

        if (notification == null)
            throw new NotFoundException($"Notification with ID {query.NotificationId} not found");

        return new GetNotificationStatusResponse(
            notification.Id,
            notification.Status.ToString(),
            notification.SentAt,
            notification.ErrorMessage
        );
    }
}

---- File: NotificationService.Application\UseCases\GetNotificationStatus\GetNotificationStatusQueryValidator.cs ----
using FluentValidation;
using NotificationService.Application.UseCases.GetNotificationStatus;

namespace NotificationService.Application.UseCases.GetNotificationStatus;

public class GetNotificationStatusQueryValidator : AbstractValidator<GetNotificationStatusQuery>
{
    public GetNotificationStatusQueryValidator()
    {
        RuleFor(x => x.NotificationId)
            .NotEmpty().WithMessage("Notification ID is required");
    }
}

---- File: NotificationService.Application\UseCases\ProcessNotificationQueue\ProcessNotificationQueueCommand.cs ----
using MediatR;

namespace NotificationService.Application.UseCases.ProcessNotificationQueue;

public record ProcessNotificationQueueCommand : IRequest;

---- File: NotificationService.Application\UseCases\ProcessNotificationQueue\ProcessNotificationQueueCommandHandler.cs ----
using MediatR;
using NotificationService.Domain.Interfaces.Repositories;
using NotificationService.Domain.Interfaces.External;
using NotificationService.Domain.Enums;
using Microsoft.Extensions.Logging;
using ErrorService.Shared.Exceptions;
using NotificationService.Domain.Entities;

namespace NotificationService.Application.UseCases.ProcessNotificationQueue;

public class ProcessNotificationQueueCommandHandler
    : IRequestHandler<ProcessNotificationQueueCommand>
{
    private readonly INotificationQueueRepository _queueRepository;
    private readonly INotificationRepository _notificationRepository;
    private readonly INotificationLogRepository _logRepository;
    private readonly IEmailProvider _emailProvider;
    private readonly ISmsProvider _smsProvider;
    private readonly IPushNotificationProvider _pushProvider;
    private readonly ILogger<ProcessNotificationQueueCommandHandler> _logger;

    public ProcessNotificationQueueCommandHandler(
        INotificationQueueRepository queueRepository,
        INotificationRepository notificationRepository,
        INotificationLogRepository logRepository,
        IEmailProvider emailProvider,
        ISmsProvider smsProvider,
        IPushNotificationProvider pushProvider,
        ILogger<ProcessNotificationQueueCommandHandler> logger)
    {
        _queueRepository = queueRepository;
        _notificationRepository = notificationRepository;
        _logRepository = logRepository;
        _emailProvider = emailProvider;
        _smsProvider = smsProvider;
        _pushProvider = pushProvider;
        _logger = logger;
    }

    public async Task Handle(ProcessNotificationQueueCommand request, CancellationToken cancellationToken)
    {
        _logger.LogInformation("Starting queue processing");

        try
        {
            var pendingQueues = await _queueRepository.GetPendingAsync();

            foreach (var queue in pendingQueues)
            {
                try
                {
                    _logger.LogInformation("Processing queue item {QueueId} for notification {NotificationId}",
                        queue.Id, queue.NotificationId);

                    queue.MarkAsProcessing();
                    await _queueRepository.UpdateAsync(queue);

                    var notification = await _notificationRepository.GetByIdAsync(queue.NotificationId);
                    if (notification == null)
                    {
                        _logger.LogWarning("Notification {NotificationId} not found for queue item {QueueId}",
                            queue.NotificationId, queue.Id);
                        continue;
                    }

                    var (success, messageId, error) = await ProcessNotificationAsync(notification);

                    if (success)
                    {
                        notification.MarkAsSent();
                        await _logRepository.AddAsync(NotificationLog.CreateSent(notification.Id, messageId));
                        queue.MarkAsCompleted();
                        _logger.LogInformation("Successfully processed notification {NotificationId}", notification.Id);
                    }
                    else
                    {
                        if (notification.CanRetry())
                        {
                            notification.MarkAsFailed(error ?? "Unknown error");
                            queue.MarkAsFailed(error ?? "Unknown error");
                            _logger.LogWarning("Failed to process notification {NotificationId}, will retry: {Error}",
                                notification.Id, error);
                        }
                        else
                        {
                            notification.MarkAsFailed(error ?? "Unknown error");
                            queue.MarkAsFailed(error ?? "Unknown error");
                            _logger.LogError("Failed to process notification {NotificationId} after retries: {Error}",
                                notification.Id, error);
                        }

                        await _logRepository.AddAsync(NotificationLog.CreateFailed(notification.Id, error ?? "Unknown error"));
                    }

                    await _notificationRepository.UpdateAsync(notification);
                    await _queueRepository.UpdateAsync(queue);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error processing queue item {QueueId}", queue.Id);
                    queue.MarkAsFailed(ex.Message);
                    await _queueRepository.UpdateAsync(queue);
                }
            }

            _logger.LogInformation("Queue processing completed");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during queue processing");
            throw new ServiceUnavailableException("An unexpected error occurred during queue processing");
        }
    }

    private async Task<(bool success, string? messageId, string? error)> ProcessNotificationAsync(
        NotificationService.Domain.Entities.Notification notification)
    {
        try
        {
            return notification.Type switch
            {
                NotificationType.Email => await _emailProvider.SendAsync(
                    notification.Recipient,
                    notification.Subject,
                    notification.Content,
                    true,
                    notification.Metadata
                ),
                NotificationType.Sms => await _smsProvider.SendAsync(
                    notification.Recipient,
                    notification.Content,
                    notification.Metadata
                ),
                NotificationType.Push => await _pushProvider.SendAsync(
                    notification.Recipient,
                    notification.Subject,
                    notification.Content,
                    null,
                    notification.Metadata
                ),
                _ => (false, null, $"Unsupported notification type: {notification.Type}")
            };
        }
        catch (Exception ex)
        {
            return (false, null, ex.Message);
        }
    }
}

---- File: NotificationService.Application\UseCases\SendEmailNotification\SendEmailNotificationCommand.cs ----
using MediatR;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendEmailNotification;

public record SendEmailNotificationCommand(SendEmailNotificationRequest Request) 
    : IRequest<SendEmailNotificationResponse>;

---- File: NotificationService.Application\UseCases\SendEmailNotification\SendEmailNotificationCommandHandler.cs ----
// NotificationService.Application\UseCases\SendEmailNotification\SendEmailNotificationCommandHandler.cs
using MediatR;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Interfaces.Repositories;
using NotificationService.Domain.Interfaces.External;
using Microsoft.Extensions.Logging;
using ErrorService.Shared.Exceptions;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendEmailNotification;

public class SendEmailNotificationCommandHandler
    : IRequestHandler<SendEmailNotificationCommand, SendEmailNotificationResponse>
{
    private readonly INotificationRepository _notificationRepository;
    private readonly INotificationLogRepository _logRepository;
    private readonly IEmailProvider _emailProvider;
    private readonly ILogger<SendEmailNotificationCommandHandler> _logger;

    public SendEmailNotificationCommandHandler(
        INotificationRepository notificationRepository,
        INotificationLogRepository logRepository,
        IEmailProvider emailProvider,
        ILogger<SendEmailNotificationCommandHandler> logger)
    {
        _notificationRepository = notificationRepository;
        _logRepository = logRepository;
        _emailProvider = emailProvider;
        _logger = logger;
    }

    public async Task<SendEmailNotificationResponse> Handle(
        SendEmailNotificationCommand command,
        CancellationToken cancellationToken)
    {
        var request = command.Request;

        _logger.LogInformation("Creating email notification for {To}", request.To);

        try
        {
            // Crear la notificación
            var notification = Notification.CreateEmailNotification(
                request.To,
                request.Subject,
                request.Body,
                metadata: request.Metadata
            );

            await _notificationRepository.AddAsync(notification);

            _logger.LogInformation("Notification {NotificationId} created, sending via {Provider}",
                notification.Id, _emailProvider.ProviderName);

            // Enviar el email
            var (success, messageId, error) = await _emailProvider.SendAsync(
                request.To,
                request.Subject,
                request.Body,
                request.IsHtml,
                request.Metadata
            );

            if (success)
            {
                notification.MarkAsSent();
                await _logRepository.AddAsync(NotificationLog.CreateSent(notification.Id, messageId));
                _logger.LogInformation("Email notification {NotificationId} sent successfully", notification.Id);
            }
            else
            {
                notification.MarkAsFailed(error ?? "Unknown error");
                await _logRepository.AddAsync(NotificationLog.CreateFailed(notification.Id, error ?? "Unknown error"));
                _logger.LogWarning("Failed to send email notification {NotificationId}: {Error}",
                    notification.Id, error);

                // ✅ EL MIDDLEWARE CAPTURARÁ AUTOMÁTICAMENTE ESTA EXCEPCIÓN
                throw new ServiceUnavailableException($"Failed to send email: {error}");
            }

            await _notificationRepository.UpdateAsync(notification);

            return new SendEmailNotificationResponse(
                notification.Id,
                notification.Status.ToString(),
                success ? "Email sent successfully" : error ?? "Failed to send email"
            );
        }
        catch (AppException)
        {
            throw; // El middleware capturará estas excepciones
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error sending email notification to {To}", request.To);

            throw new ServiceUnavailableException("An unexpected error occurred while sending the email");
        }
    }
}

---- File: NotificationService.Application\UseCases\SendEmailNotification\SendEmailNotificationCommandValidator.cs ----
using FluentValidation;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendEmailNotification;

public class SendEmailNotificationCommandValidator : AbstractValidator<SendEmailNotificationCommand>
{
    public SendEmailNotificationCommandValidator()
    {
        RuleFor(x => x.Request.To)
            .NotEmpty().WithMessage("Recipient email is required")
            .EmailAddress().WithMessage("Invalid email address format");

        RuleFor(x => x.Request.Subject)
            .NotEmpty().WithMessage("Subject is required")
            .MaximumLength(200).WithMessage("Subject cannot exceed 200 characters");

        RuleFor(x => x.Request.Body)
            .NotEmpty().WithMessage("Body is required");
    }
}

---- File: NotificationService.Application\UseCases\SendPushNotification\SendPushNotificationCommand.cs ----
using MediatR;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendPushNotification;

public record SendPushNotificationCommand(SendPushNotificationRequest Request) 
    : IRequest<SendPushNotificationResponse>;

---- File: NotificationService.Application\UseCases\SendPushNotification\SendPushNotificationCommandHandler.cs ----
using MediatR;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Interfaces.Repositories;
using NotificationService.Domain.Interfaces.External;
using Microsoft.Extensions.Logging;
using ErrorService.Shared.Exceptions;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendPushNotification;

public class SendPushNotificationCommandHandler
    : IRequestHandler<SendPushNotificationCommand, SendPushNotificationResponse>
{
    private readonly INotificationRepository _notificationRepository;
    private readonly INotificationLogRepository _logRepository;
    private readonly IPushNotificationProvider _pushProvider;
    private readonly ILogger<SendPushNotificationCommandHandler> _logger;

    public SendPushNotificationCommandHandler(
        INotificationRepository notificationRepository,
        INotificationLogRepository logRepository,
        IPushNotificationProvider pushProvider,
        ILogger<SendPushNotificationCommandHandler> logger)
    {
        _notificationRepository = notificationRepository;
        _logRepository = logRepository;
        _pushProvider = pushProvider;
        _logger = logger;
    }

    public async Task<SendPushNotificationResponse> Handle(
        SendPushNotificationCommand command,
        CancellationToken cancellationToken)
    {
        var request = command.Request;

        _logger.LogInformation("Creating push notification for device {DeviceToken}", request.DeviceToken);

        try
        {
            var notification = Notification.CreatePushNotification(
                request.DeviceToken,
                request.Title,
                request.Body,
                metadata: request.Metadata
            );

            await _notificationRepository.AddAsync(notification);

            _logger.LogInformation("Push notification {NotificationId} created, sending via {Provider}",
                notification.Id, _pushProvider.ProviderName);

            var (success, messageId, error) = await _pushProvider.SendAsync(
                request.DeviceToken,
                request.Title,
                request.Body,
                request.Data,
                request.Metadata
            );

            if (success)
            {
                notification.MarkAsSent();
                await _logRepository.AddAsync(NotificationLog.CreateSent(notification.Id, messageId));
                _logger.LogInformation("Push notification {NotificationId} sent successfully", notification.Id);
            }
            else
            {
                notification.MarkAsFailed(error ?? "Unknown error");
                await _logRepository.AddAsync(NotificationLog.CreateFailed(notification.Id, error ?? "Unknown error"));
                _logger.LogWarning("Failed to send push notification {NotificationId}: {Error}",
                    notification.Id, error);
                throw new ServiceUnavailableException($"Failed to send push notification: {error}");
            }

            await _notificationRepository.UpdateAsync(notification);

            return new SendPushNotificationResponse(
                notification.Id,
                notification.Status.ToString(),
                success ? "Push notification sent successfully" : error ?? "Failed to send push notification"
            );
        }
        catch (AppException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error sending push notification to device {DeviceToken}", request.DeviceToken);
            throw new ServiceUnavailableException("An unexpected error occurred while sending the push notification");
        }
    }
}

---- File: NotificationService.Application\UseCases\SendPushNotification\SendPushNotificationCommandValidator.cs ----
using FluentValidation;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendPushNotification;

public class SendPushNotificationCommandValidator : AbstractValidator<SendPushNotificationCommand>
{
    public SendPushNotificationCommandValidator()
    {
        RuleFor(x => x.Request.DeviceToken)
            .NotEmpty().WithMessage("Device token is required");

        RuleFor(x => x.Request.Title)
            .NotEmpty().WithMessage("Title is required")
            .MaximumLength(100).WithMessage("Title cannot exceed 100 characters");

        RuleFor(x => x.Request.Body)
            .NotEmpty().WithMessage("Body is required")
            .MaximumLength(200).WithMessage("Body cannot exceed 200 characters");
    }
}

---- File: NotificationService.Application\UseCases\SendSmsNotification\SendSmsNotificationCommand.cs ----
using MediatR;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendSmsNotification;

public record SendSmsNotificationCommand(SendSmsNotificationRequest Request) 
    : IRequest<SendSmsNotificationResponse>;

---- File: NotificationService.Application\UseCases\SendSmsNotification\SendSmsNotificationCommandHandler.cs ----
using MediatR;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Interfaces.Repositories;
using NotificationService.Domain.Interfaces.External;
using Microsoft.Extensions.Logging;
using ErrorService.Shared.Exceptions;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendSmsNotification;

public class SendSmsNotificationCommandHandler
    : IRequestHandler<SendSmsNotificationCommand, SendSmsNotificationResponse>
{
    private readonly INotificationRepository _notificationRepository;
    private readonly INotificationLogRepository _logRepository;
    private readonly ISmsProvider _smsProvider;
    private readonly ILogger<SendSmsNotificationCommandHandler> _logger;

    public SendSmsNotificationCommandHandler(
        INotificationRepository notificationRepository,
        INotificationLogRepository logRepository,
        ISmsProvider smsProvider,
        ILogger<SendSmsNotificationCommandHandler> logger)
    {
        _notificationRepository = notificationRepository;
        _logRepository = logRepository;
        _smsProvider = smsProvider;
        _logger = logger;
    }

    public async Task<SendSmsNotificationResponse> Handle(
        SendSmsNotificationCommand command,
        CancellationToken cancellationToken)
    {
        var request = command.Request;

        _logger.LogInformation("Creating SMS notification for {To}", request.To);

        try
        {
            var notification = Notification.CreateSmsNotification(
                request.To,
                request.Message,
                metadata: request.Metadata
            );

            await _notificationRepository.AddAsync(notification);

            _logger.LogInformation("SMS notification {NotificationId} created, sending via {Provider}",
                notification.Id, _smsProvider.ProviderName);

            var (success, messageId, error) = await _smsProvider.SendAsync(
                request.To,
                request.Message,
                request.Metadata
            );

            if (success)
            {
                notification.MarkAsSent();
                await _logRepository.AddAsync(NotificationLog.CreateSent(notification.Id, messageId));
                _logger.LogInformation("SMS notification {NotificationId} sent successfully", notification.Id);
            }
            else
            {
                notification.MarkAsFailed(error ?? "Unknown error");
                await _logRepository.AddAsync(NotificationLog.CreateFailed(notification.Id, error ?? "Unknown error"));
                _logger.LogWarning("Failed to send SMS notification {NotificationId}: {Error}",
                    notification.Id, error);
                throw new ServiceUnavailableException($"Failed to send SMS: {error}");
            }

            await _notificationRepository.UpdateAsync(notification);

            return new SendSmsNotificationResponse(
                notification.Id,
                notification.Status.ToString(),
                success ? "SMS sent successfully" : error ?? "Failed to send SMS"
            );
        }
        catch (AppException)
        {
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error sending SMS notification to {To}", request.To);
            throw new ServiceUnavailableException("An unexpected error occurred while sending the SMS");
        }
    }
}

---- File: NotificationService.Application\UseCases\SendSmsNotification\SendSmsNotificationCommandValidator.cs ----
using FluentValidation;
using NotificationService.Application.DTOs;

namespace NotificationService.Application.UseCases.SendSmsNotification;

public class SendSmsNotificationCommandValidator : AbstractValidator<SendSmsNotificationCommand>
{
    public SendSmsNotificationCommandValidator()
    {
        RuleFor(x => x.Request.To)
            .NotEmpty().WithMessage("Recipient phone number is required");

        RuleFor(x => x.Request.Message)
            .NotEmpty().WithMessage("Message is required")
            .MaximumLength(160).WithMessage("Message cannot exceed 160 characters");
    }
}

---- File: NotificationService.Domain\NotificationService.Domain.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MediatR.Contracts" Version="1.0.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\AuthService\AuthService.Shared\AuthService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: NotificationService.Domain\Entities\Notification.cs ----
using NotificationService.Domain.Enums;
using System.Text.Json;

namespace NotificationService.Domain.Entities;

public class Notification
{
    public Guid Id { get; set; }
    public NotificationType Type { get; set; }
    public string Recipient { get; set; } = string.Empty;
    public string Subject { get; set; } = string.Empty;
    public string Content { get; set; } = string.Empty;
    public NotificationStatus Status { get; set; }
    public NotificationProvider Provider { get; set; }
    public PriorityLevel Priority { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? SentAt { get; set; }
    public int RetryCount { get; set; }
    public string? ErrorMessage { get; set; }
    public string? TemplateName { get; set; }
    public Dictionary<string, object>? Metadata { get; set; }

    // Constructor
    public Notification()
    {
        Id = Guid.NewGuid();
        CreatedAt = DateTime.UtcNow;
        Status = NotificationStatus.Pending;
        Priority = PriorityLevel.Medium;
        RetryCount = 0;
        Metadata = new Dictionary<string, object>();
    }

    // Factory methods
    public static Notification CreateEmailNotification(string to, string subject, string body, 
        NotificationProvider provider = NotificationProvider.SendGrid, 
        PriorityLevel priority = PriorityLevel.Medium,
        Dictionary<string, object>? metadata = null)
    {
        return new Notification
        {
            Type = NotificationType.Email,
            Recipient = to,
            Subject = subject,
            Content = body,
            Provider = provider,
            Priority = priority,
            Metadata = metadata ?? new Dictionary<string, object>()
        };
    }

    public static Notification CreateSmsNotification(string to, string message,
        NotificationProvider provider = NotificationProvider.Twilio,
        PriorityLevel priority = PriorityLevel.Medium,
        Dictionary<string, object>? metadata = null)
    {
        return new Notification
        {
            Type = NotificationType.Sms,
            Recipient = to,
            Content = message,
            Provider = provider,
            Priority = priority,
            Metadata = metadata ?? new Dictionary<string, object>()
        };
    }

    public static Notification CreatePushNotification(string deviceToken, string title, string body,
        NotificationProvider provider = NotificationProvider.Firebase,
        PriorityLevel priority = PriorityLevel.Medium,
        Dictionary<string, object>? metadata = null)
    {
        return new Notification
        {
            Type = NotificationType.Push,
            Recipient = deviceToken,
            Subject = title,
            Content = body,
            Provider = provider,
            Priority = priority,
            Metadata = metadata ?? new Dictionary<string, object>()
        };
    }

    // Business methods
    public void MarkAsSent()
    {
        Status = NotificationStatus.Sent;
        SentAt = DateTime.UtcNow;
        ErrorMessage = null;
    }

    public void MarkAsFailed(string errorMessage)
    {
        Status = NotificationStatus.Failed;
        ErrorMessage = errorMessage;
        RetryCount++;
    }

    public void MarkAsDelivered()
    {
        Status = NotificationStatus.Delivered;
    }

    public bool CanRetry()
    {
        return Status == NotificationStatus.Failed && RetryCount < 3;
    }

    public void UpdateMetadata(string key, object value)
    {
        Metadata ??= new Dictionary<string, object>();
        Metadata[key] = value;
    }
}

---- File: NotificationService.Domain\Entities\NotificationLog.cs ----
using NotificationService.Domain.Enums;
using System.Text.Json;

namespace NotificationService.Domain.Entities;

public class NotificationLog
{
    public Guid Id { get; set; }
    public Guid NotificationId { get; set; }
    public Notification Notification { get; set; } = null!;
    public string Action { get; set; } = string.Empty;
    public string? Details { get; set; }
    public string? ErrorMessage { get; set; }
    public DateTime Timestamp { get; set; }
    public string? ProviderResponse { get; set; }
    public string? ProviderMessageId { get; set; }
    public decimal? Cost { get; set; }
    public string? IpAddress { get; set; }
    public string? UserAgent { get; set; }
    public Dictionary<string, object>? Metadata { get; set; }

    // Constructor
    public NotificationLog()
    {
        Id = Guid.NewGuid();
        Timestamp = DateTime.UtcNow;
    }

    // Factory methods
    public static NotificationLog CreateSent(Guid notificationId, string? providerMessageId = null, 
        string? providerResponse = null, decimal? cost = null)
    {
        return new NotificationLog
        {
            NotificationId = notificationId,
            Action = "SENT",
            Details = "Notification sent successfully",
            ProviderMessageId = providerMessageId,
            ProviderResponse = providerResponse,
            Cost = cost
        };
    }

    public static NotificationLog CreateFailed(Guid notificationId, string errorMessage, 
        string? providerResponse = null)
    {
        return new NotificationLog
        {
            NotificationId = notificationId,
            Action = "FAILED",
            ErrorMessage = errorMessage,
            ProviderResponse = providerResponse,
            Details = "Failed to send notification"
        };
    }

    public static NotificationLog CreateDelivered(Guid notificationId, string? providerResponse = null)
    {
        return new NotificationLog
        {
            NotificationId = notificationId,
            Action = "DELIVERED",
            Details = "Notification delivered to recipient",
            ProviderResponse = providerResponse
        };
    }

    public static NotificationLog CreateOpened(Guid notificationId, string? ipAddress = null, 
        string? userAgent = null)
    {
        return new NotificationLog
        {
            NotificationId = notificationId,
            Action = "OPENED",
            Details = "Notification was opened by recipient",
            IpAddress = ipAddress,
            UserAgent = userAgent
        };
    }

    public static NotificationLog CreateClicked(Guid notificationId, string linkUrl, 
        string? ipAddress = null, string? userAgent = null)
    {
        return new NotificationLog
        {
            NotificationId = notificationId,
            Action = "CLICKED",
            Details = $"Recipient clicked link: {linkUrl}",
            IpAddress = ipAddress,
            UserAgent = userAgent
        };
    }

    // Business methods
    public bool IsSuccess()
    {
        return Action == "SENT" || Action == "DELIVERED";
    }

    public bool IsFailure()
    {
        return Action == "FAILED";
    }

    public void UpdateDetails(string details)
    {
        Details = details;
        Timestamp = DateTime.UtcNow;
    }
}

---- File: NotificationService.Domain\Entities\NotificationQueue.cs ----
using NotificationService.Domain.Enums;

namespace NotificationService.Domain.Entities;

public class NotificationQueue
{
    public Guid Id { get; set; }
    public Guid NotificationId { get; set; }
    public Notification Notification { get; set; } = null!;
    public DateTime QueuedAt { get; set; }
    public DateTime? ProcessedAt { get; set; }
    public int RetryCount { get; set; }
    public string? ErrorMessage { get; set; }
    public QueueStatus Status { get; set; }
    public DateTime? NextRetryAt { get; set; }

    // Constructor
    public NotificationQueue()
    {
        Id = Guid.NewGuid();
        QueuedAt = DateTime.UtcNow;
        Status = QueueStatus.Pending;
        RetryCount = 0;
    }

    // Factory method
    public static NotificationQueue Create(Notification notification)
    {
        return new NotificationQueue
        {
            NotificationId = notification.Id,
            Notification = notification
        };
    }

    // Business methods
    public void MarkAsProcessing()
    {
        Status = QueueStatus.Processing;
    }

    public void MarkAsCompleted()
    {
        Status = QueueStatus.Completed;
        ProcessedAt = DateTime.UtcNow;
        ErrorMessage = null;
    }

    public void MarkAsFailed(string errorMessage)
    {
        Status = QueueStatus.Failed;
        ErrorMessage = errorMessage;
        RetryCount++;
        
        // Calculate next retry time (exponential backoff)
        if (RetryCount < 5)
        {
            NextRetryAt = DateTime.UtcNow.AddMinutes(Math.Pow(2, RetryCount));
            Status = QueueStatus.Retry;
        }
    }

    public bool CanRetry()
    {
        return Status == QueueStatus.Failed && RetryCount < 5 && NextRetryAt <= DateTime.UtcNow;
    }

    public void MarkForRetry()
    {
        if (CanRetry())
        {
            Status = QueueStatus.Pending;
            ErrorMessage = null;
        }
    }
}

---- File: NotificationService.Domain\Entities\NotificationTemplate.cs ----
using NotificationService.Domain.Enums;
using System.Text.Json;

namespace NotificationService.Domain.Entities;

public class NotificationTemplate
{
    public Guid Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Subject { get; set; } = string.Empty;
    public string Body { get; set; } = string.Empty;
    public NotificationType Type { get; set; }
    public bool IsActive { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime? UpdatedAt { get; set; }
    public Dictionary<string, string>? Variables { get; set; }
    public string? Description { get; set; }
    public string? Category { get; set; }

    // Constructor
    public NotificationTemplate()
    {
        Id = Guid.NewGuid();
        CreatedAt = DateTime.UtcNow;
        IsActive = true;
        Variables = new Dictionary<string, string>();
    }

    // Factory method
    public static NotificationTemplate Create(string name, string subject, string body, 
        NotificationType type, string? description = null, string? category = null)
    {
        return new NotificationTemplate
        {
            Name = name,
            Subject = subject,
            Body = body,
            Type = type,
            Description = description,
            Category = category
        };
    }

    // Business methods
    public void Update(string subject, string body, string? description = null)
    {
        Subject = subject;
        Body = body;
        Description = description;
        UpdatedAt = DateTime.UtcNow;
    }

    public void Activate()
    {
        IsActive = true;
        UpdatedAt = DateTime.UtcNow;
    }

    public void Deactivate()
    {
        IsActive = false;
        UpdatedAt = DateTime.UtcNow;
    }

    public void AddVariable(string key, string defaultValue = "")
    {
        Variables ??= new Dictionary<string, string>();
        Variables[key] = defaultValue;
    }

    public void RemoveVariable(string key)
    {
        Variables?.Remove(key);
    }

    public string RenderBody(Dictionary<string, object> parameters)
    {
        var renderedBody = Body;
        
        if (Variables != null && parameters != null)
        {
            foreach (var variable in Variables)
            {
                var placeholder = $"{{{{{variable.Key}}}}}";
                var value = parameters.ContainsKey(variable.Key) ? 
                    parameters[variable.Key]?.ToString() : variable.Value;
                renderedBody = renderedBody.Replace(placeholder, value ?? string.Empty);
            }
        }

        return renderedBody;
    }

    public string RenderSubject(Dictionary<string, object> parameters)
    {
        var renderedSubject = Subject;
        
        if (Variables != null && parameters != null)
        {
            foreach (var variable in Variables)
            {
                var placeholder = $"{{{{{variable.Key}}}}}";
                var value = parameters.ContainsKey(variable.Key) ? 
                    parameters[variable.Key]?.ToString() : variable.Value;
                renderedSubject = renderedSubject.Replace(placeholder, value ?? string.Empty);
            }
        }

        return renderedSubject;
    }
}

---- File: NotificationService.Domain\Enums\NotificationProvider.cs ----
namespace NotificationService.Domain.Enums;

public enum NotificationProvider
{
    SendGrid = 1,
    Twilio = 2,
    Firebase = 3,
    Custom = 4
}

---- File: NotificationService.Domain\Enums\NotificationStatus.cs ----
namespace NotificationService.Domain.Enums;

public enum NotificationStatus
{
    Pending = 1,
    Sent = 2,
    Failed = 3,
    Delivered = 4
}

---- File: NotificationService.Domain\Enums\NotificationType.cs ----
namespace NotificationService.Domain.Enums;

public enum NotificationType
{
    Email = 1,
    Sms = 2,
    Push = 3,
    Webhook = 4
}

---- File: NotificationService.Domain\Enums\PriorityLevel.cs ----
namespace NotificationService.Domain.Enums;

public enum PriorityLevel
{
    Low = 1,
    Medium = 2,
    High = 3,
    Urgent = 4
}

---- File: NotificationService.Domain\Enums\QueueStatus.cs ----
namespace NotificationService.Domain.Enums;

public enum QueueStatus
{
    Pending = 1,
    Processing = 2,
    Completed = 3,
    Failed = 4,
    Retry = 5,
    Cancelled = 6
}

---- File: NotificationService.Domain\Events\NotificationSentEvent.cs ----
using MediatR;

namespace NotificationService.Domain.Events;

public class NotificationSentEvent : INotification
{
    public Guid NotificationId { get; }
    public string Recipient { get; }
    public string Type { get; }
    public DateTime SentAt { get; }
    public bool Success { get; }
    public string? ErrorMessage { get; }
    public string? ProviderMessageId { get; }

    public NotificationSentEvent(Guid notificationId, string recipient, string type, 
        DateTime sentAt, bool success, string? errorMessage = null, string? providerMessageId = null)
    {
        NotificationId = notificationId;
        Recipient = recipient;
        Type = type;
        SentAt = sentAt;
        Success = success;
        ErrorMessage = errorMessage;
        ProviderMessageId = providerMessageId;
    }

    // Factory methods
    public static NotificationSentEvent CreateSuccess(Guid notificationId, string recipient, 
        string type, string? providerMessageId = null)
    {
        return new NotificationSentEvent(
            notificationId, 
            recipient, 
            type, 
            DateTime.UtcNow, 
            true, 
            null, 
            providerMessageId);
    }

    public static NotificationSentEvent CreateFailure(Guid notificationId, string recipient, 
        string type, string errorMessage)
    {
        return new NotificationSentEvent(
            notificationId, 
            recipient, 
            type, 
            DateTime.UtcNow, 
            false, 
            errorMessage);
    }
}

---- File: NotificationService.Domain\Interfaces\IEmailService.cs ----
// NotificationService.Domain/Interfaces/IEmailService.cs
namespace NotificationService.Domain.Interfaces;

public interface IEmailService
{
    Task<bool> SendEmailAsync(string to, string subject, string body, bool isHtml = true);
}

---- File: NotificationService.Domain\Interfaces\IMessageBus.cs ----
namespace NotificationService.Domain.Interfaces;

public interface IMessageBus
{
    Task PublishAsync<T>(T message, string queueName);
    Task SubscribeAsync<T>(Func<T, Task> handler, string queueName);
    Task<bool> IsConnectedAsync();
}

---- File: NotificationService.Domain\Interfaces\INotificationLogRepository.cs ----
using NotificationService.Domain.Entities;

namespace NotificationService.Domain.Interfaces.Repositories;

public interface INotificationLogRepository
{
    Task<IEnumerable<NotificationLog>> GetByNotificationIdAsync(Guid notificationId);
    Task<IEnumerable<NotificationLog>> GetByActionAsync(string action, DateTime startDate, DateTime endDate);
    Task AddAsync(NotificationLog log);
    Task AddRangeAsync(IEnumerable<NotificationLog> logs);
    Task<int> GetLogCountByNotificationAsync(Guid notificationId);
    Task<int> CleanupOldLogsAsync(DateTime cutoffDate);
}

---- File: NotificationService.Domain\Interfaces\INotificationQueueRepository.cs ----
using NotificationService.Domain.Entities;

namespace NotificationService.Domain.Interfaces.Repositories;

public interface INotificationQueueRepository
{
    Task<NotificationQueue?> GetNextPendingAsync();
    Task<IEnumerable<NotificationQueue>> GetPendingAsync();
    Task<IEnumerable<NotificationQueue>> GetRetryQueueAsync();
    Task AddAsync(NotificationQueue queue);
    Task AddRangeAsync(IEnumerable<NotificationQueue> queues);
    Task UpdateAsync(NotificationQueue queue);
    Task UpdateRangeAsync(IEnumerable<NotificationQueue> queues);
    Task<int> GetPendingCountAsync();
    Task<int> CleanupProcessedAsync(DateTime cutoffDate);
}

---- File: NotificationService.Domain\Interfaces\INotificationRepository.cs ----
using NotificationService.Domain.Entities;
using NotificationService.Domain.Enums;

namespace NotificationService.Domain.Interfaces.Repositories;

public interface INotificationRepository
{
    Task<Notification?> GetByIdAsync(Guid id);
    Task<IEnumerable<Notification>> GetByStatusAsync(NotificationStatus status);
    Task<IEnumerable<Notification>> GetByRecipientAsync(string recipient);
    Task<IEnumerable<Notification>> GetByTypeAsync(NotificationType type);
    Task<IEnumerable<Notification>> GetByProviderAsync(NotificationProvider provider);
    Task<IEnumerable<Notification>> GetByDateRangeAsync(DateTime startDate, DateTime endDate);
    Task<IEnumerable<Notification>> GetFailedNotificationsAsync(DateTime since);
    Task<IEnumerable<Notification>> GetPendingNotificationsAsync();
    Task AddAsync(Notification notification);
    Task AddRangeAsync(IEnumerable<Notification> notifications);
    Task UpdateAsync(Notification notification);
    Task UpdateRangeAsync(IEnumerable<Notification> notifications);
    Task DeleteAsync(Guid id);
    Task<int> GetCountByStatusAsync(NotificationStatus status);
    Task<int> GetCountByRecipientAsync(string recipient);
    Task<bool> ExistsAsync(Guid id);
    Task<IEnumerable<Notification>> GetNotificationsWithPaginationAsync(int pageNumber, int pageSize);
    Task<int> GetTotalCountAsync();
    Task<IEnumerable<Notification>> GetRecentNotificationsAsync(int count = 50);
    Task<int> CleanupOldNotificationsAsync(DateTime cutoffDate);
}

---- File: NotificationService.Domain\Interfaces\INotificationTemplateRepository.cs ----
using NotificationService.Domain.Entities;
using NotificationService.Domain.Enums;

namespace NotificationService.Domain.Interfaces.Repositories;

public interface INotificationTemplateRepository
{
    Task<NotificationTemplate?> GetByIdAsync(Guid id);
    Task<NotificationTemplate?> GetByNameAsync(string name);
    Task<IEnumerable<NotificationTemplate>> GetByTypeAsync(NotificationType type);
    Task<IEnumerable<NotificationTemplate>> GetActiveTemplatesAsync();
    Task AddAsync(NotificationTemplate template);
    Task UpdateAsync(NotificationTemplate template);
    Task DeleteAsync(Guid id);
    Task<bool> ExistsAsync(string name);
}

---- File: NotificationService.Domain\Interfaces\IPushNotificationService.cs ----
using AuthService.Shared.NotificationMessages;
using NotificationService.Domain.Entities;

namespace NotificationService.Domain.Interfaces;

public interface IPushNotificationService
{
    Task<bool> SendPushNotificationAsync(PushNotificationEvent pushEvent);
    Task<bool> SendToDeviceAsync(string deviceToken, string title, string message, Dictionary<string, string> customData = null);
    Task<bool> SendToTopicAsync(string topic, string title, string message, Dictionary<string, string> customData = null);
    Task<bool> SubscribeToTopicAsync(string deviceToken, string topic);
    Task<bool> UnsubscribeFromTopicAsync(string deviceToken, string topic);
}

---- File: NotificationService.Domain\Interfaces\ISmsService.cs ----
namespace NotificationService.Domain.Interfaces;

// NotificationService.Domain/Interfaces/ISmsService.cs
public interface ISmsService
{
    Task<bool> SendSmsAsync(string to, string message);
}

---- File: NotificationService.Domain\Interfaces\ITemplateEngine.cs ----
namespace NotificationService.Domain.Interfaces;

public interface ITemplateEngine
{
    Task<string> RenderTemplateAsync(string templateName, Dictionary<string, object> parameters);
}

---- File: NotificationService.Domain\Interfaces\IUnitOfWork.cs ----
using NotificationService.Domain.Interfaces.Repositories;

namespace NotificationService.Domain.Interfaces;

public interface IUnitOfWork : IDisposable
{
    INotificationRepository Notifications { get; }
    INotificationTemplateRepository NotificationTemplates { get; }
    INotificationQueueRepository NotificationQueues { get; }
    INotificationLogRepository NotificationLogs { get; }
    
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
    Task<bool> SaveEntitiesAsync(CancellationToken cancellationToken = default);
    Task BeginTransactionAsync();
    Task CommitTransactionAsync();
    Task RollbackTransactionAsync();
}

---- File: NotificationService.Domain\Interfaces\External\IEmailProvider.cs ----
namespace NotificationService.Domain.Interfaces.External;

public interface IEmailProvider
{
    Task<(bool success, string? messageId, string? error)> SendAsync(
        string to, 
        string subject, 
        string body, 
        bool isHtml = true,
        Dictionary<string, object>? metadata = null);
    
    string ProviderName { get; }
}

---- File: NotificationService.Domain\Interfaces\External\IPushNotificationProvider.cs ----
namespace NotificationService.Domain.Interfaces.External;

public interface IPushNotificationProvider
{
    Task<(bool success, string? messageId, string? error)> SendAsync(
        string deviceToken, 
        string title, 
        string body, 
        object? data = null,
        Dictionary<string, object>? metadata = null);
    
    string ProviderName { get; }
}

---- File: NotificationService.Domain\Interfaces\External\ISmsProvider.cs ----
namespace NotificationService.Domain.Interfaces.External;

public interface ISmsProvider
{
    Task<(bool success, string? messageId, string? error)> SendAsync(
        string to, 
        string message,
        Dictionary<string, object>? metadata = null);
    
    string ProviderName { get; }
}

---- File: NotificationService.Domain\ValueObjects\EmailAddress.cs ----
namespace NotificationService.Domain.ValueObjects;

public record EmailAddress
{
    public string Value { get; }

    public EmailAddress(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Email address cannot be empty");
        
        if (!IsValidEmail(value))
            throw new ArgumentException("Invalid email address format");

        Value = value.ToLower().Trim();
    }

    private static bool IsValidEmail(string email)
    {
        try
        {
            var addr = new System.Net.Mail.MailAddress(email);
            return addr.Address == email;
        }
        catch
        {
            return false;
        }
    }

    public static implicit operator string(EmailAddress email) => email.Value;
    public static implicit operator EmailAddress(string email) => new(email);

    public override string ToString() => Value;

    public string GetDomain()
    {
        var atIndex = Value.IndexOf('@');
        return atIndex > 0 ? Value[(atIndex + 1)..] : string.Empty;
    }

    public string GetUsername()
    {
        var atIndex = Value.IndexOf('@');
        return atIndex > 0 ? Value[..atIndex] : Value;
    }
}

---- File: NotificationService.Domain\ValueObjects\MessageContent.cs ----
namespace NotificationService.Domain.ValueObjects;

public record MessageContent
{
    public string Value { get; }

    public MessageContent(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Message content cannot be empty");

        if (value.Length > 1600)
            throw new ArgumentException("Message content too long");

        Value = value.Trim();
    }

    public static implicit operator string(MessageContent content) => content.Value;
    public static implicit operator MessageContent(string content) => new(content);

    public override string ToString() => Value;

    public int WordCount => Value.Split(new[] { ' ', '\t', '\n', '\r' }, 
        StringSplitOptions.RemoveEmptyEntries).Length;

    public bool ContainsHtml => Value.Contains('<') && Value.Contains('>');
}

---- File: NotificationService.Domain\ValueObjects\NotificationSubject.cs ----
namespace NotificationService.Domain.ValueObjects;

public record NotificationSubject
{
    public string Value { get; }

    public NotificationSubject(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Subject cannot be empty");

        if (value.Length > 200)
            throw new ArgumentException("Subject too long");

        Value = value.Trim();
    }

    public static implicit operator string(NotificationSubject subject) => subject.Value;
    public static implicit operator NotificationSubject(string subject) => new(subject);

    public override string ToString() => Value;

    public string Truncate(int maxLength)
    {
        return Value.Length <= maxLength ? Value : Value[..maxLength] + "...";
    }
}

---- File: NotificationService.Domain\ValueObjects\PhoneNumber.cs ----
namespace NotificationService.Domain.ValueObjects;

public record PhoneNumber
{
    public string Value { get; }

    public PhoneNumber(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
            throw new ArgumentException("Phone number cannot be empty");

        // Basic validation - in production you might want more sophisticated validation
        var cleaned = new string(value.Where(char.IsDigit).ToArray());
        
        if (cleaned.Length < 10)
            throw new ArgumentException("Phone number too short");

        Value = cleaned;
    }

    public static implicit operator string(PhoneNumber phone) => phone.Value;
    public static implicit operator PhoneNumber(string phone) => new(phone);

    public override string ToString() => Value;

    public string FormatInternational()
    {
        if (Value.Length == 10)
        {
            return $"+1{Value}"; // Assuming US numbers for simplicity
        }
        return $"+{Value}";
    }

    public string FormatLocal()
    {
        if (Value.Length == 10)
        {
            return $"({Value[..3]}) {Value[3..6]}-{Value[6..]}";
        }
        return Value;
    }
}

---- File: NotificationService.Infrastructure\DependencyInjection.cs ----
// NotificationService.Infrastructure\DependencyInjection.cs
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using NotificationService.Domain.Interfaces;
using NotificationService.Domain.Interfaces.External;
using NotificationService.Domain.Interfaces.Repositories;
using NotificationService.Infrastructure.External;
using NotificationService.Infrastructure.MessageBus;
using NotificationService.Infrastructure.Persistence;
using NotificationService.Infrastructure.Services;
using NotificationService.Shared;

namespace NotificationService.Infrastructure;

public static class DependencyInjection
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
    {
        // Database Context
        var connectionString = configuration.GetConnectionString("DefaultConnection");
        services.AddDbContext<ApplicationDbContext>(options =>
            options.UseNpgsql(connectionString));

        // Repositories (Domain Interfaces)
        services.AddScoped<INotificationRepository, EfNotificationRepository>();
        services.AddScoped<INotificationTemplateRepository, EfNotificationTemplateRepository>();
        services.AddScoped<INotificationQueueRepository, EfNotificationQueueRepository>();
        services.AddScoped<INotificationLogRepository, EfNotificationLogRepository>();

        // External Services (Domain Interfaces)
        services.AddScoped<IEmailProvider, SendGridEmailService>();
        services.AddScoped<ISmsProvider, TwilioSmsService>();
        services.AddScoped<IPushNotificationProvider, FirebasePushService>();

        // Infrastructure Services (Domain Interfaces)
        services.AddScoped<ITemplateEngine, TemplateService>();
        services.AddScoped<NotificationQueueService>();

        // ✅ AGREGAR HTTP CLIENT PARA ERROR SERVICE
        services.AddHttpClient<ErrorServiceClient>(client =>
        {
            client.BaseAddress = new Uri("http://errorservice:80");
            client.DefaultRequestHeaders.Add("User-Agent", "NotificationService");
        });

        // Message Bus (Domain Interface)
        services.AddSingleton<IMessageBus>(sp =>
        {
            var config = sp.GetRequiredService<IConfiguration>();
            return new RabbitMQMessageBus(
                config["RabbitMQ:HostName"] ?? "localhost",
                config["RabbitMQ:UserName"] ?? "guest",
                config["RabbitMQ:Password"] ?? "guest");
        });

        return services;
    }
}

---- File: NotificationService.Infrastructure\NotificationService.Infrastructure.csproj ----
<!-- NotificationService.Infrastructure\NotificationService.Infrastructure.csproj -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <RootNamespace>NotificationService.Infrastructure</RootNamespace>
    <AssemblyName>NotificationService.Infrastructure</AssemblyName>
    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
    <NoWarn>NU1605</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <!-- Entity Framework Core -->
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.11" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.8" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.11">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>

    <!-- Microsoft Extensions -->
    <PackageReference Include="Microsoft.Extensions.Logging" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.Options" Version="8.0.2" />
    <PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="8.0.1" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" Version="8.0.2" />

    <!-- ✅ AGREGAR ESTE PAQUETE PARA PostAsJsonAsync -->
    <PackageReference Include="System.Net.Http.Json" Version="8.0.0" />

    <!-- Proveedores externos -->
    <PackageReference Include="SendGrid" Version="9.28.1" />
    <PackageReference Include="Twilio" Version="6.2.5" />
    <PackageReference Include="RabbitMQ.Client" Version="6.8.1" />
    <PackageReference Include="Azure.Messaging.ServiceBus" Version="7.17.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\AuthService\AuthService.Infrastructure\AuthService.Infrastructure.csproj" />
    <ProjectReference Include="..\NotificationService.Application\NotificationService.Application.csproj" />
    <ProjectReference Include="..\NotificationService.Domain\NotificationService.Domain.csproj" />
    <ProjectReference Include="..\NotificationService.Shared\NotificationService.Shared.csproj" />
  </ItemGroup>
</Project>

---- File: NotificationService.Infrastructure\Extensions\ServiceCollectionExtensions.cs ----
using AuthService.Infrastructure.Services.Notification;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using NotificationService.Domain.Interfaces;
using NotificationService.Infrastructure.Messaging;
using NotificationService.Infrastructure.Persistence;
using NotificationService.Infrastructure.Services;

namespace NotificationService.Infrastructure.Extensions;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration configuration)
    {
        // Database Context (ya configurado en Program.cs)
        // No duplicar la configuración del DbContext aquí

        // RabbitMQ Configuration
        services.Configure<RabbitMQSettings>(configuration.GetSection("RabbitMQ"));
        services.Configure<NotificationServiceRabbitMQSettings>(configuration.GetSection("NotificationService"));

        // Register Queue Service
        services.AddScoped<NotificationQueueService>();

        // Background Services
        services.AddHostedService<RabbitMQNotificationConsumer>(); // Para mensajes externos de RabbitMQ
        services.AddHostedService<NotificationQueueBackgroundService>(); // Para procesar colas internas

        return services;
    }
}

---- File: NotificationService.Infrastructure\External\FirebasePushService.cs ----
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NotificationService.Domain.Interfaces.External;
using NotificationService.Shared;

namespace NotificationService.Infrastructure.External;

public class FirebasePushService : IPushNotificationProvider
{
    private readonly FirebaseSettings _settings;
    private readonly ILogger<FirebasePushService> _logger;

    public FirebasePushService(
        IOptions<NotificationSettings> settings,
        ILogger<FirebasePushService> logger)
    {
        _settings = settings.Value.Firebase;
        _logger = logger;
    }

    public string ProviderName => "Firebase";

    public async Task<(bool success, string? messageId, string? error)> SendAsync(
        string deviceToken,
        string title,
        string body,
        object? data = null,
        Dictionary<string, object>? metadata = null)
    {
        try
        {
            // Implementar lógica real de Firebase Cloud Messaging
            // Por ahora simulamos el envío exitoso
            await Task.Delay(100);

            _logger.LogInformation("Push notification sent successfully to device {DeviceToken}", deviceToken);
            return (true, Guid.NewGuid().ToString(), null);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending push notification to device {DeviceToken}", deviceToken);
            return (false, null, ex.Message);
        }
    }
}

---- File: NotificationService.Infrastructure\External\SendGridEmailService.cs ----
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NotificationService.Domain.Interfaces.External;
using NotificationService.Shared;
using SendGrid;
using SendGrid.Helpers.Mail;

namespace NotificationService.Infrastructure.External;

public class SendGridEmailService : IEmailProvider
{
    private readonly SendGridClient _client;
    private readonly EmailAddress _fromAddress;
    private readonly ILogger<SendGridEmailService> _logger;

    public SendGridEmailService(
        IOptions<NotificationSettings> settings,
        ILogger<SendGridEmailService> logger)
    {
        var sendGridSettings = settings.Value.SendGrid;
        _client = new SendGridClient(sendGridSettings.ApiKey);
        _fromAddress = new EmailAddress(sendGridSettings.FromEmail, sendGridSettings.FromName);
        _logger = logger;
    }

    public string ProviderName => "SendGrid";

    public async Task<(bool success, string? messageId, string? error)> SendAsync(
        string to,
        string subject,
        string body,
        bool isHtml = true,
        Dictionary<string, object>? metadata = null)
    {
        try
        {
            var toEmail = new EmailAddress(to);
            var message = MailHelper.CreateSingleEmail(_fromAddress, toEmail, subject,
                isHtml ? null : body, isHtml ? body : null);

            if (metadata != null)
            {
                message.AddHeaders(metadata.ToDictionary(kvp => kvp.Key, kvp => kvp.Value?.ToString() ?? ""));
            }

            var response = await _client.SendEmailAsync(message);
            var responseBody = await response.Body.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                _logger.LogInformation("Email sent successfully to {To}", to);
                return (true, response.Headers.GetValues("X-Message-Id").FirstOrDefault(), null);
            }
            else
            {
                _logger.LogWarning("Failed to send email to {To}. Status: {StatusCode}", to, response.StatusCode);
                return (false, null, $"SendGrid API error: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending email to {To}", to);
            return (false, null, ex.Message);
        }
    }
}

---- File: NotificationService.Infrastructure\External\TwilioSmsService.cs ----
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NotificationService.Domain.Interfaces.External; // ✅ CORRECTO - Domain
using NotificationService.Shared;
using Twilio;
using Twilio.Rest.Api.V2010.Account;
using Twilio.Types;

namespace NotificationService.Infrastructure.External;

public class TwilioSmsService : ISmsProvider // ✅ Implementa interfaz de Domain
{
    private readonly string _fromNumber;
    private readonly ILogger<TwilioSmsService> _logger;

    public TwilioSmsService(
        IOptions<NotificationSettings> settings,
        ILogger<TwilioSmsService> logger)
    {
        var twilioSettings = settings.Value.Twilio;
        TwilioClient.Init(twilioSettings.AccountSid, twilioSettings.AuthToken);
        _fromNumber = twilioSettings.FromNumber;
        _logger = logger;
    }

    public string ProviderName => "Twilio";

    public async Task<(bool success, string? messageId, string? error)> SendAsync(
        string to,
        string message,
        Dictionary<string, object>? metadata = null)
    {
        try
        {
            var messageResource = await MessageResource.CreateAsync(
                body: message,
                from: new PhoneNumber(_fromNumber),
                to: new PhoneNumber(to)
            );

            if (messageResource.Status != MessageResource.StatusEnum.Failed)
            {
                _logger.LogInformation("SMS sent successfully to {To}", to);
                return (true, messageResource.Sid, null);
            }
            else
            {
                _logger.LogWarning("Failed to send SMS to {To}. Status: {Status}", to, messageResource.Status);
                return (false, null, $"Twilio error: {messageResource.ErrorMessage}");
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error sending SMS to {To}", to);
            return (false, null, ex.Message);
        }
    }
}

---- File: NotificationService.Infrastructure\MessageBus\AzureServiceBus.cs ----
using Azure.Messaging.ServiceBus;
using System.Text.Json;
using NotificationService.Domain.Interfaces;

namespace NotificationService.Infrastructure.MessageBus;

public class AzureServiceBus : IMessageBus
{
    private readonly ServiceBusClient _client;

    public AzureServiceBus(string connectionString)
    {
        _client = new ServiceBusClient(connectionString);
    }

    public async Task PublishAsync<T>(T message, string queueName)
    {
        var sender = _client.CreateSender(queueName);
        var messageBody = JsonSerializer.Serialize(message);
        var serviceBusMessage = new ServiceBusMessage(messageBody);
        await sender.SendMessageAsync(serviceBusMessage);
    }

    public async Task SubscribeAsync<T>(Func<T, Task> handler, string queueName)
    {
        var processor = _client.CreateProcessor(queueName);
        processor.ProcessMessageAsync += async args =>
        {
            var messageBody = args.Message.Body.ToString();
            var message = JsonSerializer.Deserialize<T>(messageBody);
            if (message != null)
            {
                await handler(message);
            }
            await args.CompleteMessageAsync(args.Message);
        };
        processor.ProcessErrorAsync += args =>
        {
            // Manejar error
            return Task.CompletedTask;
        };
        await processor.StartProcessingAsync();
    }

    public Task<bool> IsConnectedAsync()
    {
        return Task.FromResult(_client != null);
    }
}

---- File: NotificationService.Infrastructure\MessageBus\InMemoryMessageBus.cs ----
using System.Text.Json;
using NotificationService.Domain.Interfaces;

namespace NotificationService.Infrastructure.MessageBus;

public class InMemoryMessageBus : IMessageBus
{
    private readonly Dictionary<string, List<Func<string, Task>>> _handlers = new();

    public Task PublishAsync<T>(T message, string queueName)
    {
        if (_handlers.ContainsKey(queueName))
        {
            var messageBody = JsonSerializer.Serialize(message);
            foreach (var handler in _handlers[queueName])
            {
                handler(messageBody).ContinueWith(t =>
                {
                    if (t.IsFaulted)
                    {
                        // Log error
                    }
                });
            }
        }
        return Task.CompletedTask;
    }

    public Task SubscribeAsync<T>(Func<T, Task> handler, string queueName)
    {
        if (!_handlers.ContainsKey(queueName))
        {
            _handlers[queueName] = new List<Func<string, Task>>();
        }

        _handlers[queueName].Add(async messageBody =>
        {
            var message = JsonSerializer.Deserialize<T>(messageBody);
            if (message != null)
            {
                await handler(message);
            }
        });

        return Task.CompletedTask;
    }

    public Task<bool> IsConnectedAsync()
    {
        return Task.FromResult(true); // Siempre conectado en memoria
    }
}

---- File: NotificationService.Infrastructure\MessageBus\RabbitMQMessageBus.cs ----
using RabbitMQ.Client;
using System.Text;
using System.Text.Json;
using NotificationService.Domain.Interfaces;

namespace NotificationService.Infrastructure.MessageBus;

public class RabbitMQMessageBus : IMessageBus
{
    private readonly IConnection _connection;
    private readonly IModel _channel;

    public RabbitMQMessageBus(string hostName, string userName, string password)
    {
        var factory = new ConnectionFactory
        {
            HostName = hostName,
            UserName = userName,
            Password = password
        };

        _connection = factory.CreateConnection();
        _channel = _connection.CreateModel();
    }

    public async Task PublishAsync<T>(T message, string queueName)
    {
        await Task.Run(() =>
        {
            _channel.QueueDeclare(queue: queueName, durable: true, exclusive: false, autoDelete: false, arguments: null);

            var body = Encoding.UTF8.GetBytes(JsonSerializer.Serialize(message));

            _channel.BasicPublish(exchange: "", routingKey: queueName, basicProperties: null, body: body);
        });
    }

    public async Task SubscribeAsync<T>(Func<T, Task> handler, string queueName)
    {
        _channel.QueueDeclare(queue: queueName, durable: true, exclusive: false, autoDelete: false, arguments: null);

        var consumer = new RabbitMQ.Client.Events.AsyncEventingBasicConsumer(_channel);

        consumer.Received += async (model, ea) =>
        {
            var body = ea.Body.ToArray();
            var message = JsonSerializer.Deserialize<T>(Encoding.UTF8.GetString(body));

            if (message != null)
            {
                await handler(message);
            }

            _channel.BasicAck(ea.DeliveryTag, false);
        };

        _channel.BasicConsume(queue: queueName, autoAck: false, consumer: consumer);
        await Task.CompletedTask;
    }

    public Task<bool> IsConnectedAsync()
    {
        return Task.FromResult(_connection?.IsOpen ?? false);
    }
}

---- File: NotificationService.Infrastructure\Messaging\NotificationServiceRabbitMQSettings.cs ----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace NotificationService.Infrastructure.Messaging;

public class NotificationServiceRabbitMQSettings
{
    public bool EnableRabbitMQ { get; set; } = true;

    // Configuración principal (debe coincidir EXACTAMENTE con AuthService)
    public string QueueName { get; set; } = "notification-queue";
    public string ExchangeName { get; set; } = "notification-exchange";
    public string RoutingKey { get; set; } = "notification.auth";

    // Colas específicas por tipo de notificación
    public string EmailQueueName { get; set; } = "notification-email-queue";
    public string SmsQueueName { get; set; } = "notification-sms-queue";
    public string PushQueueName { get; set; } = "notification-push-queue";

    // Configuración de reintentos y manejo de errores
    public int RetryDelayMs { get; set; } = 60000; // 1 minuto para retry
    public int MaxRetryAttempts { get; set; } = 3;
    public int PrefetchCount { get; set; } = 10; // Número de mensajes a pre-fetch

    // Configuración de timeouts
    public int ConnectionTimeoutMs { get; set; } = 30000;
    public int RequestedHeartbeatMs { get; set; } = 60;

    // Configuración de calidad de servicio (QoS)
    public bool GlobalQos { get; set; } = false;
}

---- File: NotificationService.Infrastructure\Messaging\RabbitMQNotificationConsumer.cs ----
using AuthService.Shared.NotificationMessages;
using MediatR;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using NotificationService.Application.DTOs;
using NotificationService.Application.UseCases.SendEmailNotification;
using NotificationService.Application.UseCases.SendSmsNotification;
using NotificationService.Domain.Entities;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;
using System.Text.Json;

namespace NotificationService.Infrastructure.Messaging;

public class RabbitMQNotificationConsumer : BackgroundService
{
    private readonly IConnection _connection;
    private readonly IModel _channel;
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<RabbitMQNotificationConsumer> _logger;
    private readonly NotificationServiceRabbitMQSettings _settings;
    private readonly JsonSerializerOptions _jsonOptions;

    public RabbitMQNotificationConsumer(
        IServiceProvider serviceProvider,
        IOptions<RabbitMQSettings> rabbitMqSettings,
        IOptions<NotificationServiceRabbitMQSettings> notificationSettings,
        ILogger<RabbitMQNotificationConsumer> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
        _settings = notificationSettings.Value;

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = false
        };

        try
        {
            var factory = new ConnectionFactory
            {
                HostName = rabbitMqSettings.Value.Host,
                Port = rabbitMqSettings.Value.Port,
                UserName = rabbitMqSettings.Value.Username,
                Password = rabbitMqSettings.Value.Password,
                VirtualHost = rabbitMqSettings.Value.VirtualHost,
                DispatchConsumersAsync = true
            };

            _connection = factory.CreateConnection();
            _channel = _connection.CreateModel();

            // Configurar exchange y colas (deben coincidir con AuthService)
            SetupRabbitMQ();

            _logger.LogInformation("✅ RabbitMQ Notification Consumer initialized successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "❌ Failed to initialize RabbitMQ Notification Consumer");
            throw;
        }
    }

    private void SetupRabbitMQ()
    {
        // Exchange principal
        _channel.ExchangeDeclare(
            exchange: _settings.ExchangeName,
            type: ExchangeType.Direct,
            durable: true,
            autoDelete: false);

        // Cola general
        _channel.QueueDeclare(
            queue: _settings.QueueName,
            durable: true,
            exclusive: false,
            autoDelete: false,
            arguments: null);

        _channel.QueueBind(
            queue: _settings.QueueName,
            exchange: _settings.ExchangeName,
            routingKey: _settings.RoutingKey);

        // Cola específica para emails
        _channel.QueueDeclare(
            queue: _settings.EmailQueueName,
            durable: true,
            exclusive: false,
            autoDelete: false,
            arguments: null);

        _channel.QueueBind(
            queue: _settings.EmailQueueName,
            exchange: _settings.ExchangeName,
            routingKey: "notification.email");

        // Cola específica para SMS
        _channel.QueueDeclare(
            queue: _settings.SmsQueueName,
            durable: true,
            exclusive: false,
            autoDelete: false,
            arguments: null);

        _channel.QueueBind(
            queue: _settings.SmsQueueName,
            exchange: _settings.ExchangeName,
            routingKey: "notification.sms");

        // Configurar QoS
        _channel.BasicQos(0, (ushort)_settings.PrefetchCount, _settings.GlobalQos);

        _logger.LogInformation("RabbitMQ setup completed for NotificationService");
    }

    protected override Task ExecuteAsync(CancellationToken stoppingToken)
    {
        stoppingToken.Register(() =>
        {
            _logger.LogInformation("🛑 RabbitMQ Notification Consumer is stopping");
            _channel?.Close();
            _connection?.Close();
        });

        // Iniciar consumo de todas las colas
        StartConsuming(_settings.QueueName, "general");
        StartConsuming(_settings.EmailQueueName, "email");
        StartConsuming(_settings.SmsQueueName, "sms");

        _logger.LogInformation("RabbitMQ Notification Consumer started successfully");
        return Task.CompletedTask;
    }

    private void StartConsuming(string queueName, string queueType)
    {
        var consumer = new AsyncEventingBasicConsumer(_channel);

        consumer.Received += async (model, ea) =>
        {
            var body = ea.Body.ToArray();
            var message = Encoding.UTF8.GetString(body);

            try
            {
                _logger.LogInformation("Received message from {QueueName} ({Type})", queueName, queueType);
                await ProcessMessage(queueType, message);
                _channel.BasicAck(ea.DeliveryTag, false);
                _logger.LogInformation("Successfully processed message from {QueueName}", queueName);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing message from queue {QueueName}", queueName);
                _channel.BasicNack(ea.DeliveryTag, false, false);
            }
        };

        _channel.BasicConsume(
            queue: queueName,
            autoAck: false,
            consumer: consumer);

        _logger.LogInformation("Started consuming from queue: {QueueName} ({Type})", queueName, queueType);
    }

    private async Task ProcessMessage(string queueType, string message)
    {
        using var scope = _serviceProvider.CreateScope();

        try
        {
            switch (queueType)
            {
                case "email":
                    await ProcessEmailMessage(message, scope);
                    break;
                case "sms":
                    await ProcessSmsMessage(message, scope);
                    break;
                case "general":
                    await ProcessGeneralMessage(message, scope);
                    break;
                default:
                    _logger.LogWarning("Unknown queue type: {QueueType}", queueType);
                    break;
            }
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "JSON deserialization error for {QueueType} message", queueType);
            throw;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing {QueueType} message", queueType);
            throw;
        }
    }

    private async Task ProcessEmailMessage(string message, IServiceScope scope)
    {
        var emailEvent = JsonSerializer.Deserialize<EmailNotificationEvent>(message, _jsonOptions);
        if (emailEvent == null)
        {
            _logger.LogWarning("Failed to deserialize email message");
            return;
        }

        // Usar los comandos EXISTENTES de tu aplicación
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();

        // Crear el request usando tu DTO existente
        var request = new SendEmailNotificationRequest(
            To: emailEvent.To,
            Subject: emailEvent.Subject,
            Body: emailEvent.Body,
            IsHtml: emailEvent.IsHtml,
            Metadata: emailEvent.Data
        );

        // Usar el comando EXISTENTE de tu aplicación
        var command = new SendEmailNotificationCommand(request);
        var result = await mediator.Send(command);

        if (result.NotificationId != Guid.Empty)
        {
            _logger.LogInformation("Successfully processed email notification {NotificationId} for {To}",
                result.NotificationId, emailEvent.To);
        }
        else
        {
            _logger.LogWarning("Failed to process email notification for {To}", emailEvent.To);
        }
    }

    private async Task ProcessSmsMessage(string message, IServiceScope scope)
    {
        var smsEvent = JsonSerializer.Deserialize<SmsNotificationEvent>(message, _jsonOptions);
        if (smsEvent == null)
        {
            _logger.LogWarning("Failed to deserialize SMS message");
            return;
        }

        // Usar los comandos EXISTENTES de tu aplicación
        var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();

        // Crear el request usando tu DTO existente
        var request = new SendSmsNotificationRequest(
            To: smsEvent.To,
            Message: smsEvent.Body,
            Metadata: smsEvent.Data
        );

        // Usar el comando EXISTENTE de tu aplicación
        var command = new SendSmsNotificationCommand(request);
        var result = await mediator.Send(command);

        if (result.NotificationId != Guid.Empty)
        {
            _logger.LogInformation("Successfully processed SMS notification {NotificationId} for {To}",
                result.NotificationId, smsEvent.To);
        }
        else
        {
            _logger.LogWarning("Failed to process SMS notification for {To}", smsEvent.To);
        }
    }

    private async Task ProcessGeneralMessage(string message, IServiceScope scope)
    {
        var notificationEvent = JsonSerializer.Deserialize<NotificationEvent>(message, _jsonOptions);
        if (notificationEvent == null)
        {
            _logger.LogWarning("Failed to deserialize general notification message");
            return;
        }

        // Determinar el tipo basado en el campo Type
        switch (notificationEvent.Type.ToLower())
        {
            case "email":
                await ProcessEmailMessage(message, scope);
                break;
            case "sms":
                await ProcessSmsMessage(message, scope);
                break;
            default:
                _logger.LogWarning("Unsupported notification type in general queue: {Type}", notificationEvent.Type);
                break;
        }
    }

    public override void Dispose()
    {
        _channel?.Close();
        _channel?.Dispose();
        _connection?.Close();
        _connection?.Dispose();
        base.Dispose();
    }
}

---- File: NotificationService.Infrastructure\Messaging\RabbitMQSettings.cs ----
namespace NotificationService.Infrastructure.Messaging;

public class RabbitMQSettings
{
    public string Host { get; set; } = "rabbitmq";
    public int Port { get; set; } = 5672;
    public string Username { get; set; } = "guest";
    public string Password { get; set; } = "guest";
    public string VirtualHost { get; set; } = "/";
    public int ConnectionTimeout { get; set; } = 30000;
    public int RequestedHeartbeat { get; set; } = 60;

    // Propiedades adicionales para resiliencia
    public int RetryCount { get; set; } = 3;
    public int RetryDelayMilliseconds { get; set; } = 2000;
    public bool AutomaticRecoveryEnabled { get; set; } = true;
    public TimeSpan NetworkRecoveryInterval { get; set; } = TimeSpan.FromSeconds(10);
}

---- File: NotificationService.Infrastructure\Migrations\20251023183351_InitialCreate.cs ----
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace NotificationService.Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Notifications",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Type = table.Column<string>(type: "text", nullable: false),
                    Recipient = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
                    Subject = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: false),
                    Content = table.Column<string>(type: "text", nullable: false),
                    Status = table.Column<string>(type: "text", nullable: false),
                    Provider = table.Column<string>(type: "text", nullable: false),
                    Priority = table.Column<string>(type: "text", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    SentAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    RetryCount = table.Column<int>(type: "integer", nullable: false),
                    ErrorMessage = table.Column<string>(type: "character varying(1000)", maxLength: 1000, nullable: true),
                    TemplateName = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: true),
                    Metadata = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Notifications", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "NotificationTemplates",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Name = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    Subject = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: false),
                    Body = table.Column<string>(type: "text", nullable: false),
                    Type = table.Column<string>(type: "text", nullable: false),
                    IsActive = table.Column<bool>(type: "boolean", nullable: false),
                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    Variables = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_NotificationTemplates", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "NotificationLogs",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    NotificationId = table.Column<Guid>(type: "uuid", nullable: false),
                    Action = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
                    Details = table.Column<string>(type: "character varying(2000)", maxLength: 2000, nullable: true),
                    ErrorMessage = table.Column<string>(type: "character varying(2000)", maxLength: 2000, nullable: true),
                    Timestamp = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    ProviderResponse = table.Column<string>(type: "character varying(1000)", maxLength: 1000, nullable: true),
                    ProviderMessageId = table.Column<string>(type: "character varying(200)", maxLength: 200, nullable: true),
                    Cost = table.Column<decimal>(type: "numeric(18,6)", precision: 18, scale: 6, nullable: true),
                    IpAddress = table.Column<string>(type: "character varying(45)", maxLength: 45, nullable: true),
                    UserAgent = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: true),
                    Metadata = table.Column<string>(type: "text", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_NotificationLogs", x => x.Id);
                    table.ForeignKey(
                        name: "FK_NotificationLogs_Notifications_NotificationId",
                        column: x => x.NotificationId,
                        principalTable: "Notifications",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateTable(
                name: "NotificationQueues",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    NotificationId = table.Column<Guid>(type: "uuid", nullable: false),
                    QueuedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    ProcessedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
                    RetryCount = table.Column<int>(type: "integer", nullable: false),
                    ErrorMessage = table.Column<string>(type: "character varying(1000)", maxLength: 1000, nullable: true),
                    Status = table.Column<string>(type: "text", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_NotificationQueues", x => x.Id);
                    table.ForeignKey(
                        name: "FK_NotificationQueues_Notifications_NotificationId",
                        column: x => x.NotificationId,
                        principalTable: "Notifications",
                        principalColumn: "Id",
                        onDelete: ReferentialAction.Cascade);
                });

            migrationBuilder.CreateIndex(
                name: "IX_NotificationLogs_Action",
                table: "NotificationLogs",
                column: "Action");

            migrationBuilder.CreateIndex(
                name: "IX_NotificationLogs_NotificationId",
                table: "NotificationLogs",
                column: "NotificationId");

            migrationBuilder.CreateIndex(
                name: "IX_NotificationLogs_NotificationId_Timestamp",
                table: "NotificationLogs",
                columns: new[] { "NotificationId", "Timestamp" });

            migrationBuilder.CreateIndex(
                name: "IX_NotificationLogs_Timestamp",
                table: "NotificationLogs",
                column: "Timestamp");

            migrationBuilder.CreateIndex(
                name: "IX_NotificationQueues_NotificationId",
                table: "NotificationQueues",
                column: "NotificationId");

            migrationBuilder.CreateIndex(
                name: "IX_NotificationTemplates_Name",
                table: "NotificationTemplates",
                column: "Name",
                unique: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "NotificationLogs");

            migrationBuilder.DropTable(
                name: "NotificationQueues");

            migrationBuilder.DropTable(
                name: "NotificationTemplates");

            migrationBuilder.DropTable(
                name: "Notifications");
        }
    }
}

---- File: NotificationService.Infrastructure\Migrations\20251023183351_InitialCreate.Designer.cs ----
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NotificationService.Infrastructure.Persistence;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace NotificationService.Infrastructure.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251023183351_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.11")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("NotificationService.Domain.Entities.Notification", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("ErrorMessage")
                        .HasMaxLength(1000)
                        .HasColumnType("character varying(1000)");

                    b.Property<string>("Metadata")
                        .HasColumnType("text");

                    b.Property<string>("Priority")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Provider")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Recipient")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("character varying(255)");

                    b.Property<int>("RetryCount")
                        .HasColumnType("integer");

                    b.Property<DateTime?>("SentAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Subject")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("TemplateName")
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Notifications");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationLog", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Action")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<decimal?>("Cost")
                        .HasPrecision(18, 6)
                        .HasColumnType("numeric(18,6)");

                    b.Property<string>("Details")
                        .HasMaxLength(2000)
                        .HasColumnType("character varying(2000)");

                    b.Property<string>("ErrorMessage")
                        .HasMaxLength(2000)
                        .HasColumnType("character varying(2000)");

                    b.Property<string>("IpAddress")
                        .HasMaxLength(45)
                        .HasColumnType("character varying(45)");

                    b.Property<string>("Metadata")
                        .HasColumnType("text");

                    b.Property<Guid>("NotificationId")
                        .HasColumnType("uuid");

                    b.Property<string>("ProviderMessageId")
                        .HasMaxLength(200)
                        .HasColumnType("character varying(200)");

                    b.Property<string>("ProviderResponse")
                        .HasMaxLength(1000)
                        .HasColumnType("character varying(1000)");

                    b.Property<DateTime>("Timestamp")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UserAgent")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.HasKey("Id");

                    b.HasIndex("Action");

                    b.HasIndex("NotificationId");

                    b.HasIndex("Timestamp");

                    b.HasIndex("NotificationId", "Timestamp");

                    b.ToTable("NotificationLogs");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationQueue", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("ErrorMessage")
                        .HasMaxLength(1000)
                        .HasColumnType("character varying(1000)");

                    b.Property<Guid>("NotificationId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("ProcessedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("QueuedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<int>("RetryCount")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("NotificationId");

                    b.ToTable("NotificationQueues");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationTemplate", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Body")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("Subject")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Variables")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Name")
                        .IsUnique();

                    b.ToTable("NotificationTemplates");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationLog", b =>
                {
                    b.HasOne("NotificationService.Domain.Entities.Notification", "Notification")
                        .WithMany()
                        .HasForeignKey("NotificationId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Notification");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationQueue", b =>
                {
                    b.HasOne("NotificationService.Domain.Entities.Notification", "Notification")
                        .WithMany()
                        .HasForeignKey("NotificationId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Notification");
                });
#pragma warning restore 612, 618
        }
    }
}

---- File: NotificationService.Infrastructure\Migrations\ApplicationDbContextModelSnapshot.cs ----
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using NotificationService.Infrastructure.Persistence;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace NotificationService.Infrastructure.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    partial class ApplicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.11")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("NotificationService.Domain.Entities.Notification", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("ErrorMessage")
                        .HasMaxLength(1000)
                        .HasColumnType("character varying(1000)");

                    b.Property<string>("Metadata")
                        .HasColumnType("text");

                    b.Property<string>("Priority")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Provider")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Recipient")
                        .IsRequired()
                        .HasMaxLength(255)
                        .HasColumnType("character varying(255)");

                    b.Property<int>("RetryCount")
                        .HasColumnType("integer");

                    b.Property<DateTime?>("SentAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Subject")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("TemplateName")
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Notifications");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationLog", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Action")
                        .IsRequired()
                        .HasMaxLength(50)
                        .HasColumnType("character varying(50)");

                    b.Property<decimal?>("Cost")
                        .HasPrecision(18, 6)
                        .HasColumnType("numeric(18,6)");

                    b.Property<string>("Details")
                        .HasMaxLength(2000)
                        .HasColumnType("character varying(2000)");

                    b.Property<string>("ErrorMessage")
                        .HasMaxLength(2000)
                        .HasColumnType("character varying(2000)");

                    b.Property<string>("IpAddress")
                        .HasMaxLength(45)
                        .HasColumnType("character varying(45)");

                    b.Property<string>("Metadata")
                        .HasColumnType("text");

                    b.Property<Guid>("NotificationId")
                        .HasColumnType("uuid");

                    b.Property<string>("ProviderMessageId")
                        .HasMaxLength(200)
                        .HasColumnType("character varying(200)");

                    b.Property<string>("ProviderResponse")
                        .HasMaxLength(1000)
                        .HasColumnType("character varying(1000)");

                    b.Property<DateTime>("Timestamp")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("UserAgent")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.HasKey("Id");

                    b.HasIndex("Action");

                    b.HasIndex("NotificationId");

                    b.HasIndex("Timestamp");

                    b.HasIndex("NotificationId", "Timestamp");

                    b.ToTable("NotificationLogs");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationQueue", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("ErrorMessage")
                        .HasMaxLength(1000)
                        .HasColumnType("character varying(1000)");

                    b.Property<Guid>("NotificationId")
                        .HasColumnType("uuid");

                    b.Property<DateTime?>("ProcessedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTime>("QueuedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<int>("RetryCount")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("NotificationId");

                    b.ToTable("NotificationQueues");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationTemplate", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Body")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsActive")
                        .HasColumnType("boolean");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)");

                    b.Property<string>("Subject")
                        .IsRequired()
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTime?>("UpdatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Variables")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("Name")
                        .IsUnique();

                    b.ToTable("NotificationTemplates");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationLog", b =>
                {
                    b.HasOne("NotificationService.Domain.Entities.Notification", "Notification")
                        .WithMany()
                        .HasForeignKey("NotificationId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Notification");
                });

            modelBuilder.Entity("NotificationService.Domain.Entities.NotificationQueue", b =>
                {
                    b.HasOne("NotificationService.Domain.Entities.Notification", "Notification")
                        .WithMany()
                        .HasForeignKey("NotificationId")
                        .OnDelete(DeleteBehavior.Cascade)
                        .IsRequired();

                    b.Navigation("Notification");
                });
#pragma warning restore 612, 618
        }
    }
}

---- File: NotificationService.Infrastructure\Persistence\ApplicationDbContext.cs ----
using Microsoft.EntityFrameworkCore;
using NotificationService.Domain.Entities;

namespace NotificationService.Infrastructure.Persistence;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }

    public DbSet<Notification> Notifications { get; set; } = null!;
    public DbSet<NotificationTemplate> NotificationTemplates { get; set; } = null!;
    public DbSet<NotificationQueue> NotificationQueues { get; set; } = null!;
    public DbSet<NotificationLog> NotificationLogs { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
    }
}

---- File: NotificationService.Infrastructure\Persistence\EfNotificationLogRepository.cs ----
using Microsoft.EntityFrameworkCore;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Interfaces.Repositories;

namespace NotificationService.Infrastructure.Persistence;

public class EfNotificationLogRepository : INotificationLogRepository
{
    private readonly ApplicationDbContext _context;

    public EfNotificationLogRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<IEnumerable<NotificationLog>> GetByNotificationIdAsync(Guid notificationId)
    {
        return await _context.NotificationLogs
            .Where(l => l.NotificationId == notificationId)
            .OrderByDescending(l => l.Timestamp)
            .ToListAsync();
    }

    public async Task<IEnumerable<NotificationLog>> GetByActionAsync(string action, DateTime startDate, DateTime endDate)
    {
        return await _context.NotificationLogs
            .Where(l => l.Action == action && l.Timestamp >= startDate && l.Timestamp <= endDate)
            .OrderByDescending(l => l.Timestamp)
            .ToListAsync();
    }

    public async Task AddAsync(NotificationLog log)
    {
        await _context.NotificationLogs.AddAsync(log);
        await _context.SaveChangesAsync();
    }

    public async Task AddRangeAsync(IEnumerable<NotificationLog> logs)
    {
        await _context.NotificationLogs.AddRangeAsync(logs);
        await _context.SaveChangesAsync();
    }

    public async Task<int> GetLogCountByNotificationAsync(Guid notificationId)
    {
        return await _context.NotificationLogs
            .CountAsync(l => l.NotificationId == notificationId);
    }

    public async Task<int> CleanupOldLogsAsync(DateTime cutoffDate)
    {
        var oldLogs = await _context.NotificationLogs
            .Where(l => l.Timestamp < cutoffDate)
            .ToListAsync();

        _context.NotificationLogs.RemoveRange(oldLogs);
        return await _context.SaveChangesAsync();
    }
}

---- File: NotificationService.Infrastructure\Persistence\EfNotificationQueueRepository.cs ----
using Microsoft.EntityFrameworkCore;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Interfaces.Repositories;

namespace NotificationService.Infrastructure.Persistence;

public class EfNotificationQueueRepository : INotificationQueueRepository
{
    private readonly ApplicationDbContext _context;

    public EfNotificationQueueRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<NotificationQueue?> GetNextPendingAsync()
    {
        return await _context.NotificationQueues
            .Include(q => q.Notification)
            .Where(q => q.Status == Domain.Enums.QueueStatus.Pending)
            .OrderBy(q => q.QueuedAt)
            .FirstOrDefaultAsync();
    }

    public async Task<IEnumerable<NotificationQueue>> GetPendingAsync()
    {
        return await _context.NotificationQueues
            .Include(q => q.Notification)
            .Where(q => q.Status == Domain.Enums.QueueStatus.Pending)
            .OrderBy(q => q.QueuedAt)
            .ToListAsync();
    }

    public async Task<IEnumerable<NotificationQueue>> GetRetryQueueAsync()
    {
        return await _context.NotificationQueues
            .Include(q => q.Notification)
            .Where(q => q.Status == Domain.Enums.QueueStatus.Retry && q.NextRetryAt <= DateTime.UtcNow)
            .OrderBy(q => q.NextRetryAt)
            .ToListAsync();
    }

    public async Task AddAsync(NotificationQueue queue)
    {
        await _context.NotificationQueues.AddAsync(queue);
        await _context.SaveChangesAsync();
    }

    public async Task AddRangeAsync(IEnumerable<NotificationQueue> queues)
    {
        await _context.NotificationQueues.AddRangeAsync(queues);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateAsync(NotificationQueue queue)
    {
        _context.NotificationQueues.Update(queue);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateRangeAsync(IEnumerable<NotificationQueue> queues)
    {
        _context.NotificationQueues.UpdateRange(queues);
        await _context.SaveChangesAsync();
    }

    public async Task<int> GetPendingCountAsync()
    {
        return await _context.NotificationQueues
            .CountAsync(q => q.Status == Domain.Enums.QueueStatus.Pending);
    }

    public async Task<int> CleanupProcessedAsync(DateTime cutoffDate)
    {
        var processedQueues = await _context.NotificationQueues
            .Where(q => q.ProcessedAt.HasValue && q.ProcessedAt.Value < cutoffDate)
            .ToListAsync();

        _context.NotificationQueues.RemoveRange(processedQueues);
        return await _context.SaveChangesAsync();
    }
}

---- File: NotificationService.Infrastructure\Persistence\EfNotificationRepository.cs ----
using Microsoft.EntityFrameworkCore;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Enums;
using NotificationService.Domain.Interfaces.Repositories;

namespace NotificationService.Infrastructure.Persistence;

public class EfNotificationRepository : INotificationRepository
{
    private readonly ApplicationDbContext _context;

    public EfNotificationRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<Notification?> GetByIdAsync(Guid id)
    {
        return await _context.Notifications.FindAsync(id);
    }

    public async Task<IEnumerable<Notification>> GetByStatusAsync(NotificationStatus status)
    {
        return await _context.Notifications
            .Where(n => n.Status == status)
            .ToListAsync();
    }

    public async Task<IEnumerable<Notification>> GetByRecipientAsync(string recipient)
    {
        return await _context.Notifications
            .Where(n => n.Recipient == recipient)
            .ToListAsync();
    }

    public async Task<IEnumerable<Notification>> GetByTypeAsync(NotificationType type)
    {
        return await _context.Notifications
            .Where(n => n.Type == type)
            .ToListAsync();
    }

    public async Task<IEnumerable<Notification>> GetByProviderAsync(NotificationProvider provider)
    {
        return await _context.Notifications
            .Where(n => n.Provider == provider)
            .ToListAsync();
    }

    public async Task<IEnumerable<Notification>> GetByDateRangeAsync(DateTime startDate, DateTime endDate)
    {
        return await _context.Notifications
            .Where(n => n.CreatedAt >= startDate && n.CreatedAt <= endDate)
            .ToListAsync();
    }

    public async Task<IEnumerable<Notification>> GetFailedNotificationsAsync(DateTime since)
    {
        return await _context.Notifications
            .Where(n => n.Status == NotificationStatus.Failed && n.CreatedAt >= since)
            .ToListAsync();
    }

    public async Task<IEnumerable<Notification>> GetPendingNotificationsAsync()
    {
        return await _context.Notifications
            .Where(n => n.Status == NotificationStatus.Pending)
            .ToListAsync();
    }

    public async Task AddAsync(Notification notification)
    {
        await _context.Notifications.AddAsync(notification);
        await _context.SaveChangesAsync();
    }

    public async Task AddRangeAsync(IEnumerable<Notification> notifications)
    {
        await _context.Notifications.AddRangeAsync(notifications);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateAsync(Notification notification)
    {
        _context.Notifications.Update(notification);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateRangeAsync(IEnumerable<Notification> notifications)
    {
        _context.Notifications.UpdateRange(notifications);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteAsync(Guid id)
    {
        var notification = await GetByIdAsync(id);
        if (notification != null)
        {
            _context.Notifications.Remove(notification);
            await _context.SaveChangesAsync();
        }
    }

    public async Task<int> GetCountByStatusAsync(NotificationStatus status)
    {
        return await _context.Notifications
            .CountAsync(n => n.Status == status);
    }

    public async Task<int> GetCountByRecipientAsync(string recipient)
    {
        return await _context.Notifications
            .CountAsync(n => n.Recipient == recipient);
    }

    public async Task<bool> ExistsAsync(Guid id)
    {
        return await _context.Notifications
            .AnyAsync(n => n.Id == id);
    }

    public async Task<IEnumerable<Notification>> GetNotificationsWithPaginationAsync(int pageNumber, int pageSize)
    {
        return await _context.Notifications
            .OrderByDescending(n => n.CreatedAt)
            .Skip((pageNumber - 1) * pageSize)
            .Take(pageSize)
            .ToListAsync();
    }

    public async Task<int> GetTotalCountAsync()
    {
        return await _context.Notifications.CountAsync();
    }

    public async Task<IEnumerable<Notification>> GetRecentNotificationsAsync(int count = 50)
    {
        return await _context.Notifications
            .OrderByDescending(n => n.CreatedAt)
            .Take(count)
            .ToListAsync();
    }

    public async Task<int> CleanupOldNotificationsAsync(DateTime cutoffDate)
    {
        var oldNotifications = await _context.Notifications
            .Where(n => n.CreatedAt < cutoffDate)
            .ToListAsync();

        _context.Notifications.RemoveRange(oldNotifications);
        return await _context.SaveChangesAsync();
    }
}

---- File: NotificationService.Infrastructure\Persistence\EfNotificationTemplateRepository.cs ----
using Microsoft.EntityFrameworkCore;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Enums;
using NotificationService.Domain.Interfaces.Repositories;

namespace NotificationService.Infrastructure.Persistence;

public class EfNotificationTemplateRepository : INotificationTemplateRepository
{
    private readonly ApplicationDbContext _context;

    public EfNotificationTemplateRepository(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<NotificationTemplate?> GetByIdAsync(Guid id)
    {
        return await _context.NotificationTemplates.FindAsync(id);
    }

    public async Task<NotificationTemplate?> GetByNameAsync(string name)
    {
        return await _context.NotificationTemplates
            .FirstOrDefaultAsync(t => t.Name == name && t.IsActive);
    }

    public async Task<IEnumerable<NotificationTemplate>> GetByTypeAsync(NotificationType type)
    {
        return await _context.NotificationTemplates
            .Where(t => t.Type == type && t.IsActive)
            .ToListAsync();
    }

    public async Task<IEnumerable<NotificationTemplate>> GetActiveTemplatesAsync()
    {
        return await _context.NotificationTemplates
            .Where(t => t.IsActive)
            .ToListAsync();
    }

    public async Task AddAsync(NotificationTemplate template)
    {
        await _context.NotificationTemplates.AddAsync(template);
        await _context.SaveChangesAsync();
    }

    public async Task UpdateAsync(NotificationTemplate template)
    {
        template.UpdatedAt = DateTime.UtcNow;
        _context.NotificationTemplates.Update(template);
        await _context.SaveChangesAsync();
    }

    public async Task DeleteAsync(Guid id)
    {
        var template = await GetByIdAsync(id);
        if (template != null)
        {
            _context.NotificationTemplates.Remove(template);
            await _context.SaveChangesAsync();
        }
    }

    public async Task<bool> ExistsAsync(string name)
    {
        return await _context.NotificationTemplates
            .AnyAsync(t => t.Name == name);
    }
}

---- File: NotificationService.Infrastructure\Persistence\Configurations\NotificationConfiguration.cs ----
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Enums;
using System.Text.Json;

namespace NotificationService.Infrastructure.Persistence.Configurations;

public class NotificationConfiguration : IEntityTypeConfiguration<Notification>
{
    public void Configure(EntityTypeBuilder<Notification> builder)
    {
        builder.ToTable("notifications");

        builder.HasKey(n => n.Id);

        builder.Property(n => n.Id)
            .HasColumnName("id")
            .IsRequired();

        builder.Property(n => n.Type)
            .HasColumnName("type")
            .IsRequired()
            .HasConversion<string>()
            .HasMaxLength(20);

        builder.Property(n => n.Recipient)
            .HasColumnName("recipient")
            .IsRequired()
            .HasMaxLength(255);

        builder.Property(n => n.Subject)
            .HasColumnName("subject")
            .HasMaxLength(500);

        builder.Property(n => n.Content)
            .HasColumnName("content")
            .IsRequired();

        builder.Property(n => n.Status)
            .HasColumnName("status")
            .IsRequired()
            .HasConversion<string>()
            .HasMaxLength(20);

        builder.Property(n => n.Provider)
            .HasColumnName("provider")
            .IsRequired()
            .HasConversion<string>()
            .HasMaxLength(20);

        builder.Property(n => n.Priority)
            .HasColumnName("priority")
            .IsRequired()
            .HasConversion<string>()
            .HasMaxLength(20);

        builder.Property(n => n.CreatedAt)
            .HasColumnName("created_at")
            .IsRequired();

        builder.Property(n => n.SentAt)
            .HasColumnName("sent_at");

        builder.Property(n => n.RetryCount)
            .HasColumnName("retry_count")
            .IsRequired();

        builder.Property(n => n.ErrorMessage)
            .HasColumnName("error_message")
            .HasMaxLength(1000);

        builder.Property(n => n.TemplateName)
            .HasColumnName("template_name")
            .HasMaxLength(100);

        builder.Property(n => n.Metadata)
            .HasColumnName("metadata")
            .HasColumnType("jsonb")
            .HasConversion(
                v => v == null ? null : JsonSerializer.Serialize(v, new JsonSerializerOptions()),
                v => v == null ? null : JsonSerializer.Deserialize<Dictionary<string, object>>(v, new JsonSerializerOptions())
            );

        // Índices
        builder.HasIndex(n => n.Type);
        builder.HasIndex(n => n.Status);
        builder.HasIndex(n => n.Recipient);
        builder.HasIndex(n => n.CreatedAt);
        builder.HasIndex(n => n.Provider);
        builder.HasIndex(n => new { n.Type, n.Status });
        builder.HasIndex(n => new { n.Recipient, n.CreatedAt });
    }
}

---- File: NotificationService.Infrastructure\Persistence\Configurations\NotificationLogConfiguration.cs ----
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NotificationService.Domain.Entities;
using System.Text.Json;

namespace NotificationService.Infrastructure.Persistence.Configurations;

public class NotificationLogConfiguration : IEntityTypeConfiguration<NotificationLog>
{
    public void Configure(EntityTypeBuilder<NotificationLog> builder)
    {
        builder.HasKey(l => l.Id);
        
        builder.Property(l => l.Action)
            .IsRequired()
            .HasMaxLength(50);

        builder.Property(l => l.Details)
            .HasMaxLength(2000);

        builder.Property(l => l.ErrorMessage)
            .HasMaxLength(2000);

        builder.Property(l => l.Timestamp)
            .IsRequired();

        builder.Property(l => l.ProviderResponse)
            .HasMaxLength(1000);

        builder.Property(l => l.ProviderMessageId)
            .HasMaxLength(200);

        builder.Property(l => l.Cost)
            .HasPrecision(18, 6);

        builder.Property(l => l.IpAddress)
            .HasMaxLength(45); // Support for IPv6

        builder.Property(l => l.UserAgent)
            .HasMaxLength(500);

        builder.HasOne(l => l.Notification)
            .WithMany()
            .HasForeignKey(l => l.NotificationId)
            .OnDelete(DeleteBehavior.Cascade);

        // Indexes for better query performance
        builder.HasIndex(l => l.NotificationId);
        builder.HasIndex(l => l.Action);
        builder.HasIndex(l => l.Timestamp);
        builder.HasIndex(l => new { l.NotificationId, l.Timestamp });

        // Configure JSON conversion for Metadata
        builder.Property(l => l.Metadata)
            .HasConversion(
                v => v == null ? null : JsonSerializer.Serialize(v, (JsonSerializerOptions?)null),
                v => v == null ? null : JsonSerializer.Deserialize<Dictionary<string, object>>(v, (JsonSerializerOptions?)null)
            );
    }
}

---- File: NotificationService.Infrastructure\Persistence\Configurations\NotificationQueueConfiguration.cs ----
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NotificationService.Domain.Entities;

namespace NotificationService.Infrastructure.Persistence.Configurations;

public class NotificationQueueConfiguration : IEntityTypeConfiguration<NotificationQueue>
{
    public void Configure(EntityTypeBuilder<NotificationQueue> builder)
    {
        builder.HasKey(q => q.Id);
        
        builder.Property(q => q.QueuedAt)
            .IsRequired();

        builder.Property(q => q.ProcessedAt);

        builder.Property(q => q.RetryCount)
            .IsRequired();

        builder.Property(q => q.ErrorMessage)
            .HasMaxLength(1000);

        builder.Property(q => q.Status)
            .IsRequired()
            .HasConversion<string>();

        builder.HasOne(q => q.Notification)
            .WithMany()
            .HasForeignKey(q => q.NotificationId)
            .OnDelete(DeleteBehavior.Cascade);
    }
}

---- File: NotificationService.Infrastructure\Persistence\Configurations\NotificationTemplateConfiguration.cs ----
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Enums;
using System.Text.Json;

namespace NotificationService.Infrastructure.Persistence.Configurations;

public class NotificationTemplateConfiguration : IEntityTypeConfiguration<NotificationTemplate>
{
    public void Configure(EntityTypeBuilder<NotificationTemplate> builder)
    {
        builder.ToTable("notification_templates");

        builder.HasKey(t => t.Id);

        builder.Property(t => t.Id)
            .HasColumnName("id")
            .IsRequired();

        builder.Property(t => t.Name)
            .HasColumnName("name")
            .IsRequired()
            .HasMaxLength(100);

        builder.Property(t => t.Subject)
            .HasColumnName("subject")
            .HasMaxLength(500);

        builder.Property(t => t.Body)
            .HasColumnName("body")
            .IsRequired();

        builder.Property(t => t.Type)
            .HasColumnName("type")
            .IsRequired()
            .HasConversion<string>()
            .HasMaxLength(20);

        builder.Property(t => t.IsActive)
            .HasColumnName("is_active")
            .IsRequired();

        builder.Property(t => t.CreatedAt)
            .HasColumnName("created_at")
            .IsRequired();

        builder.Property(t => t.UpdatedAt)
            .HasColumnName("updated_at");

        builder.Property(t => t.Description)
            .HasColumnName("description")
            .HasMaxLength(1000);

        builder.Property(t => t.Category)
            .HasColumnName("category")
            .HasMaxLength(100);

        builder.Property(t => t.Variables)
            .HasColumnName("variables")
            .HasColumnType("jsonb")
            .HasConversion(
                v => v == null ? null : JsonSerializer.Serialize(v, new JsonSerializerOptions()),
                v => v == null ? null : JsonSerializer.Deserialize<Dictionary<string, string>>(v, new JsonSerializerOptions())
            );

        builder.HasIndex(t => t.Name)
            .IsUnique();

        builder.HasIndex(t => t.Type);
        builder.HasIndex(t => t.IsActive);
        builder.HasIndex(t => t.Category);
    }
}

---- File: NotificationService.Infrastructure\Services\ErrorServiceClient.cs ----
// NotificationService.Infrastructure\Services\ErrorServiceClient.cs
using System.Net.Http.Json; // ✅ Agregar este using
using System.Text.Json;
using Microsoft.Extensions.Logging;

namespace NotificationService.Infrastructure.Services;

public class ErrorServiceClient
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<ErrorServiceClient> _logger;

    public ErrorServiceClient(HttpClient httpClient, ILogger<ErrorServiceClient> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task ReportErrorAsync(string serviceName, string errorType, string message,
        string? stackTrace = null, Dictionary<string, object>? metadata = null)
    {
        try
        {
            var errorRequest = new
            {
                ServiceName = serviceName,
                ExceptionType = errorType,
                Message = message,
                StackTrace = stackTrace,
                OccurredAt = DateTime.UtcNow,
                Metadata = metadata ?? new Dictionary<string, object>()
            };

            // ✅ Ahora PostAsJsonAsync estará disponible
            var response = await _httpClient.PostAsJsonAsync("/api/errors", errorRequest);

            if (!response.IsSuccessStatusCode)
            {
                _logger.LogWarning("Failed to report error to ErrorService: {StatusCode}", response.StatusCode);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error communicating with ErrorService");
        }
    }
}

---- File: NotificationService.Infrastructure\Services\NotificationQueueBackgroundService.cs ----
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;

namespace NotificationService.Infrastructure.Services;

public class NotificationQueueBackgroundService : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<NotificationQueueBackgroundService> _logger;
    private readonly TimeSpan _interval = TimeSpan.FromSeconds(30); // Procesar cada 30 segundos

    public NotificationQueueBackgroundService(
        IServiceProvider serviceProvider,
        ILogger<NotificationQueueBackgroundService> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("🔄 Notification Queue Background Service started");

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                using var scope = _serviceProvider.CreateScope();
                var queueService = scope.ServiceProvider.GetRequiredService<NotificationQueueService>();

                await queueService.ProcessPendingQueueAsync();
                _logger.LogDebug("✅ Processed notification queue cycle");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "❌ Error processing notification queue");
            }

            await Task.Delay(_interval, stoppingToken);
        }

        _logger.LogInformation("🛑 Notification Queue Background Service stopped");
    }
}

---- File: NotificationService.Infrastructure\Services\NotificationQueueService.cs ----
using Microsoft.Extensions.Logging;
using NotificationService.Domain.Entities;
using NotificationService.Domain.Enums;
using NotificationService.Domain.Interfaces.Repositories;
using NotificationService.Domain.Interfaces.External;

namespace NotificationService.Infrastructure.Services;

public class NotificationQueueService
{
    private readonly INotificationQueueRepository _queueRepository;
    private readonly INotificationRepository _notificationRepository;
    private readonly INotificationLogRepository _logRepository;
    private readonly IEmailProvider _emailProvider;
    private readonly ISmsProvider _smsProvider;
    private readonly IPushNotificationProvider _pushProvider;
    private readonly ILogger<NotificationQueueService> _logger;

    public NotificationQueueService(
        INotificationQueueRepository queueRepository,
        INotificationRepository notificationRepository,
        INotificationLogRepository logRepository,
        IEmailProvider emailProvider,
        ISmsProvider smsProvider,
        IPushNotificationProvider pushProvider,
        ILogger<NotificationQueueService> logger)
    {
        _queueRepository = queueRepository;
        _notificationRepository = notificationRepository;
        _logRepository = logRepository;
        _emailProvider = emailProvider;
        _smsProvider = smsProvider;
        _pushProvider = pushProvider;
        _logger = logger;
    }

    public async Task ProcessPendingQueueAsync()
    {
        _logger.LogInformation("Starting queue processing");

        try
        {
            var pendingQueues = await _queueRepository.GetPendingAsync();

            foreach (var queue in pendingQueues)
            {
                await ProcessQueueItemAsync(queue);
            }

            _logger.LogInformation("Queue processing completed");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error during queue processing");
        }
    }

    private async Task ProcessQueueItemAsync(NotificationQueue queue)
    {
        try
        {
            _logger.LogInformation("Processing queue item {QueueId} for notification {NotificationId}",
                queue.Id, queue.NotificationId);

            queue.MarkAsProcessing();
            await _queueRepository.UpdateAsync(queue);

            var notification = await _notificationRepository.GetByIdAsync(queue.NotificationId);
            if (notification == null)
            {
                _logger.LogWarning("Notification {NotificationId} not found for queue item {QueueId}",
                    queue.NotificationId, queue.Id);
                return;
            }

            var (success, messageId, error) = await ProcessNotificationAsync(notification);

            if (success)
            {
                notification.MarkAsSent();
                await _logRepository.AddAsync(NotificationLog.CreateSent(notification.Id, messageId));
                queue.MarkAsCompleted();
                _logger.LogInformation("Successfully processed notification {NotificationId}", notification.Id);
            }
            else
            {
                if (notification.CanRetry())
                {
                    notification.MarkAsFailed(error ?? "Unknown error");
                    queue.MarkAsFailed(error ?? "Unknown error");
                    _logger.LogWarning("Failed to process notification {NotificationId}, will retry: {Error}",
                        notification.Id, error);
                }
                else
                {
                    notification.MarkAsFailed(error ?? "Unknown error");
                    queue.MarkAsFailed(error ?? "Unknown error");
                    _logger.LogError("Failed to process notification {NotificationId} after retries: {Error}",
                        notification.Id, error);
                }

                await _logRepository.AddAsync(NotificationLog.CreateFailed(notification.Id, error ?? "Unknown error"));
            }

            await _notificationRepository.UpdateAsync(notification);
            await _queueRepository.UpdateAsync(queue);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing queue item {QueueId}", queue.Id);
            queue.MarkAsFailed(ex.Message);
            await _queueRepository.UpdateAsync(queue);
        }
    }

    private async Task<(bool success, string? messageId, string? error)> ProcessNotificationAsync(Notification notification)
    {
        try
        {
            return notification.Type switch
            {
                NotificationType.Email => await _emailProvider.SendAsync(
                    notification.Recipient,
                    notification.Subject,
                    notification.Content,
                    true,
                    notification.Metadata
                ),
                NotificationType.Sms => await _smsProvider.SendAsync(
                    notification.Recipient,
                    notification.Content,
                    notification.Metadata
                ),
                NotificationType.Push => await _pushProvider.SendAsync(
                    notification.Recipient,
                    notification.Subject,
                    notification.Content,
                    null,
                    notification.Metadata
                ),
                _ => (false, null, $"Unsupported notification type: {notification.Type}")
            };
        }
        catch (Exception ex)
        {
            return (false, null, ex.Message);
        }
    }
}

---- File: NotificationService.Infrastructure\Services\TemplateService.cs ----
using Microsoft.Extensions.Options;
using NotificationService.Domain.Interfaces; // ✅ CORRECTO - Domain
using NotificationService.Shared;

namespace NotificationService.Infrastructure.Services;

public class TemplateService : ITemplateEngine // ✅ Implementa interfaz de Domain
{
    private readonly string _templatesPath;

    public TemplateService(IOptions<NotificationSettings> settings)
    {
        _templatesPath = settings.Value.TemplatesPath ?? "Templates";
    }

    public async Task<string> RenderTemplateAsync(string templateName, Dictionary<string, object> parameters)
    {
        var templatePath = Path.Combine(_templatesPath, templateName);
        if (!File.Exists(templatePath))
            throw new FileNotFoundException($"Template {templateName} not found at {templatePath}");

        var templateContent = await File.ReadAllTextAsync(templatePath);

        foreach (var param in parameters)
        {
            templateContent = templateContent.Replace($"{{{{ {param.Key} }}}}", param.Value?.ToString() ?? string.Empty);
        }

        return templateContent;
    }
}

---- File: NotificationService.Infrastructure\Templates\TemplateEngine.cs ----
using Microsoft.Extensions.Options;
using NotificationService.Domain.Interfaces;
using NotificationService.Shared;

namespace NotificationService.Infrastructure.Templates;

public class TemplateEngine : ITemplateEngine
{
    private readonly string _templatesPath;

    public TemplateEngine(IOptions<NotificationSettings> settings)
    {
        _templatesPath = settings.Value.TemplatesPath ?? "Templates";
    }

    public async Task<string> RenderTemplateAsync(string templateName, Dictionary<string, object> parameters)
    {
        var templatePath = Path.Combine(_templatesPath, templateName);
        if (!File.Exists(templatePath))
            throw new FileNotFoundException($"Template {templateName} not found at {templatePath}");

        var templateContent = await File.ReadAllTextAsync(templatePath);

        foreach (var param in parameters)
        {
            templateContent = templateContent.Replace($"{{{{ {param.Key} }}}}", param.Value?.ToString() ?? string.Empty);
        }

        return templateContent;
    }
}

---- File: NotificationService.Infrastructure\Templates\EmailTemplates\ContactNotification.html ----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Contact Notification</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #007cba; color: white; padding: 20px; text-align: center; }
        .content { background: #f9f9f9; padding: 20px; }
        .footer { background: #333; color: white; padding: 10px; text-align: center; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>New Contact Message</h1>
        </div>
        <div class="content">
            <p><strong>Name:</strong> {{ Name }}</p>
            <p><strong>Email:</strong> {{ Email }}</p>
            <p><strong>Phone:</strong> {{ Phone }}</p>
            <p><strong>Message:</strong></p>
            <p>{{ Message }}</p>
            <p><strong>Received:</strong> {{ Timestamp }}</p>
        </div>
        <div class="footer">
            <p>&copy; {{ Year }} Your Company. All rights reserved.</p>
        </div>
    </div>
</body>
</html>

---- File: NotificationService.Infrastructure\Templates\EmailTemplates\PasswordReset.html ----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Password Reset Request</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #dc3545; color: white; padding: 20px; text-align: center; }
        .content { background: #f9f9f9; padding: 20px; }
        .footer { background: #333; color: white; padding: 10px; text-align: center; }
        .button { background: #007cba; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; }
        .warning { color: #dc3545; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Password Reset Request</h1>
        </div>
        <div class="content">
            <p>Hello {{ UserName }},</p>
            <p>We received a request to reset your password. If you didn't make this request, please ignore this email.</p>
            <p>To reset your password, click the button below:</p>
            <p style="text-align: center;">
                <a href="{{ ResetUrl }}" class="button">Reset Password</a>
            </p>
            <p class="warning">This link will expire in {{ ExpiryHours }} hours.</p>
            <p>If the button doesn't work, copy and paste this link into your browser:</p>
            <p>{{ ResetUrl }}</p>
        </div>
        <div class="footer">
            <p>&copy; {{ Year }} Your Company. All rights reserved.</p>
        </div>
    </div>
</body>
</html>

---- File: NotificationService.Infrastructure\Templates\EmailTemplates\WelcomeEmail.html ----
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Welcome to Our Service</title>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
        .container { max-width: 600px; margin: 0 auto; padding: 20px; }
        .header { background: #28a745; color: white; padding: 20px; text-align: center; }
        .content { background: #f9f9f9; padding: 20px; }
        .footer { background: #333; color: white; padding: 10px; text-align: center; }
        .button { background: #007cba; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Welcome to Our Service!</h1>
        </div>
        <div class="content">
            <p>Hello {{ UserName }},</p>
            <p>Thank you for joining our platform. We're excited to have you on board!</p>
            <p>Your account has been successfully created and you can now start using all our features.</p>
            <p style="text-align: center;">
                <a href="{{ LoginUrl }}" class="button">Get Started</a>
            </p>
            <p>If you have any questions, feel free to contact our support team.</p>
        </div>
        <div class="footer">
            <p>&copy; {{ Year }} Your Company. All rights reserved.</p>
        </div>
    </div>
</body>
</html>

---- File: NotificationService.Shared\ApiResponse.cs ----
namespace NotificationService.Shared;

public class ApiResponse<T>
{
    public bool Success { get; set; }
    public string Message { get; set; } = string.Empty;
    public T? Data { get; set; }
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    public static ApiResponse<T> SuccessResponse(T data, string message = "Success")
    {
        return new ApiResponse<T> { Success = true, Message = message, Data = data };
    }

    public static ApiResponse<T> ErrorResponse(string message)
    {
        return new ApiResponse<T> { Success = false, Message = message };
    }
}

---- File: NotificationService.Shared\NotificationService.Shared.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <RootNamespace>NotificationService.Shared</RootNamespace>
    <AssemblyName>NotificationService.Shared</AssemblyName>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Options" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Binder" Version="8.0.0" />
  </ItemGroup>

</Project>

---- File: NotificationService.Shared\NotificationSettings.cs ----
namespace NotificationService.Shared;

public class NotificationSettings
{
    public SendGridSettings SendGrid { get; set; } = new();
    public TwilioSettings Twilio { get; set; } = new();
    public FirebaseSettings Firebase { get; set; } = new();
    public string TemplatesPath { get; set; } = "Templates";
    public int MaxRetryAttempts { get; set; } = 3;
    public int RetryDelayInSeconds { get; set; } = 60;
    public bool EnableQueueProcessing { get; set; } = true;
    public int QueueBatchSize { get; set; } = 100;
}

public class SendGridSettings
{
    public string ApiKey { get; set; } = string.Empty;
    public string FromEmail { get; set; } = string.Empty;
    public string FromName { get; set; } = string.Empty;
    public bool EnableTracking { get; set; } = true;
    public string WebhookSecret { get; set; } = string.Empty;
}

public class TwilioSettings
{
    public string AccountSid { get; set; } = string.Empty;
    public string AuthToken { get; set; } = string.Empty;
    public string FromNumber { get; set; } = string.Empty;
}

public class FirebaseSettings
{
    public string ServiceAccountKeyPath { get; set; } = string.Empty;
    public string ProjectId { get; set; } = string.Empty;
}

---- File: NotificationService.Shared\Constants\CacheConstants.cs ----
namespace NotificationService.Shared.Constants;

public static class CacheConstants
{
    public const string NotificationTemplateCacheKey = "NotificationTemplates";
    public const string NotificationSettingsCacheKey = "NotificationSettings";
    public const string ProviderStatusCacheKey = "ProviderStatus";
    public const int CacheExpirationInMinutes = 30;
    public const int TemplateCacheExpirationInHours = 24;
}

---- File: NotificationService.Shared\Constants\NotificationConstants.cs ----
namespace NotificationService.Shared.Constants;

public static class NotificationConstants
{
    public const int MaxRetryCount = 3;
    public const int QueueBatchSize = 100;
    public const int DefaultPageSize = 20;
    public const int MaxEmailSubjectLength = 200;
    public const int MaxSmsMessageLength = 160;
    public const int MaxPushTitleLength = 100;
    public const int MaxPushBodyLength = 200;
    
    public static class Templates
    {
        public const string WelcomeEmail = "WelcomeEmail";
        public const string PasswordReset = "PasswordReset";
        public const string ContactNotification = "ContactNotification";
        public const string OrderConfirmation = "OrderConfirmation";
        public const string PaymentReceipt = "PaymentReceipt";
        public const string SecurityAlert = "SecurityAlert";
    }

    public static class Providers
    {
        public const string SendGrid = "SendGrid";
        public const string Twilio = "Twilio";
        public const string Firebase = "Firebase";
    }

    public static class QueueNames
    {
        public const string EmailQueue = "notification_email_queue";
        public const string SmsQueue = "notification_sms_queue";
        public const string PushQueue = "notification_push_queue";
        public const string RetryQueue = "notification_retry_queue";
    }

    public static class Validation
    {
        public const string EmailRequired = "Email address is required";
        public const string EmailInvalid = "Invalid email address format";
        public const string PhoneRequired = "Phone number is required";
        public const string SubjectRequired = "Subject is required";
        public const string MessageRequired = "Message content is required";
        public const string DeviceTokenRequired = "Device token is required";
    }
}

