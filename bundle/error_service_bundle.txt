## Code Bundle - Aggregated Files
## Microservicio: backend\ErrorService
## Generado: 10/29/2025 18:33:20
## Carpetas excluidas: bin, obj, Properties

---- File: ErrorService.sln ----

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ErrorService.Api", "ErrorService.Api\ErrorService.Api.csproj", "{574C44D4-3A75-4D46-A9DF-700FB5F02C7D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ErrorService.Shared", "ErrorService.Shared\ErrorService.Shared.csproj", "{55CBBF88-AC87-450C-8497-409F5C53857A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ErrorService.Application", "ErrorService.Application\ErrorService.Application.csproj", "{DADEBCEE-60A1-4489-860E-955E31152EA3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ErrorService.Infrastructure", "ErrorService.Infrastructure\ErrorService.Infrastructure.csproj", "{48AB1226-DFCB-4275-80F8-C4562F62E4B0}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ErrorService.Domain", "ErrorService.Domain\ErrorService.Domain.csproj", "{5EB5F505-5355-4B26-B50F-A48E14C9055E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{574C44D4-3A75-4D46-A9DF-700FB5F02C7D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{574C44D4-3A75-4D46-A9DF-700FB5F02C7D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{574C44D4-3A75-4D46-A9DF-700FB5F02C7D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{574C44D4-3A75-4D46-A9DF-700FB5F02C7D}.Release|Any CPU.Build.0 = Release|Any CPU
		{55CBBF88-AC87-450C-8497-409F5C53857A}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{55CBBF88-AC87-450C-8497-409F5C53857A}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{55CBBF88-AC87-450C-8497-409F5C53857A}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{55CBBF88-AC87-450C-8497-409F5C53857A}.Release|Any CPU.Build.0 = Release|Any CPU
		{DADEBCEE-60A1-4489-860E-955E31152EA3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{DADEBCEE-60A1-4489-860E-955E31152EA3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{DADEBCEE-60A1-4489-860E-955E31152EA3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{DADEBCEE-60A1-4489-860E-955E31152EA3}.Release|Any CPU.Build.0 = Release|Any CPU
		{48AB1226-DFCB-4275-80F8-C4562F62E4B0}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{48AB1226-DFCB-4275-80F8-C4562F62E4B0}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{48AB1226-DFCB-4275-80F8-C4562F62E4B0}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{48AB1226-DFCB-4275-80F8-C4562F62E4B0}.Release|Any CPU.Build.0 = Release|Any CPU
		{5EB5F505-5355-4B26-B50F-A48E14C9055E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5EB5F505-5355-4B26-B50F-A48E14C9055E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5EB5F505-5355-4B26-B50F-A48E14C9055E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5EB5F505-5355-4B26-B50F-A48E14C9055E}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal

---- File: ErrorService.Api\appsettings.Development.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore.Database.Command": "Information"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=errorservice_dev;Username=postgres;Password=password"
  },
  "ElasticSearch": {
    "ConnectionString": "http://localhost:9200",
    "DefaultIndex": "errorlogs_dev",
    "Enable": false
  }
}

---- File: ErrorService.Api\appsettings.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=errorservice;Username=postgres;Password=password"
  },
  "ElasticSearch": {
    "ConnectionString": "http://localhost:9200",
    "DefaultIndex": "errorlogs",
    "Enable": false
  },
  "RabbitMQ": {
    "Host": "rabbitmq",
    "Port": 5672,
    "Username": "guest",
    "Password": "guest",
    "VirtualHost": "/"
  },
  "ErrorService": {
    "QueueName": "error-queue",
    "ExchangeName": "error-exchange",
    "RoutingKey": "error.routing.key"
  }
}

---- File: ErrorService.Api\appsettings.Production.json ----
{
  "Logging": {
    "LogLevel": {
      "Default": "Warning",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=production-db;Database=errorservice;Username=postgres;Password=production-password"
  },
  "ElasticSearch": {
    "ConnectionString": "http://elasticsearch:9200",
    "DefaultIndex": "errorlogs",
    "Enable": true
  }
}

---- File: ErrorService.Api\Dockerfile.dev ----
FROM mcr.microsoft.com/dotnet/sdk:8.0

# Install dotnet-watch and debugger
RUN dotnet tool install --global dotnet-watch \
    && export PATH="$PATH:/root/.dotnet/tools" \
    && apt-get update \
    && apt-get install -y unzip curl \
    && curl -sSL https://aka.ms/getvsdbgsh | bash /dev/stdin -v latest -l /vsdbg

WORKDIR /app

# Copiar los archivos de proyecto de ErrorService y restaurar

COPY ErrorService/ErrorService.Api/ErrorService.Api.csproj ./ErrorService/ErrorService.Api/

# Restaurar los paquetes de ErrorService.Api
RUN dotnet restore "ErrorService/ErrorService.Api/ErrorService.Api.csproj"

# Development environment variables
ENV ASPNETCORE_ENVIRONMENT=Development \
    ASPNETCORE_URLS="http://+:80" \
    DOTNET_MSBUILD_CONFIGURATION=Debug \
    DOTNET_BUILD_CONFIGURATION=Debug \
    DOTNET_USE_POLLING_FILE_WATCHER=true \
    NUGET_XMLDOC_MODE=none

# Expose HTTP and debug ports
EXPOSE 80
EXPOSE 4022

# Start debugger and hot-reload
ENTRYPOINT ["bash", "-lc", "\
  /vsdbg/vsdbg --interpreter=vscode --server --port 4022 & \
  dotnet watch run --project ErrorService/ErrorService.Api/ErrorService.Api.csproj --urls http://0.0.0.0:80"]

---- File: ErrorService.Api\Dockerfile.prod ----
# Stage 1: Build
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# Copy solution and project files
COPY ErrorService/ErrorService.sln ./ErrorService/
COPY ErrorService/ErrorService.Api/ErrorService.Api.csproj ./ErrorService/ErrorService.Api/
COPY ErrorService/ErrorService.Application/ErrorService.Application.csproj ./ErrorService/ErrorService.Application/
COPY ErrorService/ErrorService.Domain/ErrorService.Domain.csproj ./ErrorService/ErrorService.Domain/
COPY ErrorService/ErrorService.Infrastructure/ErrorService.Infrastructure.csproj ./ErrorService/ErrorService.Infrastructure/
COPY ErrorService/ErrorService.Shared/ErrorService.Shared.csproj ./ErrorService/ErrorService.Shared/

# Restore packages
RUN dotnet restore "ErrorService/ErrorService.Api/ErrorService.Api.csproj" --verbosity quiet

# Copy source code and build
COPY ErrorService/ ./ErrorService/
WORKDIR "/src/ErrorService/ErrorService.Api"
RUN dotnet publish "ErrorService.Api.csproj" -c Release -o /app/publish \
    --no-restore \
    --verbosity minimal \
    -p:UseAppHost=false

# Stage 2: Runtime
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS runtime
WORKDIR /app

# Install curl for healthchecks
RUN apt-get update && \
    apt-get install -y --no-install-recommends curl && \
    rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN groupadd -r appuser && \
    useradd -r -g appuser -s /bin/false appuser && \
    chown -R appuser:appuser /app

USER appuser

# Copy published application
COPY --from=build --chown=appuser:appuser /app/publish .

# Environment variables
ENV ASPNETCORE_ENVIRONMENT=Production
ENV ASPNETCORE_URLS=http://+:80
ENV DOTNET_RUNNING_IN_CONTAINER=true
ENV DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=false

EXPOSE 80

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=30s --retries=3 \
    CMD curl -f http://localhost:80/health || exit 1

# Security: Run as non-root user
USER appuser

ENTRYPOINT ["dotnet", "ErrorService.Api.dll"]

---- File: ErrorService.Api\ErrorService.Api.csproj ----
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <GenerateDocumentationFile>true</GenerateDocumentationFile>
    <NoWarn>$(NoWarn);1591</NoWarn>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.8">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.8">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Serilog.Sinks.Console" Version="5.0.1" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.8" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ErrorService.Application\ErrorService.Application.csproj" />
    <ProjectReference Include="..\ErrorService.Infrastructure\ErrorService.Infrastructure.csproj" />
    <ProjectReference Include="..\ErrorService.Shared\ErrorService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: ErrorService.Api\ErrorService.Api.http ----
@ErrorService.Api_HostAddress = http://localhost:5083

### Health Check
GET {{ErrorService.Api_HostAddress}}/health
Accept: application/json

### Log an error
POST {{ErrorService.Api_HostAddress}}/api/errors
Content-Type: application/json

{
  "serviceName": "TestService",
  "exceptionType": "System.Exception",
  "message": "This is a test error",
  "stackTrace": "at TestService.Method() in TestService.cs:line 123",
  "endpoint": "/api/test",
  "httpMethod": "GET",
  "statusCode": 500,
  "userId": "test-user-123",
  "metadata": {
    "additionalInfo": "Some additional context"
  }
}

### Get errors
GET {{ErrorService.Api_HostAddress}}/api/errors
Accept: application/json

### Get error stats
GET {{ErrorService.Api_HostAddress}}/api/errors/stats
Accept: application/json

### Get service names
GET {{ErrorService.Api_HostAddress}}/api/errors/services
Accept: application/json

---- File: ErrorService.Api\Program.cs ----
using ErrorService.Domain.Interfaces;
using ErrorService.Infrastructure.Persistence;
using ErrorService.Infrastructure.Services;
using ErrorService.Infrastructure.Services.Messaging;
using ErrorService.Shared.Extensions;
using ErrorService.Shared.Middleware;
using Microsoft.EntityFrameworkCore;
using Serilog;

var builder = WebApplication.CreateBuilder(args);

// Configurar Serilog
Log.Logger = new LoggerConfiguration()
    .Enrich.FromLogContext()
    .WriteTo.Console()
    .CreateLogger();
builder.Host.UseSerilog();

// Add services to the container
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Database Context
var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
if (string.IsNullOrEmpty(connectionString))
{
    throw new InvalidOperationException("Connection string 'DefaultConnection' not found.");
}

builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(connectionString));

// Application Services
builder.Services.AddScoped<IErrorLogRepository, EfErrorLogRepository>();
builder.Services.AddScoped<IErrorReporter, ErrorReporter>();

// Agregar MediatR
builder.Services.AddMediatR(cfg => 
    cfg.RegisterServicesFromAssembly(typeof(ErrorService.Application.UseCases.LogError.LogErrorCommand).Assembly));

// Configurar el manejo de errores
builder.Services.AddErrorHandling("ErrorService");

// Configurar RabbitMQ
builder.Services.Configure<RabbitMQSettings>(builder.Configuration.GetSection("RabbitMQ"));
builder.Services.Configure<ErrorServiceRabbitMQSettings>(builder.Configuration.GetSection("ErrorService"));

// Registrar el consumidor RabbitMQ como hosted service
builder.Services.AddHostedService<RabbitMQErrorConsumer>();

var app = builder.Build();

// Configure the HTTP request pipeline
app.UseSerilogRequestLogging();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

// Middleware para capturar respuestas
app.UseMiddleware<ResponseCaptureMiddleware>();

// Middleware para manejo de errores
app.UseErrorHandling();

app.UseAuthorization();

app.MapControllers();

// Health check endpoint
app.MapGet("/health", () => Results.Ok("ErrorService is healthy"));

// Apply migrations on startup
using (var scope = app.Services.CreateScope())
{
    var services = scope.ServiceProvider;
    try
    {
        var context = services.GetRequiredService<ApplicationDbContext>();
        context.Database.Migrate();
        Log.Information("Database migrations applied successfully.");
    }
    catch (Exception ex)
    {
        Log.Error(ex, "An error occurred while applying database migrations.");
    }
}

Log.Information("ErrorService starting up...");
app.Run();

---- File: ErrorService.Api\Controllers\ErrorsController.cs ----
using ErrorService.Application.DTOs;
using ErrorService.Application.UseCases.GetError;
using ErrorService.Application.UseCases.GetErrors;
using ErrorService.Application.UseCases.GetErrorStats;
using ErrorService.Application.UseCases.GetServiceNames;
using ErrorService.Application.UseCases.LogError;
using ErrorService.Shared;
using MediatR;
using Microsoft.AspNetCore.Mvc;
using System;
using System.Threading.Tasks;

namespace ErrorService.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class ErrorsController : ControllerBase
    {
        private readonly IMediator _mediator;

        public ErrorsController(IMediator mediator)
        {
            _mediator = mediator;
        }

        [HttpPost]
        public async Task<ActionResult<ApiResponse<LogErrorResponse>>> LogError([FromBody] LogErrorRequest request)
        {
            var command = new LogErrorCommand(request);
            var result = await _mediator.Send(command);
            return ApiResponse<LogErrorResponse>.Ok(result);
        }

        [HttpGet]
        public async Task<ActionResult<ApiResponse<GetErrorsResponse>>> GetErrors(
            [FromQuery] string? serviceName = null,
            [FromQuery] DateTime? from = null,
            [FromQuery] DateTime? to = null,
            [FromQuery] int page = 1,
            [FromQuery] int pageSize = 50)
        {
            var request = new GetErrorsRequest(serviceName, from, to, page, pageSize);
            var query = new GetErrorsQuery(request);
            var result = await _mediator.Send(query);
            return ApiResponse<GetErrorsResponse>.Ok(result);
        }

        [HttpGet("{id:guid}")]
        public async Task<ActionResult<ApiResponse<GetErrorResponse>>> GetError(Guid id)
        {
            var request = new GetErrorRequest(id);
            var query = new GetErrorQuery(request);
            var result = await _mediator.Send(query);
            
            if (result == null)
                return NotFound(ApiResponse<object>.Fail("Error not found"));

            return ApiResponse<GetErrorResponse>.Ok(result);
        }

        [HttpGet("stats")]
        public async Task<ActionResult<ApiResponse<GetErrorStatsResponse>>> GetStats(
            [FromQuery] DateTime? from = null,
            [FromQuery] DateTime? to = null)
        {
            var request = new GetErrorStatsRequest(from, to);
            var query = new GetErrorStatsQuery(request);
            var result = await _mediator.Send(query);
            return ApiResponse<GetErrorStatsResponse>.Ok(result);
        }

        [HttpGet("services")]
        public async Task<ActionResult<ApiResponse<GetServiceNamesResponse>>> GetServiceNames()
        {
            var request = new GetServiceNamesRequest();
            var query = new GetServiceNamesQuery(request);
            var result = await _mediator.Send(query);
            return ApiResponse<GetServiceNamesResponse>.Ok(result);
        }
    }
}

---- File: ErrorService.Api\Controllers\HealthController.cs ----
using ErrorService.Shared;
using Microsoft.AspNetCore.Mvc;

namespace ErrorService.Api.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class HealthController : ControllerBase
    {
        [HttpGet]
        public ActionResult<ApiResponse<string>> Get() 
        {
            return ApiResponse<string>.Ok("ErrorService is running");
        }
    }
}

---- File: ErrorService.Application\ErrorService.Application.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="FluentValidation" Version="11.9.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ErrorService.Domain\ErrorService.Domain.csproj" />
  </ItemGroup>
  
</Project>

---- File: ErrorService.Application\DTOs\ErrorDto.cs ----
using System;
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record ErrorDto(
        Guid Id,
        string ServiceName,
        string ExceptionType,
        string Message,
        string? StackTrace,
        DateTime OccurredAt,
        string? Endpoint,
        string? HttpMethod,
        int? StatusCode,
        string? UserId,
        Dictionary<string, object> Metadata
    );
}

---- File: ErrorService.Application\DTOs\ErrorItemDto.cs ----
using System;
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record ErrorItemDto(
        Guid Id,
        string ServiceName,
        string ExceptionType,
        string Message,
        string? StackTrace,
        DateTime OccurredAt,
        string? Endpoint,
        string? HttpMethod,
        int? StatusCode,
        string? UserId,
        Dictionary<string, object> Metadata
    );
}

---- File: ErrorService.Application\DTOs\ErrorStatsDto.cs ----
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record ErrorStatsDto(
        int TotalErrors,
        int ErrorsLast24Hours,
        int ErrorsLast7Days,
        Dictionary<string, int> ErrorsByService,
        Dictionary<int, int> ErrorsByStatusCode
    );
}

---- File: ErrorService.Application\DTOs\GetErrorRequest.cs ----
using System;

namespace ErrorService.Application.DTOs
{
    public record GetErrorRequest(Guid Id);
}

---- File: ErrorService.Application\DTOs\GetErrorResponse.cs ----
using System;
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record GetErrorResponse(
        Guid Id,
        string ServiceName,
        string ExceptionType,
        string Message,
        string? StackTrace,
        DateTime OccurredAt,
        string? Endpoint,
        string? HttpMethod,
        int? StatusCode,
        string? UserId,
        Dictionary<string, object> Metadata
    );
}

---- File: ErrorService.Application\DTOs\GetErrorsRequest.cs ----
using System;

namespace ErrorService.Application.DTOs
{
    public record GetErrorsRequest(
        string? ServiceName,
        DateTime? From,
        DateTime? To,
        int Page,
        int PageSize
    );
}

---- File: ErrorService.Application\DTOs\GetErrorsResponse.cs ----
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record GetErrorsResponse(
        List<ErrorItemDto> Errors,
        int TotalCount,
        int Page,
        int PageSize
    );
}

---- File: ErrorService.Application\DTOs\GetErrorStatsRequest.cs ----
using System;

namespace ErrorService.Application.DTOs
{
    public record GetErrorStatsRequest(DateTime? From, DateTime? To);
}

---- File: ErrorService.Application\DTOs\GetErrorStatsResponse.cs ----
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record GetErrorStatsResponse(
        int TotalErrors,
        int ErrorsLast24Hours,
        int ErrorsLast7Days,
        Dictionary<string, int> ErrorsByService,
        Dictionary<int, int> ErrorsByStatusCode
    );
}

---- File: ErrorService.Application\DTOs\GetNotificationStatsResponse.cs ----
namespace NotificationService.Application.DTOs
{
    public record GetNotificationStatsResponse(
        int TotalNotifications,
        int NotificationsLast24Hours,
        int NotificationsLast7Days,
        Dictionary<string, int> NotificationsByType
    );
}

---- File: ErrorService.Application\DTOs\GetServiceNamesRequest.cs ----
namespace ErrorService.Application.DTOs
{
    public record GetServiceNamesRequest();
}

---- File: ErrorService.Application\DTOs\GetServiceNamesResponse.cs ----
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record GetServiceNamesResponse(List<string> ServiceNames);
}

---- File: ErrorService.Application\DTOs\LogErrorRequest.cs ----
using System;
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record LogErrorRequest(
        string ServiceName,
        string ExceptionType,
        string Message,
        string? StackTrace,
        DateTime? OccurredAt,
        string? Endpoint,
        string? HttpMethod,
        int? StatusCode,
        string? UserId,
        Dictionary<string, object>? Metadata
    );
}

---- File: ErrorService.Application\DTOs\LogErrorResponse.cs ----
using System;

namespace ErrorService.Application.DTOs
{
    public record LogErrorResponse(Guid ErrorId);
}

---- File: ErrorService.Application\DTOs\PaginationDto.cs ----
namespace ErrorService.Application.DTOs
{
    public record PaginationDto(int Page, int PageSize, int TotalCount, int TotalPages);
}

---- File: ErrorService.Application\DTOs\SendPushNotificationResponse.cs ----
namespace NotificationService.Application.DTOs
{
    public record SendPushNotificationResponse(Guid NotificationId, bool Success);
}

---- File: ErrorService.Application\DTOs\SendSmsNotificationResponse.cs ----
namespace NotificationService.Application.DTOs
{
    public record SendSmsNotificationResponse(Guid NotificationId, bool Success);
}

---- File: ErrorService.Application\DTOs\ServiceNamesDto.cs ----
using System.Collections.Generic;

namespace ErrorService.Application.DTOs
{
    public record ServiceNamesDto(List<string> ServiceNames);
}

---- File: ErrorService.Application\UseCases\GetError\GetErrorQuery.cs ----
using ErrorService.Application.DTOs;
using MediatR;

namespace ErrorService.Application.UseCases.GetError
{
    public record GetErrorQuery(GetErrorRequest Request) : IRequest<GetErrorResponse>;
}

---- File: ErrorService.Application\UseCases\GetError\GetErrorQueryHandler.cs ----
using ErrorService.Application.DTOs;
using ErrorService.Domain.Interfaces;
using MediatR;
using System.Threading;
using System.Threading.Tasks;

namespace ErrorService.Application.UseCases.GetError
{
    public class GetErrorQueryHandler : IRequestHandler<GetErrorQuery, GetErrorResponse?>
    {
        private readonly IErrorLogRepository _errorLogRepository;

        public GetErrorQueryHandler(IErrorLogRepository errorLogRepository)
        {
            _errorLogRepository = errorLogRepository;
        }

        public async Task<GetErrorResponse?> Handle(GetErrorQuery query, CancellationToken cancellationToken)
        {
            var errorLog = await _errorLogRepository.GetByIdAsync(query.Request.Id);
            if (errorLog == null) 
                return null; // Esto está bien con el tipo nullable

            return new GetErrorResponse(
                errorLog.Id,
                errorLog.ServiceName,
                errorLog.ExceptionType,
                errorLog.Message,
                errorLog.StackTrace,
                errorLog.OccurredAt,
                errorLog.Endpoint,
                errorLog.HttpMethod,
                errorLog.StatusCode,
                errorLog.UserId,
                errorLog.Metadata
            );
        }
    }
}

---- File: ErrorService.Application\UseCases\GetErrors\GetErrorsQuery.cs ----
using ErrorService.Application.DTOs;
using MediatR;

namespace ErrorService.Application.UseCases.GetErrors
{
    public record GetErrorsQuery(GetErrorsRequest Request) : IRequest<GetErrorsResponse>;
}

---- File: ErrorService.Application\UseCases\GetErrors\GetErrorsQueryHandler.cs ----
using ErrorService.Application.DTOs;
using ErrorService.Domain.Interfaces;
using MediatR;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace ErrorService.Application.UseCases.GetErrors
{
    public class GetErrorsQueryHandler : IRequestHandler<GetErrorsQuery, GetErrorsResponse>
    {
        private readonly IErrorLogRepository _errorLogRepository;

        public GetErrorsQueryHandler(IErrorLogRepository errorLogRepository)
        {
            _errorLogRepository = errorLogRepository;
        }

        public async Task<GetErrorsResponse> Handle(GetErrorsQuery query, CancellationToken cancellationToken)
        {
            var domainQuery = new ErrorQuery
            {
                ServiceName = query.Request.ServiceName,
                From = query.Request.From,
                To = query.Request.To,
                Page = query.Request.Page,
                PageSize = query.Request.PageSize
            };

            var errors = await _errorLogRepository.GetAsync(domainQuery);
            
            var errorItems = errors.Select(error => new ErrorItemDto(
                error.Id,
                error.ServiceName,
                error.ExceptionType,
                error.Message,
                error.StackTrace,
                error.OccurredAt,
                error.Endpoint,
                error.HttpMethod,
                error.StatusCode,
                error.UserId,
                error.Metadata
            )).ToList();

            return new GetErrorsResponse(errorItems, errorItems.Count, query.Request.Page, query.Request.PageSize);
        }
    }
}

---- File: ErrorService.Application\UseCases\GetErrorStats\GetErrorStatsQuery.cs ----
using ErrorService.Application.DTOs;
using MediatR;

namespace ErrorService.Application.UseCases.GetErrorStats
{
    public record GetErrorStatsQuery(GetErrorStatsRequest Request) : IRequest<GetErrorStatsResponse>;
}

---- File: ErrorService.Application\UseCases\GetErrorStats\GetErrorStatsQueryHandler.cs ----
using ErrorService.Application.DTOs;
using ErrorService.Domain.Interfaces;
using MediatR;
using System.Threading;
using System.Threading.Tasks;

namespace ErrorService.Application.UseCases.GetErrorStats
{
    public class GetErrorStatsQueryHandler : IRequestHandler<GetErrorStatsQuery, GetErrorStatsResponse>
    {
        private readonly IErrorLogRepository _errorLogRepository;

        public GetErrorStatsQueryHandler(IErrorLogRepository errorLogRepository)
        {
            _errorLogRepository = errorLogRepository;
        }

        public async Task<GetErrorStatsResponse> Handle(GetErrorStatsQuery query, CancellationToken cancellationToken)
        {
            var stats = await _errorLogRepository.GetStatsAsync(query.Request.From, query.Request.To);
            
            return new GetErrorStatsResponse(
                stats.TotalErrors,
                stats.ErrorsLast24Hours,
                stats.ErrorsLast7Days,
                stats.ErrorsByService,
                stats.ErrorsByStatusCode
            );
        }
    }
}

---- File: ErrorService.Application\UseCases\GetServiceNames\GetServiceNamesQuery.cs ----
using ErrorService.Application.DTOs;
using MediatR;

namespace ErrorService.Application.UseCases.GetServiceNames
{
    public record GetServiceNamesQuery(GetServiceNamesRequest Request) : IRequest<GetServiceNamesResponse>;
}

---- File: ErrorService.Application\UseCases\GetServiceNames\GetServiceNamesQueryHandler.cs ----
using ErrorService.Application.DTOs;
using ErrorService.Domain.Interfaces;
using MediatR;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace ErrorService.Application.UseCases.GetServiceNames
{
    public class GetServiceNamesQueryHandler : IRequestHandler<GetServiceNamesQuery, GetServiceNamesResponse>
    {
        private readonly IErrorLogRepository _errorLogRepository;

        public GetServiceNamesQueryHandler(IErrorLogRepository errorLogRepository)
        {
            _errorLogRepository = errorLogRepository;
        }

        public async Task<GetServiceNamesResponse> Handle(GetServiceNamesQuery query, CancellationToken cancellationToken)
        {
            var serviceNames = await _errorLogRepository.GetServiceNamesAsync();
            return new GetServiceNamesResponse(serviceNames.ToList());
        }
    }
}

---- File: ErrorService.Application\UseCases\LogError\LogErrorCommand.cs ----
using ErrorService.Application.DTOs;
using MediatR;

namespace ErrorService.Application.UseCases.LogError
{
    public record LogErrorCommand(LogErrorRequest Request) : IRequest<LogErrorResponse>;
}

---- File: ErrorService.Application\UseCases\LogError\LogErrorCommandHandler.cs ----
using ErrorService.Application.DTOs;
using ErrorService.Domain.Entities;
using ErrorService.Domain.Interfaces;
using MediatR;
using System.Threading;
using System.Threading.Tasks;

namespace ErrorService.Application.UseCases.LogError
{
    public class LogErrorCommandHandler : IRequestHandler<LogErrorCommand, LogErrorResponse>
    {
        private readonly IErrorLogRepository _errorLogRepository;

        public LogErrorCommandHandler(IErrorLogRepository errorLogRepository)
        {
            _errorLogRepository = errorLogRepository;
        }

        public async Task<LogErrorResponse> Handle(LogErrorCommand command, CancellationToken cancellationToken)
        {
            var errorLog = new ErrorLog
            {
                Id = System.Guid.NewGuid(),
                ServiceName = command.Request.ServiceName,
                ExceptionType = command.Request.ExceptionType,
                Message = command.Request.Message,
                StackTrace = command.Request.StackTrace,
                OccurredAt = command.Request.OccurredAt ?? System.DateTime.UtcNow,
                Endpoint = command.Request.Endpoint,
                HttpMethod = command.Request.HttpMethod,
                StatusCode = command.Request.StatusCode,
                UserId = command.Request.UserId,
                Metadata = command.Request.Metadata ?? new System.Collections.Generic.Dictionary<string, object>()
            };

            await _errorLogRepository.AddAsync(errorLog);
            
            return new LogErrorResponse(errorLog.Id);
        }
    }
}

---- File: ErrorService.Application\UseCases\LogError\LogErrorCommandValidator.cs ----
using FluentValidation;
using ErrorService.Application.DTOs;

namespace ErrorService.Application.UseCases.LogError
{
    public class LogErrorCommandValidator : AbstractValidator<LogErrorRequest>
    {
        public LogErrorCommandValidator()
        {
            RuleFor(x => x.ServiceName)
                .NotEmpty().WithMessage("Service name is required")
                .MaximumLength(100).WithMessage("Service name must not exceed 100 characters");

            RuleFor(x => x.ExceptionType)
                .NotEmpty().WithMessage("Exception type is required")
                .MaximumLength(200).WithMessage("Exception type must not exceed 200 characters");

            RuleFor(x => x.Message)
                .NotEmpty().WithMessage("Error message is required");

            RuleFor(x => x.Endpoint)
                .MaximumLength(500).WithMessage("Endpoint must not exceed 500 characters");

            RuleFor(x => x.HttpMethod)
                .MaximumLength(10).WithMessage("HTTP method must not exceed 10 characters");

            RuleFor(x => x.UserId)
                .MaximumLength(100).WithMessage("User ID must not exceed 100 characters");
        }
    }
}

---- File: ErrorService.Domain\ErrorService.Domain.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>

---- File: ErrorService.Domain\Entities\ErrorLog.cs ----
using System;
using System.Collections.Generic;

namespace ErrorService.Domain.Entities
{
    public class ErrorLog
    {
        public Guid Id { get; set; }
        public string ServiceName { get; set; } = null!;
        public string ExceptionType { get; set; } = null!;
        public string Message { get; set; } = null!;
        public string? StackTrace { get; set; }
        public DateTime OccurredAt { get; set; }
        public string? Endpoint { get; set; }
        public string? HttpMethod { get; set; }
        public int? StatusCode { get; set; }
        public string? UserId { get; set; }
        public Dictionary<string, object> Metadata { get; set; } = new Dictionary<string, object>();
    }
}

---- File: ErrorService.Domain\Interfaces\IErrorLogRepository.cs ----
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ErrorService.Domain.Entities;

namespace ErrorService.Domain.Interfaces
{
    public interface IErrorLogRepository
    {
        Task<ErrorLog?> GetByIdAsync(Guid id);
        Task<IEnumerable<ErrorLog>> GetAsync(ErrorQuery query);
        Task AddAsync(ErrorLog errorLog);
        Task DeleteAsync(Guid id);
        Task<IEnumerable<string>> GetServiceNamesAsync();
        Task<ErrorStats> GetStatsAsync(DateTime? from = null, DateTime? to = null);
    }

    public class ErrorQuery
    {
        public string? ServiceName { get; set; }
        public DateTime? From { get; set; }
        public DateTime? To { get; set; }
        public int Page { get; set; } = 1;
        public int PageSize { get; set; } = 50;
    }

    public class ErrorStats
    {
        public int TotalErrors { get; set; }
        public int ErrorsLast24Hours { get; set; }
        public int ErrorsLast7Days { get; set; }
        public Dictionary<string, int> ErrorsByService { get; set; } = new Dictionary<string, int>();
        public Dictionary<int, int> ErrorsByStatusCode { get; set; } = new Dictionary<int, int>();
    }
}

---- File: ErrorService.Domain\Interfaces\IErrorReporter.cs ----
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace ErrorService.Domain.Interfaces
{
    public interface IErrorReporter
    {
        Task<Guid> ReportErrorAsync(ErrorReport request);
    }

    public class ErrorReport
    {
        public string ServiceName { get; set; } = null!;
        public string ExceptionType { get; set; } = null!;
        public string Message { get; set; } = null!;
        public string? StackTrace { get; set; }
        public DateTime OccurredAt { get; set; }
        public string? Endpoint { get; set; }
        public string? HttpMethod { get; set; }
        public int? StatusCode { get; set; }
        public string? UserId { get; set; }
        public Dictionary<string, object> Metadata { get; set; } = new Dictionary<string, object>();
    }
}

---- File: ErrorService.Infrastructure\ErrorService.Infrastructure.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.8" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.8">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" Version="8.0.8">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.8" />
    <PackageReference Include="Elastic.Clients.Elasticsearch" Version="8.13.0" />
    <PackageReference Include="Microsoft.Extensions.Configuration.Abstractions" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
    <PackageReference Include="MediatR" Version="12.2.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ErrorService.Domain\ErrorService.Domain.csproj" />
    <ProjectReference Include="..\ErrorService.Application\ErrorService.Application.csproj" />
    <ProjectReference Include="..\ErrorService.Shared\ErrorService.Shared.csproj" />
  </ItemGroup>

</Project>

---- File: ErrorService.Infrastructure\External\ElasticSearchService.cs ----
using ErrorService.Domain.Entities;
using Elastic.Clients.Elasticsearch;
using Elastic.Transport;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace ErrorService.Infrastructure.External
{
    public class ElasticSearchSettings
    {
        public string ConnectionString { get; set; } = "http://localhost:9200";
        public string DefaultIndex { get; set; } = "errorlogs";
        public string Username { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
        public bool Enable { get; set; } = false;
    }

    public class ElasticSearchService
    {
        private readonly ElasticsearchClient? _client; // HACER NULLABLE
        private readonly ILogger<ElasticSearchService> _logger;
        private readonly ElasticSearchSettings _settings;

        public ElasticSearchService(IOptions<ElasticSearchSettings> settings, ILogger<ElasticSearchService> logger)
        {
            _settings = settings.Value;
            _logger = logger;

            if (!_settings.Enable)
            {
                _client = null;
                return;
            }

            try
            {
                var config = new ElasticsearchClientSettings(new Uri(_settings.ConnectionString))
                    .DefaultIndex(_settings.DefaultIndex);

                // Configurar autenticación si se proporciona
                if (!string.IsNullOrEmpty(_settings.Username) && !string.IsNullOrEmpty(_settings.Password))
                {
                    config.Authentication(new BasicAuthentication(_settings.Username, _settings.Password));
                }

                _client = new ElasticsearchClient(config);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to initialize Elasticsearch client");
                _client = null;
            }
        }

        public async Task IndexErrorAsync(ErrorLog errorLog)
        {
            if (_client == null || !_settings.Enable)
            {
                _logger.LogDebug("Elasticsearch is disabled, skipping error indexing.");
                return;
            }

            try
            {
                var response = await _client.IndexAsync(errorLog, _settings.DefaultIndex);
                
                if (!response.IsValidResponse)
                {
                    _logger.LogWarning("Failed to index error log in Elasticsearch: {DebugInfo}", response.DebugInformation);
                }
                else
                {
                    _logger.LogInformation("Successfully indexed error log {ErrorId} in Elasticsearch", errorLog.Id);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error indexing error log in Elasticsearch");
            }
        }

        public async Task<IEnumerable<ErrorLog>> SearchErrorsAsync(string searchTerm, int page = 1, int pageSize = 50)
        {
            if (_client == null || !_settings.Enable)
            {
                _logger.LogDebug("Elasticsearch is disabled, returning empty search results.");
                return Enumerable.Empty<ErrorLog>();
            }

            try
            {
                var response = await _client.SearchAsync<ErrorLog>(s => s
                    .Index(_settings.DefaultIndex)
                    .From((page - 1) * pageSize)
                    .Size(pageSize)
                    .Query(q => q
                        .MultiMatch(m => m
                            .Fields(new[] { "message", "exceptionType", "serviceName" })
                            .Query(searchTerm)
                        )
                    )
                );

                if (response.IsValidResponse)
                {
                    return response.Documents;
                }

                _logger.LogWarning("Elasticsearch search failed: {DebugInfo}", response.DebugInformation);
                return Enumerable.Empty<ErrorLog>();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error searching error logs in Elasticsearch");
                return Enumerable.Empty<ErrorLog>();
            }
        }

        public async Task<bool> IsHealthyAsync()
        {
            if (_client == null || !_settings.Enable)
                return false;

            try
            {
                var response = await _client.PingAsync();
                return response.IsValidResponse;
            }
            catch
            {
                return false;
            }
        }
    }
}

---- File: ErrorService.Infrastructure\Migrations\20251023014417_InitialCreate.cs ----
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace ErrorService.Infrastructure.Migrations
{
    /// <inheritdoc />
    public partial class InitialCreate : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "error_logs",
                columns: table => new
                {
                    id = table.Column<Guid>(type: "uuid", nullable: false),
                    service_name = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
                    exception_type = table.Column<string>(type: "character varying(200)", maxLength: 200, nullable: false),
                    message = table.Column<string>(type: "text", nullable: false),
                    stack_trace = table.Column<string>(type: "text", nullable: true),
                    occurred_at = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
                    endpoint = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: true),
                    http_method = table.Column<string>(type: "character varying(10)", maxLength: 10, nullable: true),
                    status_code = table.Column<int>(type: "integer", nullable: true),
                    user_id = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: true),
                    metadata = table.Column<string>(type: "jsonb", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_error_logs", x => x.id);
                });

            migrationBuilder.CreateIndex(
                name: "IX_error_logs_occurred_at",
                table: "error_logs",
                column: "occurred_at");

            migrationBuilder.CreateIndex(
                name: "IX_error_logs_service_name",
                table: "error_logs",
                column: "service_name");

            migrationBuilder.CreateIndex(
                name: "IX_error_logs_service_name_occurred_at",
                table: "error_logs",
                columns: new[] { "service_name", "occurred_at" });

            migrationBuilder.CreateIndex(
                name: "IX_error_logs_status_code",
                table: "error_logs",
                column: "status_code");

            migrationBuilder.CreateIndex(
                name: "IX_error_logs_user_id",
                table: "error_logs",
                column: "user_id");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "error_logs");
        }
    }
}

---- File: ErrorService.Infrastructure\Migrations\20251023014417_InitialCreate.Designer.cs ----
// <auto-generated />
using System;
using ErrorService.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace ErrorService.Infrastructure.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    [Migration("20251023014417_InitialCreate")]
    partial class InitialCreate
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("ErrorService.Domain.Entities.ErrorLog", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid")
                        .HasColumnName("id");

                    b.Property<string>("Endpoint")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)")
                        .HasColumnName("endpoint");

                    b.Property<string>("ExceptionType")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("character varying(200)")
                        .HasColumnName("exception_type");

                    b.Property<string>("HttpMethod")
                        .HasMaxLength(10)
                        .HasColumnType("character varying(10)")
                        .HasColumnName("http_method");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("text")
                        .HasColumnName("message");

                    b.Property<string>("Metadata")
                        .IsRequired()
                        .HasColumnType("jsonb")
                        .HasColumnName("metadata");

                    b.Property<DateTime>("OccurredAt")
                        .HasColumnType("timestamp with time zone")
                        .HasColumnName("occurred_at");

                    b.Property<string>("ServiceName")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)")
                        .HasColumnName("service_name");

                    b.Property<string>("StackTrace")
                        .HasColumnType("text")
                        .HasColumnName("stack_trace");

                    b.Property<int?>("StatusCode")
                        .HasColumnType("integer")
                        .HasColumnName("status_code");

                    b.Property<string>("UserId")
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)")
                        .HasColumnName("user_id");

                    b.HasKey("Id");

                    b.HasIndex("OccurredAt");

                    b.HasIndex("ServiceName");

                    b.HasIndex("StatusCode");

                    b.HasIndex("UserId");

                    b.HasIndex("ServiceName", "OccurredAt");

                    b.ToTable("error_logs", (string)null);
                });
#pragma warning restore 612, 618
        }
    }
}

---- File: ErrorService.Infrastructure\Migrations\ApplicationDbContextModelSnapshot.cs ----
// <auto-generated />
using System;
using ErrorService.Infrastructure.Persistence;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;

#nullable disable

namespace ErrorService.Infrastructure.Migrations
{
    [DbContext(typeof(ApplicationDbContext))]
    partial class ApplicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.8")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("ErrorService.Domain.Entities.ErrorLog", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid")
                        .HasColumnName("id");

                    b.Property<string>("Endpoint")
                        .HasMaxLength(500)
                        .HasColumnType("character varying(500)")
                        .HasColumnName("endpoint");

                    b.Property<string>("ExceptionType")
                        .IsRequired()
                        .HasMaxLength(200)
                        .HasColumnType("character varying(200)")
                        .HasColumnName("exception_type");

                    b.Property<string>("HttpMethod")
                        .HasMaxLength(10)
                        .HasColumnType("character varying(10)")
                        .HasColumnName("http_method");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("text")
                        .HasColumnName("message");

                    b.Property<string>("Metadata")
                        .IsRequired()
                        .HasColumnType("jsonb")
                        .HasColumnName("metadata");

                    b.Property<DateTime>("OccurredAt")
                        .HasColumnType("timestamp with time zone")
                        .HasColumnName("occurred_at");

                    b.Property<string>("ServiceName")
                        .IsRequired()
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)")
                        .HasColumnName("service_name");

                    b.Property<string>("StackTrace")
                        .HasColumnType("text")
                        .HasColumnName("stack_trace");

                    b.Property<int?>("StatusCode")
                        .HasColumnType("integer")
                        .HasColumnName("status_code");

                    b.Property<string>("UserId")
                        .HasMaxLength(100)
                        .HasColumnType("character varying(100)")
                        .HasColumnName("user_id");

                    b.HasKey("Id");

                    b.HasIndex("OccurredAt");

                    b.HasIndex("ServiceName");

                    b.HasIndex("StatusCode");

                    b.HasIndex("UserId");

                    b.HasIndex("ServiceName", "OccurredAt");

                    b.ToTable("error_logs", (string)null);
                });
#pragma warning restore 612, 618
        }
    }
}

---- File: ErrorService.Infrastructure\Persistence\ApplicationDbContext.cs ----
using ErrorService.Domain.Entities;
using Microsoft.EntityFrameworkCore;

namespace ErrorService.Infrastructure.Persistence
{
    public class ApplicationDbContext : DbContext
    {
        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }

        public DbSet<ErrorLog> ErrorLogs => Set<ErrorLog>();

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
            
            // Aplicar todas las configuraciones desde este assembly
            modelBuilder.ApplyConfigurationsFromAssembly(typeof(ApplicationDbContext).Assembly);
        }
    }
}

---- File: ErrorService.Infrastructure\Persistence\EfErrorLogRepository.cs ----
using ErrorService.Domain.Entities;
using ErrorService.Domain.Interfaces;
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace ErrorService.Infrastructure.Persistence
{
    public class EfErrorLogRepository : IErrorLogRepository
    {
        private readonly ApplicationDbContext _context;

        public EfErrorLogRepository(ApplicationDbContext context)
        {
            _context = context;
        }

        public async Task<ErrorLog?> GetByIdAsync(Guid id)
        {
            return await _context.ErrorLogs.FindAsync(id);
        }

        public async Task<IEnumerable<ErrorLog>> GetAsync(ErrorQuery query)
        {
            var dbQuery = _context.ErrorLogs.AsQueryable();

            // Aplicar filtros
            if (!string.IsNullOrWhiteSpace(query.ServiceName))
            {
                dbQuery = dbQuery.Where(e => e.ServiceName == query.ServiceName);
            }

            if (query.From.HasValue)
            {
                dbQuery = dbQuery.Where(e => e.OccurredAt >= query.From.Value);
            }

            if (query.To.HasValue)
            {
                dbQuery = dbQuery.Where(e => e.OccurredAt <= query.To.Value);
            }

            // Ordenar y paginar
            dbQuery = dbQuery.OrderByDescending(e => e.OccurredAt)
                            .Skip((query.Page - 1) * query.PageSize)
                            .Take(query.PageSize);

            return await dbQuery.ToListAsync();
        }

        public async Task AddAsync(ErrorLog errorLog)
        {
            _context.ErrorLogs.Add(errorLog);
            await _context.SaveChangesAsync();
        }

        public async Task DeleteAsync(Guid id)
        {
            var errorLog = await _context.ErrorLogs.FindAsync(id);
            if (errorLog != null)
            {
                _context.ErrorLogs.Remove(errorLog);
                await _context.SaveChangesAsync();
            }
        }

        public async Task<IEnumerable<string>> GetServiceNamesAsync()
        {
            return await _context.ErrorLogs
                .Select(e => e.ServiceName)
                .Distinct()
                .OrderBy(name => name)
                .ToListAsync();
        }

        public async Task<ErrorStats> GetStatsAsync(DateTime? from = null, DateTime? to = null)
        {
            var query = _context.ErrorLogs.AsQueryable();

            // Aplicar filtros de fecha
            if (from.HasValue)
            {
                query = query.Where(e => e.OccurredAt >= from.Value);
            }

            if (to.HasValue)
            {
                query = query.Where(e => e.OccurredAt <= to.Value);
            }

            var totalErrors = await query.CountAsync();

            var errorsLast24Hours = await _context.ErrorLogs
                .Where(e => e.OccurredAt >= DateTime.UtcNow.AddHours(-24))
                .CountAsync();

            var errorsLast7Days = await _context.ErrorLogs
                .Where(e => e.OccurredAt >= DateTime.UtcNow.AddDays(-7))
                .CountAsync();

            var errorsByService = await query
                .GroupBy(e => e.ServiceName)
                .Select(g => new { ServiceName = g.Key, Count = g.Count() })
                .ToDictionaryAsync(x => x.ServiceName, x => x.Count);

            // CORREGIR esta línea (probablemente la línea 110)
            var errorsByStatusCode = await query
                .Where(e => e.StatusCode.HasValue)
                .GroupBy(e => e.StatusCode!.Value) // Usar ! para indicar que no es null
                .Select(g => new { StatusCode = g.Key, Count = g.Count() })
                .ToDictionaryAsync(x => x.StatusCode, x => x.Count);

            return new ErrorStats
            {
                TotalErrors = totalErrors,
                ErrorsLast24Hours = errorsLast24Hours,
                ErrorsLast7Days = errorsLast7Days,
                ErrorsByService = errorsByService,
                ErrorsByStatusCode = errorsByStatusCode
            };
        }
    }
}

---- File: ErrorService.Infrastructure\Persistence\Configurations\ErrorLogConfiguration.cs ----
using ErrorService.Domain.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using System.Text.Json;

namespace ErrorService.Infrastructure.Persistence.Configurations
{
    public class ErrorLogConfiguration : IEntityTypeConfiguration<ErrorLog>
    {
        public void Configure(EntityTypeBuilder<ErrorLog> builder)
        {
            builder.ToTable("error_logs");

            // Primary Key
            builder.HasKey(e => e.Id);

            // Properties
            builder.Property(e => e.Id)
                .HasColumnName("id")
                .IsRequired();

            builder.Property(e => e.ServiceName)
                .HasColumnName("service_name")
                .IsRequired()
                .HasMaxLength(100);

            builder.Property(e => e.ExceptionType)
                .HasColumnName("exception_type")
                .IsRequired()
                .HasMaxLength(200);

            builder.Property(e => e.Message)
                .HasColumnName("message")
                .IsRequired();

            builder.Property(e => e.StackTrace)
                .HasColumnName("stack_trace");

            builder.Property(e => e.OccurredAt)
                .HasColumnName("occurred_at")
                .IsRequired();

            builder.Property(e => e.Endpoint)
                .HasColumnName("endpoint")
                .HasMaxLength(500);

            builder.Property(e => e.HttpMethod)
                .HasColumnName("http_method")
                .HasMaxLength(10);

            builder.Property(e => e.StatusCode)
                .HasColumnName("status_code");

            builder.Property(e => e.UserId)
                .HasColumnName("user_id")
                .HasMaxLength(100);

            // Configuración para el diccionario de metadatos (JSONB en PostgreSQL)
            builder.Property(e => e.Metadata)
                .HasColumnName("metadata")
                .HasColumnType("jsonb")
                .HasConversion(
                    v => JsonSerializer.Serialize(v, new JsonSerializerOptions()),
                    v => JsonSerializer.Deserialize<Dictionary<string, object>>(v, new JsonSerializerOptions()) ?? new Dictionary<string, object>()
                );

            // Índices para búsquedas comunes
            builder.HasIndex(e => e.ServiceName);
            builder.HasIndex(e => e.OccurredAt);
            builder.HasIndex(e => e.StatusCode);
            builder.HasIndex(e => e.UserId);
            builder.HasIndex(e => new { e.ServiceName, e.OccurredAt });
        }
    }
}

---- File: ErrorService.Infrastructure\Services\ErrorReporter.cs ----
using ErrorService.Application.DTOs;
using ErrorService.Application.UseCases.LogError;
using ErrorService.Domain.Interfaces;
using MediatR;
using System;
using System.Threading.Tasks;

namespace ErrorService.Infrastructure.Services
{
    public class ErrorReporter : IErrorReporter
    {
        private readonly IMediator _mediator;

        public ErrorReporter(IMediator mediator)
        {
            _mediator = mediator;
        }

        public async Task<Guid> ReportErrorAsync(ErrorReport request)
        {
            // Usar el constructor del record con todos los parámetros
            var logRequest = new LogErrorRequest(
                request.ServiceName,
                request.ExceptionType,
                request.Message,
                request.StackTrace,
                request.OccurredAt,
                request.Endpoint,
                request.HttpMethod,
                request.StatusCode,
                request.UserId,
                request.Metadata
            );

            var command = new LogErrorCommand(logRequest);
            var result = await _mediator.Send(command);
            return result.ErrorId;
        }
    }
}

---- File: ErrorService.Infrastructure\Services\Messaging\RabbitMQErrorConsumer.cs ----
using ErrorService.Domain.Entities;
using ErrorService.Domain.Interfaces;
using ErrorService.Shared.ErrorMessages;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using System.Text;
using System.Text.Json;

namespace ErrorService.Infrastructure.Services.Messaging;

public class RabbitMQSettings
{
    public string Host { get; set; } = "localhost";
    public int Port { get; set; } = 5672;
    public string Username { get; set; } = "guest";
    public string Password { get; set; } = "guest";
    public string VirtualHost { get; set; } = "/";
}

public class ErrorServiceRabbitMQSettings
{
    public string QueueName { get; set; } = "error-queue";
    public string ExchangeName { get; set; } = "error-exchange";
    public string RoutingKey { get; set; } = "error.routing.key";
}

public class RabbitMQErrorConsumer : BackgroundService
{
    private readonly IConnection _connection;
    private readonly IModel _channel;
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<RabbitMQErrorConsumer> _logger;
    private readonly ErrorServiceRabbitMQSettings _settings;
    private readonly JsonSerializerOptions _jsonOptions;

    public RabbitMQErrorConsumer(
        IOptions<RabbitMQSettings> rabbitMqSettings,
        IOptions<ErrorServiceRabbitMQSettings> errorServiceSettings,
        IServiceProvider serviceProvider,
        ILogger<RabbitMQErrorConsumer> logger)
    {
        _serviceProvider = serviceProvider;
        _logger = logger;
        _settings = errorServiceSettings.Value;

        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        };

        try
        {
            var factory = new ConnectionFactory
            {
                HostName = rabbitMqSettings.Value.Host,
                Port = rabbitMqSettings.Value.Port,
                UserName = rabbitMqSettings.Value.Username,
                Password = rabbitMqSettings.Value.Password,
                VirtualHost = rabbitMqSettings.Value.VirtualHost,
                DispatchConsumersAsync = true
            };

            _connection = factory.CreateConnection();
            _channel = _connection.CreateModel();

            // Declarar exchange y queue (mismo que el productor)
            _channel.ExchangeDeclare(
                exchange: _settings.ExchangeName,
                type: ExchangeType.Direct,
                durable: true,
                autoDelete: false);

            _channel.QueueDeclare(
                queue: _settings.QueueName,
                durable: true,
                exclusive: false,
                autoDelete: false,
                arguments: null);

            _channel.QueueBind(
                queue: _settings.QueueName,
                exchange: _settings.ExchangeName,
                routingKey: _settings.RoutingKey);

            _channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);

            _logger.LogInformation("RabbitMQ Error Consumer initialized successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to initialize RabbitMQ Error Consumer");
            throw;
        }
    }

    protected override Task ExecuteAsync(CancellationToken stoppingToken)
    {
        stoppingToken.ThrowIfCancellationRequested();

        var consumer = new AsyncEventingBasicConsumer(_channel);
        consumer.Received += async (model, ea) =>
        {
            var body = ea.Body.ToArray();
            var message = Encoding.UTF8.GetString(body);

            try
            {
                await ProcessMessageAsync(message, ea.DeliveryTag);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing RabbitMQ message");
                // Reject and requeue the message
                _channel.BasicNack(ea.DeliveryTag, multiple: false, requeue: true);
            }
        };

        _channel.BasicConsume(
            queue: _settings.QueueName,
            autoAck: false,
            consumer: consumer);

        return Task.CompletedTask;
    }

    private async Task ProcessMessageAsync(string message, ulong deliveryTag)
    {
        try
        {
            var errorEvent = JsonSerializer.Deserialize<RabbitMQErrorEvent>(message, _jsonOptions);
            if (errorEvent == null)
            {
                _logger.LogWarning("Received null or invalid error event from RabbitMQ");
                _channel.BasicAck(deliveryTag, multiple: false);
                return;
            }

            using var scope = _serviceProvider.CreateScope();
            var errorLogRepository = scope.ServiceProvider.GetRequiredService<IErrorLogRepository>();

            // Convertir RabbitMQErrorEvent a ErrorLog entity
            var errorLog = new ErrorLog
            {
                Id = Guid.Parse(errorEvent.Id),
                ServiceName = errorEvent.ServiceName,
                ExceptionType = errorEvent.ErrorCode,
                Message = errorEvent.ErrorMessage,
                StackTrace = errorEvent.StackTrace,
                OccurredAt = errorEvent.Timestamp,
                Endpoint = errorEvent.Endpoint,
                HttpMethod = errorEvent.HttpMethod,
                StatusCode = errorEvent.StatusCode,
                UserId = errorEvent.UserId,
                Metadata = errorEvent.Metadata ?? new Dictionary<string, object>()
            };

            await errorLogRepository.AddAsync(errorLog);

            _logger.LogInformation("Successfully processed error event from {ServiceName}: {ErrorCode}",
                errorEvent.ServiceName, errorEvent.ErrorCode);

            // Acknowledge the message
            _channel.BasicAck(deliveryTag, multiple: false);
        }
        catch (JsonException jsonEx)
        {
            _logger.LogError(jsonEx, "Failed to deserialize RabbitMQ message");
            // Reject and don't requeue malformed messages
            _channel.BasicNack(deliveryTag, multiple: false, requeue: false);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unexpected error processing RabbitMQ message");
            // Reject and requeue for transient errors
            _channel.BasicNack(deliveryTag, multiple: false, requeue: true);
        }
    }

    public override void Dispose()
    {
        _channel?.Close();
        _channel?.Dispose();
        _connection?.Close();
        _connection?.Dispose();
        base.Dispose();
    }
}

---- File: ErrorService.Shared\ErrorService.Shared.csproj ----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Http.Abstractions" Version="2.2.0" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="8.0.0" />
    <PackageReference Include="RabbitMQ.Client" Version="6.8.1" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\ErrorService.Domain\ErrorService.Domain.csproj" />
  </ItemGroup>

</Project>

---- File: ErrorService.Shared\ErrorMessages\RabbitMQErrorEvent.cs ----
using System.Text.Json.Serialization;

namespace ErrorService.Shared.ErrorMessages;

public class RabbitMQErrorEvent
{
    [JsonPropertyName("id")]
    public string Id { get; set; } = Guid.NewGuid().ToString();

    [JsonPropertyName("serviceName")]
    public string ServiceName { get; set; } = "UnknownService";

    [JsonPropertyName("errorCode")]
    public string ErrorCode { get; set; } = string.Empty;

    [JsonPropertyName("errorMessage")]
    public string ErrorMessage { get; set; } = string.Empty;

    [JsonPropertyName("stackTrace")]
    public string? StackTrace { get; set; }

    [JsonPropertyName("timestamp")]
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;

    [JsonPropertyName("userId")]
    public string? UserId { get; set; }

    [JsonPropertyName("endpoint")]
    public string? Endpoint { get; set; }

    [JsonPropertyName("httpMethod")]
    public string? HttpMethod { get; set; }

    [JsonPropertyName("statusCode")]
    public int? StatusCode { get; set; }

    [JsonPropertyName("metadata")]
    public Dictionary<string, object> Metadata { get; set; } = new();

    [JsonPropertyName("environment")]
    public string Environment { get; set; } = "Development";
}

---- File: ErrorService.Shared\Exceptions\AppException.cs ----
using System;

namespace ErrorService.Shared.Exceptions
{
    public class AppException : Exception
    {
        public int StatusCode { get; }

        public AppException(string message, int statusCode = 400) : base(message)
        {
            StatusCode = statusCode;
        }
    }
}

---- File: ErrorService.Shared\Exceptions\BadGatewayException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class BadRequestException : AppException
    {
        public BadRequestException(string message) : base(message, 400) { }
    }
}

---- File: ErrorService.Shared\Exceptions\BadRequestException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class BadGatewayException : AppException
    {
        public BadGatewayException(string message) : base(message, 502) { }
    }
}

---- File: ErrorService.Shared\Exceptions\ConflictException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class ConflictException : AppException
    {
        public ConflictException(string message) : base(message, 409) { }
    }
}

---- File: ErrorService.Shared\Exceptions\ForbiddenException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class ForbiddenException : AppException
    {
        public ForbiddenException(string message) : base(message, 403) { }
    }
}

---- File: ErrorService.Shared\Exceptions\GatewayTimeoutException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class GatewayTimeoutException : AppException
    {
        public GatewayTimeoutException(string message) : base(message, 504) { }
    }
}

---- File: ErrorService.Shared\Exceptions\LengthRequiredException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class LengthRequiredException : AppException
    {
        public LengthRequiredException(string message) : base(message, 411) { }
    }
}

---- File: ErrorService.Shared\Exceptions\MethodNotAllowedException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class MethodNotAllowedException : AppException
    {
        public MethodNotAllowedException(string message) : base(message, 405) { }
    }
}

---- File: ErrorService.Shared\Exceptions\NotAcceptableException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class NotAcceptableException : AppException
    {
        public NotAcceptableException(string message) : base(message, 406) { }
    }
}

---- File: ErrorService.Shared\Exceptions\NotFoundException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class NotFoundException : AppException
    {
        public NotFoundException(string message) : base(message, 404) { }
    }
}

---- File: ErrorService.Shared\Exceptions\NotImplementedServiceException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class NotImplementedServiceException : AppException
    {
        public NotImplementedServiceException(string message) : base(message, 501) { }
    }
}

---- File: ErrorService.Shared\Exceptions\PreconditionFailedException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class PreconditionFailedException : AppException
    {
        public PreconditionFailedException(string message) : base(message, 412) { }
    }
}

---- File: ErrorService.Shared\Exceptions\ServiceUnavailableException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class ServiceUnavailableException : AppException
    {
        public ServiceUnavailableException(string message) : base(message, 503) { }
    }
}

---- File: ErrorService.Shared\Exceptions\TooManyRequestsException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class TooManyRequestsException : AppException
    {
        public TooManyRequestsException(string message) : base(message, 429) { }
    }
}

---- File: ErrorService.Shared\Exceptions\UnauthorizedException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class UnauthorizedException : AppException
    {
        public UnauthorizedException(string message) : base(message, 401) { }
    }
}

---- File: ErrorService.Shared\Exceptions\UnprocessableEntityException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class UnprocessableEntityException : AppException
    {
        public UnprocessableEntityException(string message) : base(message, 422) { }
    }
}

---- File: ErrorService.Shared\Exceptions\UnsupportedMediaTypeException.cs ----
namespace ErrorService.Shared.Exceptions
{
    public class UnsupportedMediaTypeException : AppException
    {
        public UnsupportedMediaTypeException(string message) : base(message, 415) { }
    }
}

---- File: ErrorService.Shared\Exceptions\ValidationException.cs ----
using System.Collections.Generic;

namespace ErrorService.Shared.Exceptions
{
    public class ValidationException : AppException
    {
        public IDictionary<string, string[]> Errors { get; }

        public ValidationException(IDictionary<string, string[]> errors) 
            : base("Validation failed", 422)
        {
            Errors = errors;
        }
    }
}

---- File: ErrorService.Shared\Extensions\ErrorHandlingExtensions.cs ----
using ErrorService.Domain.Interfaces;
using ErrorService.Shared.Middleware;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

namespace ErrorService.Shared.Extensions
{
    public static class ErrorHandlingExtensions
    {
        public static IServiceCollection AddErrorHandling(this IServiceCollection services, string serviceName)
        {
            services.AddSingleton(new ErrorHandlingMiddlewareOptions { ServiceName = serviceName });
            return services;
        }

        public static IApplicationBuilder UseErrorHandling(this IApplicationBuilder app)
        {
            var serviceName = app.ApplicationServices.GetService<ErrorHandlingMiddlewareOptions>()?.ServiceName ?? "UnknownService";
            var errorReporter = app.ApplicationServices.GetRequiredService<IErrorReporter>();
            
            return app.UseMiddleware<ErrorHandlingMiddleware>(errorReporter, serviceName);
        }
    }

    public class ErrorHandlingMiddlewareOptions
    {
        public string ServiceName { get; set; } = "UnknownService";
    }
}   

---- File: ErrorService.Shared\Extensions\ServiceCollectionExtensions.cs ----
using ErrorService.Shared.Middleware;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

namespace ErrorService.Shared.Extensions
{
    public static class ServiceCollectionExtensions
    {
        public static IServiceCollection AddErrorHandling(this IServiceCollection services)
        {
            services.AddScoped<ErrorHandlingMiddleware>();
            return services;
        }

        // public static IApplicationBuilder UseErrorHandling(this IApplicationBuilder app)
        // {
        //     app.UseMiddleware<ErrorHandlingMiddleware>();
        //     return app;
        // }
    }
}

---- File: ErrorService.Shared\Middleware\ErrorHandlingMiddleware.cs ----
using ErrorService.Domain.Interfaces;
using ErrorService.Shared.Exceptions;
using Microsoft.AspNetCore.Http;
using Serilog;
using System.Text.Json;

namespace ErrorService.Shared.Middleware
{
    public class ErrorHandlingMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly IErrorReporter _errorReporter;
        private readonly string _serviceName;

        public ErrorHandlingMiddleware(
            RequestDelegate next, 
            IErrorReporter errorReporter, 
            string serviceName = "UnknownService")
        {
            _next = next;
            _errorReporter = errorReporter;
            _serviceName = serviceName;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            try
            {
                await _next(context);
                
                if (context.Response.StatusCode == StatusCodes.Status400BadRequest)
                {
                    await CaptureValidationErrorAsync(context);
                }
            }
            catch (AppException appEx)
            {
                await HandleExceptionAsync(appEx, context, appEx.StatusCode);
            }
            catch (Exception ex)
            {
                await HandleExceptionAsync(ex, context, StatusCodes.Status500InternalServerError);
            }
        }

        private async Task HandleExceptionAsync(Exception exception, HttpContext context, int statusCode)
        {
            Log.Error(exception, "Unhandled exception in {ServiceName}", _serviceName);

            await StoreErrorInDatabase(exception, context, statusCode);

            context.Response.StatusCode = statusCode;
            
            var response = new 
            { 
                success = false, 
                error = exception is AppException ? exception.Message : "Internal server error.",
                traceId = context.TraceIdentifier
            };
            
            await context.Response.WriteAsJsonAsync(response);
        }

        private async Task CaptureValidationErrorAsync(HttpContext context)
        {
            try
            {
                if (context.Items.TryGetValue("ResponseBody", out var responseBodyObj) && 
                    responseBodyObj is string responseBody)
                {
                    var validationDetails = TryParseValidationResponse(responseBody);

                    var errorRequest = new ErrorReport
                    {
                        ServiceName = _serviceName,
                        ExceptionType = "ValidationError",
                        Message = "Request validation failed",
                        StackTrace = null,
                        OccurredAt = DateTime.UtcNow,
                        Endpoint = context.Request.Path,
                        HttpMethod = context.Request.Method,
                        StatusCode = StatusCodes.Status400BadRequest,
                        UserId = context.User?.FindFirst("sub")?.Value,
                        Metadata = new Dictionary<string, object>
                        {
                            ["RequestId"] = context.TraceIdentifier,
                            ["RequestQuery"] = context.Request.QueryString.ToString(),
                            ["UserAgent"] = context.Request.Headers.UserAgent.ToString(),
                            ["ClientIp"] = context.Connection.RemoteIpAddress?.ToString() ?? "unknown",
                            ["ValidationDetails"] = validationDetails,
                            ["ErrorType"] = "FluentValidation",
                            ["ServiceName"] = _serviceName
                        }
                    };

                    await _errorReporter.ReportErrorAsync(errorRequest);
                }
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to capture validation error");
            }
        }

        private string TryParseValidationResponse(string responseBody)
        {
            try
            {
                using var document = JsonDocument.Parse(responseBody);
                if (document.RootElement.TryGetProperty("errors", out var errors))
                {
                    return errors.ToString();
                }
                if (document.RootElement.TryGetProperty("error", out var error))
                {
                    return error.GetString() ?? responseBody;
                }
            }
            catch
            {
                // Si no se puede parsear, devolver el cuerpo original
            }
            return responseBody;
        }

        private async Task StoreErrorInDatabase(Exception exception, HttpContext context, int statusCode)
        {
            try
            {
                var errorRequest = new ErrorReport
                {
                    ServiceName = _serviceName,
                    ExceptionType = exception.GetType().Name,
                    Message = exception.Message,
                    StackTrace = exception.StackTrace,
                    OccurredAt = DateTime.UtcNow,
                    Endpoint = context.Request.Path,
                    HttpMethod = context.Request.Method,
                    StatusCode = statusCode,
                    UserId = context.User?.FindFirst("sub")?.Value,
                    Metadata = new Dictionary<string, object>
                    {
                        ["RequestId"] = context.TraceIdentifier,
                        ["RequestQuery"] = context.Request.QueryString.ToString(),
                        ["UserAgent"] = context.Request.Headers.UserAgent.ToString(),
                        ["ClientIp"] = context.Connection.RemoteIpAddress?.ToString() ?? "unknown",
                        ["ServiceName"] = _serviceName
                    }
                };

                await _errorReporter.ReportErrorAsync(errorRequest);
            }
            catch (Exception logEx)
            {
                Log.Error(logEx, "Failed to store error in ErrorService database");
            }
        }
    }
}

---- File: ErrorService.Shared\Middleware\ResponseCaptureMiddleware.cs ----
using Microsoft.AspNetCore.Http;
using System.IO;
using System.Threading.Tasks;

namespace ErrorService.Shared.Middleware
{
    public class ResponseCaptureMiddleware
    {
        private readonly RequestDelegate _next;

        public ResponseCaptureMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            var originalBodyStream = context.Response.Body;
            
            using var responseBody = new MemoryStream();
            context.Response.Body = responseBody;

            await _next(context);

            responseBody.Seek(0, SeekOrigin.Begin);
            await responseBody.CopyToAsync(originalBodyStream);
            context.Response.Body = originalBodyStream;
            
            // Guardar el cuerpo de la respuesta para que el ErrorHandlingMiddleware pueda leerlo
            responseBody.Seek(0, SeekOrigin.Begin);
            var responseBodyContent = await new StreamReader(responseBody).ReadToEndAsync();
            context.Items["ResponseBody"] = responseBodyContent;
        }
    }
}

---- File: ErrorService.Shared\Models\ApiResponse.cs ----
namespace ErrorService.Shared
{
    public class ApiResponse<T>
    {
        public bool Success { get; set; }
        public T? Data { get; set; }
        public string? Error { get; set; }

        public static ApiResponse<T> Ok(T data) => new() { Success = true, Data = data };
        public static ApiResponse<T> Fail(string error) => new() { Success = false, Error = error };
    }
}

